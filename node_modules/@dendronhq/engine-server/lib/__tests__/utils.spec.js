"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_test_utils_1 = require("@dendronhq/common-test-utils");
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("../utils");
function createFileLink(data) {
    let cleanData = lodash_1.default.defaults(data, { type: "file" });
    return {
        from: {
            fname: "foo",
        },
        type: "ref",
        data: cleanData,
    };
}
describe("matchEmbedMarker", () => {
    test("basic", () => {
        // @ts-ignore
        expect(utils_1.matchRefMarker("<!--(([[class.mba.chapters.2]]))-->")[1]).toEqual("[[class.mba.chapters.2]]");
    });
});
describe("parseFileLink", () => {
    it("just file", () => {
        expect(utils_1.parseFileLink("[[foo]]")).toEqual(createFileLink());
    });
    it("one anchor", () => {
        expect(utils_1.parseFileLink("[[foo]]#head1")).toEqual(createFileLink({ anchorStart: "head1" }));
    });
    it("all parts", () => {
        expect(utils_1.parseFileLink("[[foo]]#head1:#head2")).toEqual(createFileLink({ anchorStart: "head1", anchorEnd: "head2" }));
    });
    it("next anchor", () => {
        expect(utils_1.parseFileLink("[[foo]]#head1:#*")).toEqual(createFileLink({ anchorStart: "head1", anchorEnd: "*" }));
    });
});
describe("link2String", () => {
    test("file", () => {
        expect(utils_1.refLink2String({
            type: "ref",
            from: {
                fname: "foo",
            },
            data: {
                type: "file",
            },
        })).toEqual("[[foo]]");
    });
    it("one anchor", () => {
        expect(utils_1.refLink2String(createFileLink({ anchorStart: "head1" }))).toEqual("[[foo]]#head1");
    });
    it("all parts", () => {
        expect(utils_1.refLink2String(createFileLink({
            anchorEnd: "head2",
            anchorStart: "head1",
        }))).toEqual("[[foo]]#head1:#head2");
    });
    it("next anchor", () => {
        expect(utils_1.refLink2String(createFileLink({
            anchorEnd: "*",
            anchorStart: "head1",
        }))).toEqual("[[foo]]#head1:#*");
    });
});
describe("parseRef", () => {
    it("describe file ref without extension", () => {
        expect(utils_1.parseDendronRef("ref: [[foo]]")).toEqual({
            direction: "to",
            link: createFileLink(),
        });
    });
    it("describe file ref", () => {
        expect(utils_1.parseDendronRef("ref: [[foo.md]]")).toEqual({
            direction: "to",
            link: createFileLink(),
        });
    });
    it("describe file ref with anchor", () => {
        expect(utils_1.parseDendronRef("ref: [[foo.md]]#head1")).toEqual({
            direction: "to",
            link: createFileLink({ anchorStart: "head1" }),
        });
    });
    it("describe file ref with anchor start and end", () => {
        expect(utils_1.parseDendronRef("ref: [[foo.md]]#head1:#head2")).toEqual({
            direction: "to",
            link: createFileLink({ anchorStart: "head1", anchorEnd: "head2" }),
        });
    });
    it("describe file ref with anchor start and end, start offset", () => {
        expect(utils_1.parseDendronRef("ref: [[foo.md]]#head1,1:#head2")).toEqual({
            direction: "to",
            link: createFileLink({
                anchorStart: "head1",
                anchorEnd: "head2",
                anchorStartOffset: 1,
            }),
        });
    });
});
const FILE_TEXT = `
# Head 1

Head 1 Text

## Head 2.1

Head 2.1 Text

### Head 2.1.1

Head 2.1.1 Text

## Head 2.2

Head 2.2 Text`;
describe("extractBlock", () => {
    it("no anchor", () => {
        expect(utils_1.extractBlock(FILE_TEXT, createFileLink()).block).toEqual(FILE_TEXT);
    });
    it("anchor start", () => {
        expect(utils_1.extractBlock(FILE_TEXT, createFileLink({
            anchorStart: "Head 2.1",
        })).block).toEqual(lodash_1.default.trim(`
## Head 2.1

Head 2.1 Text

### Head 2.1.1

Head 2.1.1 Text

## Head 2.2

Head 2.2 Text`));
    });
    it("anchor start alt", () => {
        const txt = ["", `# Tasks`, "task1", "task2"];
        expect(utils_1.extractBlock(txt.join("\n"), createFileLink({
            anchorStart: "Tasks",
        })).block).toEqual(lodash_1.default.trim(txt.join("\n")));
    });
    it("anchor stard and end", () => {
        expect(utils_1.extractBlock(FILE_TEXT, createFileLink({
            anchorStart: "Head 2.1",
            anchorEnd: "Head 2.2",
        })).block).toEqual(lodash_1.default.trim(`
## Head 2.1

Head 2.1 Text

### Head 2.1.1

Head 2.1.1 Text`));
    });
});
describe("replaceRefWithMPEImport", () => {
    let root;
    beforeEach(async () => {
        root = await common_test_utils_1.EngineTestUtilsV2.setupVault({
            initDirCb: async (vaultPath) => {
                await common_test_utils_1.FileTestUtils.createFiles(vaultPath, [
                    {
                        path: "ref.md",
                        body: `---
id: 5668f5ec-0db3-4530-812d-f8bb4f3c551b
title: ref
desc: ref test
---

# head1

Header 1 text

## head2.1

Header 2 text

## head2.2

head 2.2 text

## head2.3

head w.3 text
          `,
                    },
                ]);
            },
        });
    });
    it("basic", () => {
        expect(utils_1.replaceRefWithMPEImport("((ref:[[foo]]))", {
            root,
        })).toEqual('@import "foo.md"');
    });
    it("anchor start", () => {
        expect(utils_1.replaceRefWithMPEImport("((ref:[[ref]]#head2.1))", {
            root,
        })).toEqual('@import "ref.md" {line_begin=10}');
    });
    it("anchor start and end", () => {
        expect(utils_1.replaceRefWithMPEImport("((ref:[[ref]]#head2.1:#head2.3))", {
            root,
        })).toEqual('@import "ref.md" {line_begin=10 line_end=18}');
    });
});
describe("stripLocalOnlyTags", () => {
    it("basic", () => {
        const txt = `
- this is a bullet
    - this is a secret <!--LOCAL_ONLY_LINE-->
`;
        expect(lodash_1.default.trim(utils_1.stripLocalOnlyTags(txt))).toEqual("- this is a bullet");
    });
});
//# sourceMappingURL=utils.spec.js.map