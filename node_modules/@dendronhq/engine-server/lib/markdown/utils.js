"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MDUtilsV4 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const remark_1 = __importDefault(require("remark"));
const remark_parse_1 = __importDefault(require("remark-parse"));
const remark_frontmatter_1 = __importDefault(require("remark-frontmatter"));
const wikiLinks_1 = require("./remark/wikiLinks");
const lodash_1 = __importDefault(require("lodash"));
const noteRefs_1 = require("./remark/noteRefs");
const types_1 = require("./types");
const dendronPub_1 = require("./remark/dendronPub");
const toString = require("mdast-util-to-string");
class MDUtilsV4 {
    static findIndex(array, fn) {
        for (var i = 0; i < array.length; i++) {
            if (fn(array[i], i)) {
                return i;
            }
        }
        return -1;
    }
    static getDendronData(proc) {
        return proc.data("dendron");
    }
    static setDendronData(proc, data) {
        const _data = proc.data("dendron");
        return proc.data("dendron", { ..._data, ...data });
    }
    static getEngineFromProc(proc) {
        const engine = proc.data("engine");
        let error;
        if (lodash_1.default.isUndefined(engine) || lodash_1.default.isNull(engine)) {
            error = new common_all_1.DendronError({ msg: "engine not defined" });
        }
        return {
            error,
            engine,
        };
    }
    static getNoteRefLvl(proc) {
        return proc.data("noteRefLvl") || 0;
    }
    static setNoteRefLvl(proc, lvl) {
        return proc.data("noteRefLvl", lvl);
    }
    static isHeading(node, text, depth) {
        if (node.type !== "heading") {
            return false;
        }
        // wildcard is always true
        if (text === "*") {
            return true;
        }
        if (text) {
            var headingText = toString(node);
            return text.trim().toLowerCase() === headingText.trim().toLowerCase();
        }
        if (depth) {
            return node.depth <= depth;
        }
        return true;
    }
    static proc(opts) {
        const { engine } = opts;
        const errors = [];
        let _proc = remark_1.default()
            .use(remark_parse_1.default, { gfm: true })
            .data("errors", errors)
            .data("engine", engine)
            .use(remark_frontmatter_1.default, ["yaml"])
            .use({ settings: { listItemIndent: "1", fences: true, bullet: "-" } });
        return _proc;
    }
    static procFull(opts) {
        const { dest, vault } = opts;
        const proc = this.proc(opts)
            .data("dendron", { dest, vault })
            .use(wikiLinks_1.wikiLinks, opts.wikiLinksOpts)
            .use(noteRefs_1.noteRefs, { ...opts.noteRefOpts, wikiLinkOpts: opts.wikiLinksOpts });
        if (dest === types_1.DendronASTDest.HTML) {
            return proc.use(dendronPub_1.dendronPub, opts.publishOpts);
        }
        return proc;
    }
}
exports.MDUtilsV4 = MDUtilsV4;
//# sourceMappingURL=utils.js.map