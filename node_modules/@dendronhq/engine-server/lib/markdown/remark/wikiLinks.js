"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.wikiLinks = exports.LINK_REGEX = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const types_1 = require("../types");
const utils_1 = require("../utils");
const utils_2 = require("./utils");
exports.LINK_REGEX = /^\[\[(.+?)\]\]/;
function parseAnchorIfExist(link) {
    if (link.indexOf("#") !== -1) {
        return link.split("#");
    }
    else {
        return [link, undefined];
    }
}
const plugin = function (opts) {
    attachParser(this);
    if (this.Compiler != null) {
        attachCompiler(this, opts);
    }
};
exports.wikiLinks = plugin;
function attachCompiler(proc, opts) {
    const copts = lodash_1.default.defaults(opts || {}, {
        convertObsidianLinks: false,
        useId: false,
    });
    const Compiler = proc.Compiler;
    const visitors = Compiler.prototype.visitors;
    const { dest, vault } = utils_1.MDUtilsV4.getDendronData(proc);
    if (visitors) {
        visitors.wikiLink = function (node) {
            const data = node.data;
            let value = node.value;
            const { error, engine } = utils_1.MDUtilsV4.getEngineFromProc(proc);
            if (error) {
                utils_2.addError(proc, error);
                return "error with engine";
            }
            if (copts.useId) {
                // TODO: check for vault
                const notes = common_all_1.NoteUtilsV2.getNotesByFname({
                    fname: value,
                    notes: engine.notes,
                    vault,
                });
                const { error, note } = utils_2.getNoteOrError(notes, value);
                if (error) {
                    utils_2.addError(proc, error);
                    return "error with link";
                }
                else {
                    value = note.id;
                }
            }
            switch (dest) {
                case types_1.DendronASTDest.MD_REGULAR: {
                    const alias = data.alias ? data.alias : value;
                    return `[${alias}](${copts.prefix || ""}${value})`;
                }
                case types_1.DendronASTDest.MD_ENHANCED_PREVIEW: {
                    const alias = data.alias ? data.alias : value;
                    return `[${alias}](${copts.prefix || ""}${parseAnchorIfExist(value)[0]}.md)`;
                }
                case types_1.DendronASTDest.HTML: {
                    const alias = data.alias ? data.alias : value;
                    return `[${alias}](${copts.prefix || ""}${value}.html)`;
                }
                default:
                    return `unhandled case: ${dest}`;
            }
        };
    }
}
function attachParser(proc) {
    function locator(value, fromIndex) {
        return value.indexOf("[", fromIndex);
    }
    function parseAliasLink(pageTitle) {
        const [alias, value] = pageTitle.split("|").map(lodash_1.default.trim);
        return { alias, value: common_all_1.NoteUtilsV2.normalizeFname(value) };
    }
    function parseLink(linkMatch) {
        linkMatch = common_all_1.NoteUtilsV2.normalizeFname(linkMatch);
        let out = {
            value: linkMatch,
            alias: linkMatch,
        };
        if (utils_2.LinkUtils.isAlias(linkMatch)) {
            out = parseAliasLink(linkMatch);
        }
        if (out.value.indexOf("#") !== -1) {
            const [value, anchorHeader] = out.value.split("#").map(lodash_1.default.trim);
            out.value = value;
            out.anchorHeader = anchorHeader;
            // if we didn't have an alias, links with a # anchor shouldn't have # portion be in the title
            if (!utils_2.LinkUtils.isAlias(linkMatch)) {
                out.alias = value;
            }
        }
        return out;
    }
    function inlineTokenizer(eat, value) {
        const match = exports.LINK_REGEX.exec(value);
        if (match) {
            const linkMatch = match[1].trim();
            const { value, alias, anchorHeader } = parseLink(linkMatch);
            return eat(match[0])({
                type: "wikiLink",
                value,
                data: {
                    alias,
                    anchorHeader,
                },
            });
        }
        return;
    }
    inlineTokenizer.locator = locator;
    const Parser = proc.Parser;
    const inlineTokenizers = Parser.prototype.inlineTokenizers;
    const inlineMethods = Parser.prototype.inlineMethods;
    inlineTokenizers.wikiLink = inlineTokenizer;
    inlineMethods.splice(inlineMethods.indexOf("link"), 0, "wikiLink");
}
//# sourceMappingURL=wikiLinks.js.map