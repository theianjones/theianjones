"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_test_utils_1 = require("@dendronhq/common-test-utils");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const noteRefs_1 = require("../noteRefs");
const utils_2 = require("./utils");
function proc(engine, dendron, opts) {
    return utils_1.MDUtilsV4.proc({ engine })
        .data("dendron", dendron)
        .use(noteRefs_1.noteRefs, opts);
}
describe.skip("parse", () => {
    let engine;
    let dest;
    test("init", () => {
        const resp = proc(engine, { dest }).parse(`((ref: [[foo.md]]))`);
        expect(resp).toMatchSnapshot();
        // @ts-ignore
        expect(resp.children[0].children[0].type).toEqual("refLink");
    });
    test("doesn't parse inline code block", () => {
        const resp = proc(engine, { dest }).parse("`((ref: [[foo.md]]))`");
        expect(resp).toMatchSnapshot("bond");
        // @ts-ignore
        expect(resp.children[0].children[0].type).toEqual("inlineCode");
    });
});
// future
// type TestCase<TData, TExpected> = {
//   testCase: string;
//   data: TData;
//   expected: TExpected;
// };
describe("compilev2", () => {
    const linkWithNoExtension = "((ref: [[foo]]))";
    function createTestCases(opts) {
        const { name, setupFunc, verifyFuncDict } = opts;
        return Object.values(types_1.DendronASTDest).map((dest) => {
            const verifyFunc = verifyFuncDict[dest];
            return {
                name,
                dest,
                testCase: new common_test_utils_1.TestPresetEntryV4(async (presetOpts) => {
                    const extra = await setupFunc({ ...presetOpts, extra: { dest } });
                    return await verifyFunc({ ...presetOpts, extra });
                }, { preSetupHook: opts.preSetupHook }),
            };
        });
    }
    const REGULAR_CASE = createTestCases({
        name: "regular",
        setupFunc: async ({ engine, vaults, extra }) => {
            const resp = await proc(engine, {
                dest: extra.dest,
                vault: vaults[0],
            }).process(linkWithNoExtension);
            return { resp, proc };
        },
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["foo body"],
                        }),
                        expected: true,
                    },
                ];
            },
            [types_1.DendronASTDest.HTML]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["foo body", "portal"],
                        }),
                        expected: true,
                    },
                ];
            },
            [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: async ({ extra }) => {
                const { resp } = extra;
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["foo body", "portal"],
                        }),
                        expected: true,
                    },
                ];
            },
        },
        preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupBasic,
    });
    const RECURSIVE_TEST_CASES = createTestCases({
        name: "recursive",
        setupFunc: async ({ engine, extra, vaults }) => {
            const resp = await proc(engine, {
                dest: extra.dest,
                vault: vaults[0],
            }).process(linkWithNoExtension);
            return { resp, proc };
        },
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["# Foo", "# Foo.One", "# Foo.Two"],
                        }),
                        expected: true,
                    },
                ];
            },
            [types_1.DendronASTDest.HTML]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["# Foo", "# Foo.One", "# Foo.Two", "portal"],
                        }),
                        expected: true,
                    },
                ];
            },
            [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["# Foo", "# Foo.One", "# Foo.Two", "portal"],
                        }),
                        expected: true,
                    },
                ];
            },
        },
        preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupNoteRefRecursive,
    });
    const WILDCARD_CASE = createTestCases({
        name: "wildcard",
        setupFunc: async ({ engine, extra, vaults }) => {
            const note = engine.notes["id.journal"];
            const resp = await proc(engine, {
                dest: extra.dest,
                vault: vaults[0],
            }).process(note.body);
            return { resp, proc };
        },
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra, engine }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                // @ts-ignore
                return common_test_utils_1.ENGINE_SERVER.NOTE_REF.WILDCARD_LINK_V4.genTestResults({
                    engine,
                    extra: { body: resp.toString() },
                });
            },
            [types_1.DendronASTDest.HTML]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
            },
            [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
            },
        },
        preSetupHook: common_test_utils_1.ENGINE_SERVER.NOTE_REF.WILDCARD_LINK_V4.preSetupHook,
    });
    const ALL_TEST_CASES = [
        ...REGULAR_CASE,
        ...RECURSIVE_TEST_CASES,
        ...WILDCARD_CASE,
    ];
    //const ALL_TEST_CASES = WILDCARD_CASE;
    describe("compile", () => {
        test.each(ALL_TEST_CASES.map((ent) => [`${ent.dest}: ${ent.name}`, ent.testCase]))("%p", async (_key, testCase) => {
            await common_test_utils_1.runEngineTestV4(testCase.testFunc, {
                expect,
                createEngine: utils_2.createEngine,
                preSetupHook: testCase.preSetupHook,
            });
        });
    });
});
//# sourceMappingURL=noteRefs.spec.js.map