"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stripLocalOnlyTags = exports.replaceRefWithMPEImport = exports.matchRefMarker = exports.parseFileLink = exports.parseDendronRef = exports.extractBlock = exports.writeWSMetaFile = exports.openWSMetaFile = exports.openPortFile = exports.getWSMetaFilePath = exports.getPortFilePath = exports.getEngine = exports.refLink2String = exports.loc2Path = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const markdown_it_1 = __importDefault(require("markdown-it"));
// @ts-ignoreig
const markdown_it_ast_1 = __importDefault(require("markdown-it-ast"));
const path_1 = __importDefault(require("path"));
const engineClient_1 = require("./engineClient");
const markdownIt = markdown_it_1.default();
exports.loc2Path = ({ loc, wsRoot, }) => {
    const fname = loc.fname;
    if (!loc.vault) {
        throw new common_all_1.DendronError({ msg: "no vault for loc, loc2Path" });
    }
    const fpath = common_server_1.resolvePath(loc.vault.fsPath, wsRoot);
    return path_1.default.join(fpath, fname + ".md");
};
function normalize(text) {
    return lodash_1.default.toLower(lodash_1.default.trim(text, " #"));
}
/**
 * take a ref link and parse it as regular markdown
 */
function refLink2String(link, opts) {
    const cleanOpts = lodash_1.default.defaults(opts, {
        includeParen: false,
        includeRefTag: false,
    });
    const { anchorStart, anchorStartOffset, anchorEnd } = link.data;
    const { fname: name } = link.from;
    // [[foo]]#head1:#*"
    const linkParts = [`[[${name}]]`];
    if (anchorStart) {
        linkParts.push(`#${normalize(anchorStart)}`);
    }
    if (anchorStartOffset) {
        linkParts.push(`,${anchorStartOffset}`);
    }
    if (anchorEnd) {
        linkParts.push(`:#${normalize(anchorEnd)}`);
    }
    if (cleanOpts.includeRefTag) {
        linkParts.splice(0, 0, "ref: ");
    }
    if (cleanOpts.includeParen) {
        linkParts.splice(0, 0, "((");
        linkParts.push("))");
    }
    return linkParts.join("");
}
exports.refLink2String = refLink2String;
// const testString = "<!--(([[class.mba.chapters.2]]))-->";
function genAST(txt) {
    const tokens = markdownIt.parse(txt, {});
    return markdown_it_ast_1.default.makeAST(tokens);
}
async function getEngine(opts) {
    const { numTries, wsRoot, vaults } = lodash_1.default.defaults(opts, { numTries: 5 });
    if (numTries <= 0) {
        return {
            error: new common_all_1.DendronError({ msg: "exceeded numTries" }),
        };
    }
    return new Promise((resolve, _reject) => {
        try {
            const port = engineClient_1.DendronEngineClient.getPort({ wsRoot });
            const dendronEngine = engineClient_1.DendronEngineClient.create({
                port,
                ws: wsRoot,
                vaults: vaults.map((ent) => ent.fsPath),
            });
            resolve({
                data: dendronEngine,
            });
        }
        catch (err) {
            setTimeout(() => {
                resolve(getEngine({ ...opts, numTries: numTries - 1 }));
            }, 5000);
        }
    });
}
exports.getEngine = getEngine;
function getPortFilePath({ wsRoot }) {
    const portFile = path_1.default.join(wsRoot, common_all_1.CONSTANTS.DENDRON_SERVER_PORT);
    return portFile;
}
exports.getPortFilePath = getPortFilePath;
function getWSMetaFilePath({ wsRoot }) {
    const fsPath = path_1.default.join(wsRoot, common_all_1.CONSTANTS.DENDRON_WS_META);
    return fsPath;
}
exports.getWSMetaFilePath = getWSMetaFilePath;
function openPortFile({ fpath }) {
    return lodash_1.default.toInteger(lodash_1.default.trim(fs_extra_1.default.readFileSync(fpath, { encoding: "utf8" })));
}
exports.openPortFile = openPortFile;
function openWSMetaFile({ fpath }) {
    return fs_extra_1.default.readJSONSync(fpath);
}
exports.openWSMetaFile = openWSMetaFile;
function writeWSMetaFile({ fpath, data, }) {
    return fs_extra_1.default.writeJSONSync(fpath, data);
}
exports.writeWSMetaFile = writeWSMetaFile;
function extractBlock(txt, link
//opts?: { linesOnly?: boolean }
) {
    // const copts = _.defaults(opts, { linesOnly: false });
    const { anchorStart, anchorEnd, type } = link.data;
    if (type === "id") {
        throw Error(`id link not supported`);
    }
    else {
        //txt = _.trim(txt);
        if (!anchorStart) {
            return { block: txt };
        }
        const ast = genAST(txt);
        const clean = {
            anchorStart: lodash_1.default.trim(anchorStart),
            anchorEnd: lodash_1.default.trim(anchorEnd),
        };
        const out = {
            anchorStart: null,
            anchorEnd: null,
        };
        ast.forEach((ent) => {
            if (ent.nodeType === "heading") {
                const matchKey = lodash_1.default.isNull(out["anchorStart"])
                    ? "anchorStart"
                    : "anchorEnd";
                if (lodash_1.default.trim(ent.children[0].content) === clean[matchKey]) {
                    out[matchKey] = ent.openNode.map;
                }
            }
        });
        const txtAsLines = txt.split("\n");
        if (lodash_1.default.isNull(out.anchorStart)) {
            return { block: "invalid link" };
        }
        const start = out.anchorStart[0] - 1;
        const end = lodash_1.default.isNull(out["anchorEnd"])
            ? txtAsLines.length
            : out["anchorEnd"][0];
        const block = lodash_1.default.trim(txtAsLines.slice(start, end).join("\n"));
        return { block, lines: { start, end } };
    }
}
exports.extractBlock = extractBlock;
function parseDendronRef(ref) {
    const [idOrRef, ...rest] = lodash_1.default.trim(ref).split(":");
    const cleanArgs = lodash_1.default.trim(rest.join(":"));
    let link;
    let direction;
    if (idOrRef === "ref") {
        direction = "to";
        link = parseLink(cleanArgs);
    }
    else {
        throw Error(`parse non ref not implemented, ref: ${ref}`);
    }
    return { direction, link };
}
exports.parseDendronRef = parseDendronRef;
function parseFileLink(ref) {
    var _a;
    const wikiFileName = /([^\]:]+)/.source;
    const reLink = new RegExp("" +
        /\[\[/.source +
        `(?<name>${wikiFileName})` +
        /\]\]/.source +
        `(${new RegExp(
        // anchor start
        "" +
            /#?/.source +
            `(?<anchorStart>${wikiFileName})` +
            // anchor stop
            `(:#(?<anchorEnd>${wikiFileName}))?`).source})?`, "i");
    const groups = (_a = reLink.exec(ref)) === null || _a === void 0 ? void 0 : _a.groups;
    const clean = {
        type: "file",
    };
    let fname;
    lodash_1.default.each(groups, (v, k) => {
        if (lodash_1.default.isUndefined(v)) {
            return;
        }
        if (k === "name") {
            fname = path_1.default.basename(v, ".md");
        }
        else {
            // @ts-ignore
            clean[k] = v;
        }
    });
    if (lodash_1.default.isUndefined(fname)) {
        throw new common_all_1.DendronError({ msg: `fname for ${ref} is undefined` });
    }
    if (clean.anchorStart && clean.anchorStart.indexOf(",") >= 0) {
        const [anchorStart, offset] = clean.anchorStart.split(",");
        clean.anchorStart = anchorStart;
        clean.anchorStartOffset = parseInt(offset);
    }
    return { from: { fname }, data: clean, type: "ref" };
}
exports.parseFileLink = parseFileLink;
// export function parseIdLink(ref: string): DendronRefLink {
//     const reLink = /(?<id>[^:]+)(:([^:]+))?/;
// };
function parseLink(ref) {
    if (ref.indexOf("]") >= 0) {
        return parseFileLink(ref);
    }
    else {
        throw Error(`parseLink, non-file link, not implemented, ${ref}`);
    }
}
exports.matchRefMarker = (txt) => {
    return txt.match(/\(\((?<ref>[^)]+)\)\)/);
};
exports.replaceRefWithMPEImport = (line, opts) => {
    const match = exports.matchRefMarker(line);
    let prefix = `@import`;
    if (!match || !match.groups) {
        return line;
    }
    const ref = match.groups["ref"];
    if (!ref) {
        return line;
    }
    const { link } = parseDendronRef(ref);
    // unsupported
    if (!link || !link.from.fname) {
        return line;
    }
    const { fname: name } = link.from;
    const { anchorEnd, anchorStart } = link.data;
    const fsPath = path_1.default.join(opts.root, name + ".md");
    prefix += ` "${name + ".md"}"`;
    if (!anchorStart) {
        return prefix;
    }
    // {line_begin=2 line_end=10}
    const offset = [];
    //TODO: will be more sophisticated when multi-vault
    // @ts-ignore
    const { content, matter } = common_server_1.readMD(fsPath);
    // the last --- isn't counted, shoud be +1
    // but since mpe is 0 delimited, it cancels each other out
    const fmOffset = matter.split("\n").length;
    // @ts-ignore
    const { lines } = extractBlock(content, link);
    // TODO: throw error
    if (!(lines === null || lines === void 0 ? void 0 : lines.start)) {
        return line;
    }
    // +1 because extract block does -1 for 0-indexing file
    // +1 because header block gets parsed form line before
    const pad = 2 + fmOffset;
    offset.push(`line_begin=${lines.start + pad}`);
    if (anchorEnd) {
        // everything up to header is counted here
        offset.push(`line_end=${lines.end + pad - 1}`);
    }
    prefix += ` {${offset.join(" ")}}`;
    return prefix;
};
function stripLocalOnlyTags(doc) {
    const re = new RegExp(/(?<raw>.+<!--LOCAL_ONLY_LINE-->)/);
    let matches;
    do {
        matches = doc.match(re);
        if (matches) {
            // @ts-ignore
            const { raw, body } = matches.groups;
            doc = doc.replace(raw, "");
        }
    } while (matches);
    return doc;
}
exports.stripLocalOnlyTags = stripLocalOnlyTags;
//# sourceMappingURL=utils.js.map