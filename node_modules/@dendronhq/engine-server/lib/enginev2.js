"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEngine = exports.DendronEngineV2 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const config_1 = require("./config");
const storev2_1 = require("./drivers/file/storev2");
const fuseEngine_1 = require("./fuseEngine");
const utilsv2_1 = require("./topics/markdown/utilsv2");
class DendronEngineV2 {
    constructor(props) {
        this.wsRoot = props.wsRoot;
        this.configRoot = props.wsRoot;
        this.store = props.store;
        this.logger = props.logger;
        this.props = props;
        this.fuseEngine = new fuseEngine_1.FuseEngine({});
        this.links = [];
        this.vaultsv3 = props.vaultsv3;
        this.vaults = props.vaultsv3.map((ent) => ent.fsPath);
    }
    static createV3({ vaults, wsRoot, logger, }) {
        const LOGGER = logger || common_server_1.createLogger();
        return new DendronEngineV2({
            wsRoot,
            vaultsv3: vaults,
            forceNew: true,
            store: new storev2_1.FileStorageV2({
                wsRoot,
                vaultsv3: vaults,
                logger: LOGGER,
            }),
            mode: "fuzzy",
            logger: LOGGER,
        });
    }
    static instance({ vaults, wsRoot }) {
        if (!DendronEngineV2._instance) {
            DendronEngineV2._instance = DendronEngineV2.createV3({ vaults, wsRoot });
        }
        return DendronEngineV2._instance;
    }
    get notes() {
        return this.store.notes;
    }
    get schemas() {
        return this.store.schemas;
    }
    /**
     * Does not throw error but returns it
     */
    async init() {
        try {
            const { data, error } = await this.store.init();
            const { notes, schemas } = data;
            this.updateIndex("note");
            this.updateIndex("schema");
            return {
                error,
                data: { notes, schemas },
            };
        }
        catch (error) {
            const { message, stack, msg, status, friendly } = error;
            let payload = { message, stack };
            return {
                error: new common_all_1.DendronError({ payload, msg, status, friendly }),
                data: {
                    notes: {},
                    schemas: {},
                },
            };
        }
    }
    async deleteNote(id, opts) {
        try {
            const note = this.notes[id];
            const changed = await this.store.deleteNote(id, opts);
            const noteChangeEntry = lodash_1.default.find(changed, (ent) => ent.note.id === id);
            if (noteChangeEntry.status === "delete") {
                await this.fuseEngine.removeNoteFromIndex(note);
            }
            return {
                data: changed,
                error: null,
            };
        }
        catch (err) {
            return {
                data: [],
                error: err,
            };
        }
    }
    async deleteSchema(id, opts) {
        try {
            const data = (await this.store.deleteSchema(id, opts));
            // deleted schema might affect notes
            await this.updateIndex("note");
            await this.updateIndex("schema");
            return data;
            // FIXM:E not performant
            // const smod = this.schemas[id];
            // await this.fuseEngine.removeSchemaFromIndex(smod);
            // return {
            //   data: undefined,
            //   error: null,
            // };
        }
        catch (err) {
            return {
                data: {
                    notes: {},
                    schemas: {},
                },
                error: err,
            };
        }
    }
    async getNoteByPath({ npath, createIfNew, vault, }) {
        const ctx = "getNoteByPath";
        this.logger.debug({ ctx, npath, createIfNew, msg: "enter" });
        const maybeNote = common_all_1.NoteUtilsV2.getNoteByFnameV4({
            fname: npath,
            notes: this.notes,
            vault,
        });
        this.logger.debug({ ctx, maybeNote, msg: "post-query" });
        let noteNew = maybeNote;
        let changed = [];
        let error = null;
        let updateExisting = false;
        if ((!maybeNote || maybeNote.stub) && createIfNew) {
            this.logger.debug({ ctx, maybeNote, msg: "create-new" });
            if (maybeNote === null || maybeNote === void 0 ? void 0 : maybeNote.stub) {
                noteNew = maybeNote;
                delete noteNew.stub;
                updateExisting = true;
            }
            else {
                noteNew = common_all_1.NoteUtilsV2.createWithSchema({
                    noteOpts: { fname: npath, vault },
                    engine: this,
                });
            }
            changed = (await this.writeNote(noteNew, { updateExisting })).data;
        }
        if (!createIfNew && !maybeNote) {
            error = new common_all_1.DendronError({ status: "no_note_found" });
        }
        await this.refreshNotesV2(changed);
        return {
            data: { note: noteNew, changed },
            error,
        };
    }
    async getConfig() {
        const cpath = config_1.DConfig.configPath(this.configRoot);
        const config = common_server_1.readYAML(cpath);
        return {
            error: null,
            data: config,
        };
    }
    async getSchema(id) {
        const ctx = "getSchema";
        const data = this.schemas[id];
        this.logger.info({ ctx, msg: "exit" });
        return {
            data,
            error: null,
        };
    }
    queryNotesSync({ qs, }) {
        const items = this.fuseEngine.queryNote({ qs });
        return {
            error: null,
            data: items.map((ent) => this.notes[ent.id]),
        };
    }
    async querySchema(queryString) {
        const ctx = "querySchema";
        let items = [];
        const results = await this.fuseEngine.querySchema({ qs: queryString });
        items = results.map((ent) => this.schemas[ent.id]);
        // if (queryString === "") {
        //   items = [this.schemas.root];
        // } else if (queryString === "*") {
        //   items = _.values(this.schemas);
        // } else {
        //   const results = this.schemaIndex.search(queryString);
        //   items = _.map(results, (resp) => this.schemas[resp.item.id]);
        // }
        this.logger.info({ ctx, msg: "exit" });
        return {
            error: null,
            data: items,
        };
    }
    async queryNotes(opts) {
        const ctx = "Engine:queryNotes";
        const { qs, vault, createIfNew } = opts;
        let items = await this.fuseEngine.queryNote({ qs });
        let item = this.notes[items[0].id];
        if (createIfNew) {
            let noteNew;
            if ((item === null || item === void 0 ? void 0 : item.fname) === qs && (item === null || item === void 0 ? void 0 : item.stub)) {
                noteNew = item;
                noteNew.stub = false;
            }
            else {
                if (lodash_1.default.isUndefined(vault)) {
                    return {
                        error: new common_all_1.DendronError({ msg: "no vault specified" }),
                        data: null,
                    };
                }
                noteNew = common_all_1.NoteUtilsV2.create({ fname: qs, vault });
            }
            const changed = await this.writeNote(noteNew, { newNode: true });
            await this.refreshNotesV2(changed.data);
        }
        this.logger.info({ ctx, msg: "exit" });
        let notes = items.map((ent) => this.notes[ent.id]);
        if (!lodash_1.default.isUndefined(vault)) {
            notes = notes.filter((ent) => common_server_1.VaultUtils.isEqual(vault, ent.vault, this.wsRoot));
        }
        return {
            error: null,
            data: notes,
        };
    }
    async sync() {
        throw Error("sync not implemented");
        return {};
    }
    async refreshNotesV2(notes) {
        notes.forEach((ent) => {
            const { id } = ent.note;
            //const uri = NoteUtilsV2.getURI({ note: ent.note, wsRoot: this.wsRoot });
            if (ent.status === "delete") {
                delete this.notes[id];
                // this.history &&
                //   this.history.add({ source: "engine", action: "delete", uri });
            }
            else {
                if (ent.status === "create") {
                    // this.history &&
                    //   this.history.add({ source: "engine", action: "create", uri });
                }
                const links = utilsv2_1.ParserUtilsV2.findLinks({ note: ent.note });
                ent.note.links = links;
                this.notes[id] = ent.note;
            }
        });
        this.fuseEngine.updateNotesIndex(this.notes);
    }
    async renameNote(opts) {
        try {
            const resp = await this.store.renameNote(opts);
            await this.refreshNotesV2(resp);
            return {
                error: null,
                data: resp,
            };
        }
        catch (err) {
            return {
                error: new common_all_1.DendronError({ payload: err }),
            };
        }
    }
    async updateNote(note, opts) {
        const out = this.store.updateNote(note, opts);
        await this.updateIndex("note");
        return out;
    }
    async updateIndex(mode) {
        if (mode === "schema") {
            this.fuseEngine.updateSchemaIndex(this.schemas);
        }
        else {
            this.fuseEngine.updateNotesIndex(this.notes);
        }
    }
    async updateSchema(schemaModule) {
        const out = await this.store.updateSchema(schemaModule);
        await this.updateIndex("schema");
        return out;
    }
    async writeConfig(opts) {
        const { configRoot } = this;
        const cpath = config_1.DConfig.configPath(configRoot);
        common_server_1.writeYAML(cpath, opts.config);
        return {
            error: null,
        };
    }
    async writeNote(note, opts) {
        const out = await this.store.writeNote(note, opts);
        await this.refreshNotesV2(out.data);
        return out;
    }
    async writeSchema(schema) {
        return this.store.writeSchema(schema);
    }
}
exports.DendronEngineV2 = DendronEngineV2;
exports.createEngine = ({ vaults, wsRoot }) => {
    const engine = DendronEngineV2.createV3({ vaults, wsRoot });
    return engine;
};
//# sourceMappingURL=enginev2.js.map