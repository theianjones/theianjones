"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchAll = exports.getWorkspaceCache = exports.extractDanglingRefs = exports.parseRef = exports.fsPathToRef = exports.normalizeSlashes = exports.trimLeadingSlash = exports.isInFencedCodeBlock = exports.getFileUrlForMarkdownPreview = exports.positionToOffset = exports.lineBreakOffsetsByLineIndex = exports.findUriByRef = exports.escapeForRegExp = exports.refPattern = exports.containsMarkdownExt = exports.REGEX_FENCED_CODE_BLOCK = exports.sortPaths = void 0;
/* eslint-disable no-cond-assign */
/* eslint-disable no-restricted-syntax */
/* eslint-disable no-use-before-define */
const cross_path_sort_1 = require("cross-path-sort");
Object.defineProperty(exports, "sortPaths", { enumerable: true, get: function () { return cross_path_sort_1.sort; } });
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const vscode_uri_1 = require("vscode-uri");
const workspaceCache = {
    imageUris: [],
    markdownUris: [],
    otherUris: [],
    allUris: [],
    danglingRefsByFsPath: {},
    danglingRefs: [],
};
const markdownExtRegex = /\.md$/i;
exports.REGEX_FENCED_CODE_BLOCK = /^( {0,3}|\t)```[^`\r\n]*$[\w\W]+?^( {0,3}|\t)``` *$/gm;
exports.containsMarkdownExt = (pathParam) => !!markdownExtRegex.exec(path_1.default.parse(pathParam).ext);
exports.refPattern = "(\\[\\[)([^\\[\\]]+?)(\\]\\])";
// === Utils
exports.escapeForRegExp = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
exports.findUriByRef = (uris, ref) => {
    return uris.find((uri) => {
        // const relativeFsPath =
        //   path.sep + path.relative(getWorkspaceFolder()!.toLowerCase(), uri.fsPath.toLowerCase());
        // if (containsImageExt(ref) || containsOtherKnownExts(ref) || containsUnknownExt(ref)) {
        //   if (isLongRef(ref)) {
        //     return normalizeSlashes(relativeFsPath).endsWith(ref.toLowerCase());
        //   }
        //   const basenameLowerCased = path.basename(uri.fsPath).toLowerCase();
        //   return (
        //     basenameLowerCased === ref.toLowerCase() || basenameLowerCased === `${ref.toLowerCase()}.md`
        //   );
        // }
        // if (isLongRef(ref)) {
        //   return normalizeSlashes(relativeFsPath).endsWith(`${ref.toLowerCase()}.md`);
        // }
        const name = path_1.default.parse(uri.fsPath).name.toLowerCase();
        return (exports.containsMarkdownExt(path_1.default.basename(uri.fsPath)) &&
            name === ref.toLowerCase());
    });
};
exports.lineBreakOffsetsByLineIndex = (value) => {
    const result = [];
    let index = value.indexOf("\n");
    while (index !== -1) {
        result.push(index + 1);
        index = value.indexOf("\n", index + 1);
    }
    result.push(value.length + 1);
    return result;
};
exports.positionToOffset = (content, position) => {
    if (position.line < 0) {
        throw new Error("Illegal argument: line must be non-negative");
    }
    if (position.column < 0) {
        throw new Error("Illegal argument: column must be non-negative");
    }
    const lineBreakOffsetsByIndex = exports.lineBreakOffsetsByLineIndex(content);
    if (lineBreakOffsetsByIndex[position.line] !== undefined) {
        return ((lineBreakOffsetsByIndex[position.line - 1] || 0) + position.column || 0);
    }
    return 0;
};
exports.getFileUrlForMarkdownPreview = (filePath) => vscode_uri_1.URI.file(filePath).toString().replace("file://", "");
exports.isInFencedCodeBlock = (content, lineNum) => {
    const textBefore = content
        .slice(0, exports.positionToOffset(content, { line: lineNum, column: 0 }))
        .replace(exports.REGEX_FENCED_CODE_BLOCK, "")
        .replace(/<!--[\W\w]+?-->/g, "");
    // So far `textBefore` should contain no valid fenced code block or comment
    return /^( {0,3}|\t)```[^`\r\n]*$[\w\W]*$/gm.test(textBefore);
};
exports.trimLeadingSlash = (value) => value.replace(/^\/+|^\\+/g, "");
exports.normalizeSlashes = (value) => value.replace(/\\/gi, "/");
exports.fsPathToRef = ({ path: fsPath, keepExt, basePath, }) => {
    const ref = basePath && fsPath.startsWith(basePath)
        ? exports.normalizeSlashes(fsPath.replace(basePath, ""))
        : path_1.default.basename(fsPath);
    if (keepExt) {
        return exports.trimLeadingSlash(ref);
    }
    return exports.trimLeadingSlash(ref.includes(".") ? ref.slice(0, ref.lastIndexOf(".")) : ref);
};
// export const getWorkspaceFolder = (): string | undefined =>
//   DendronWorkspace.instance().rootWorkspace.uri.fsPath;
exports.parseRef = (rawRef) => {
    const dividerPosition = rawRef.indexOf("|");
    if (dividerPosition < 0) {
        return {
            ref: lodash_1.default.trim(rawRef),
            label: lodash_1.default.trim(rawRef),
        };
    }
    else {
        return {
            ref: lodash_1.default.trim(rawRef.slice(dividerPosition + 1, rawRef.length)),
            label: lodash_1.default.trim(rawRef.slice(0, dividerPosition)),
        };
    }
};
// === Cache
// export const cacheWorkspace = async () => {
//   // await cacheUris();
//   await cacheRefs();
// };
// export const cacheUris = async () => {
//   const root = DendronWorkspace.instance().rootWorkspace;
//   const markdownUris = _.values(DendronWorkspace.instance().engine.notes)
//     .filter((n) => !n.stub)
//     .map((n) => {
//       return URI.joinPath(root.uri, n.fname + ".md");
//     });
//   workspaceCache.markdownUris = sortPaths(markdownUris, {
//     pathKey: "path",
//     shallowFirst: true,
//   });
//   workspaceCache.allUris = sortPaths([...markdownUris], {
//     pathKey: "path",
//     shallowFirst: true,
//   });
// };
// export const cacheRefs = async () => {
//   workspaceCache.danglingRefsByFsPath = await findDanglingRefsByFsPath(
//     workspaceCache.markdownUris
//   );
//   workspaceCache.danglingRefs = sortPaths(
//     Array.from(
//       new Set(
//         Object.values(workspaceCache.danglingRefsByFsPath).flatMap(
//           (refs) => refs
//         )
//       )
//     ),
//     { shallowFirst: true }
//   );
// };
// export const findDanglingRefsByFsPath = async (uris: URI[]) => {
//   const refsByFsPath: { [key: string]: string[] } = {};
//   for (const { fsPath } of uris) {
//     const fsPathExists = fs.existsSync(fsPath);
//     if (
//       !fsPathExists ||
//       !containsMarkdownExt(fsPath) ||
//       (fsPathExists && fs.lstatSync(fsPath).isDirectory())
//     ) {
//       continue;
//     }
//     const doc = workspace.textDocuments.find(
//       (doc) => doc.uri.fsPath === fsPath
//     );
//     const refs = extractDanglingRefs(
//       doc ? doc.getText() : fs.readFileSync(fsPath).toString()
//     );
//     if (refs.length) {
//       refsByFsPath[fsPath] = refs;
//     }
//   }
//   return refsByFsPath;
// };
const refRegexp = new RegExp(exports.refPattern, "gi");
exports.extractDanglingRefs = (content) => {
    const refs = [];
    content.split(/\r?\n/g).forEach((lineText, _lineNum) => {
        for (const match of exports.matchAll(refRegexp, lineText)) {
            const [, , reference] = match;
            if (reference) {
                // const offset = (match.index || 0) + 2;
                // if (isInFencedCodeBlock(content, lineNum) || isInCodeSpan(content, lineNum, offset)) {
                //   continue;
                // }
                const { ref } = exports.parseRef(reference);
                if (!exports.findUriByRef(exports.getWorkspaceCache().allUris, ref)) {
                    refs.push(ref);
                }
            }
        }
    });
    return Array.from(new Set(refs));
};
exports.getWorkspaceCache = () => workspaceCache;
exports.matchAll = (pattern, text) => {
    let match;
    const out = [];
    pattern.lastIndex = 0;
    while ((match = pattern.exec(text))) {
        out.push(match);
    }
    return out;
};
//# sourceMappingURL=utils.js.map