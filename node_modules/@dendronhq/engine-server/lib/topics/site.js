"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SiteUtils = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const config_1 = require("../config");
const utils_1 = require("../utils");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const common_server_1 = require("@dendronhq/common-server");
class SiteUtils {
    static canPublish(opts) {
        var _a, _b;
        const { note, config } = opts;
        return !lodash_1.default.some([
            // not blacklisted
            ((_a = note.custom) === null || _a === void 0 ? void 0 : _a.published) === false,
            // not whitelisted
            !config.publishByDefault && !((_b = note.custom) === null || _b === void 0 ? void 0 : _b.published),
        ]);
    }
    static async copyAssets(opts) {
        const { wsRoot, vault, siteAssetsDir } = opts;
        const vaultAssetsDir = path_1.default.join(common_server_1.vault2Path({ wsRoot, vault }), "assets");
        return fs_extra_1.default.copy(path_1.default.join(vaultAssetsDir), path_1.default.join(siteAssetsDir));
    }
    static async filterByConfig(opts) {
        const { engine, config } = opts;
        const { siteHierarchies } = config;
        let domains = [];
        // TODO: return domains from here
        const hiearchiesToPublish = await Promise.all(siteHierarchies.map(async (domain, idx) => {
            const out = await SiteUtils.filterByHiearchy({
                domain,
                config: config_1.DConfig.cleanSiteConfig(config),
                engine,
                navOrder: idx,
            });
            if (lodash_1.default.isUndefined(out)) {
                return {};
            }
            domains.push(out.domain);
            return out.notes;
        }));
        // if single hiearchy, domain includes all immediate children
        if (config.siteHierarchies.length === 1 && domains.length === 1) {
            const rootDomain = domains[0];
            domains = domains.concat(rootDomain.children.map((id) => engine.notes[id]));
        }
        return {
            notes: lodash_1.default.reduce(hiearchiesToPublish, (ent, acc) => {
                return lodash_1.default.merge(acc, ent);
            }, {}),
            domains,
        };
    }
    static async filterByHiearchy(opts) {
        const { domain, engine, navOrder, config } = opts;
        // get config
        let rConfig = lodash_1.default.defaults(lodash_1.default.get(config.config, "root", {
            publishByDefault: true,
            noindexByDefault: false,
            customFrontmatter: [],
        }));
        let hConfig = lodash_1.default.defaults(lodash_1.default.get(config.config, domain), rConfig);
        const dupBehavior = config.duplicateNoteBehavior;
        // get the domain note
        let notes = common_all_1.NoteUtilsV2.getNotesByFname({
            fname: domain,
            notes: engine.notes,
        }).filter((note) => SiteUtils.canPublish({ note, config: hConfig }));
        let domainNote;
        if (notes.length > 1) {
            if (dupBehavior) {
                const vault = dupBehavior.payload.vault;
                const maybeDomainNote = notes.filter((n) => common_all_1.VaultUtils.isEqual(n.vault, vault, engine.wsRoot));
                if (maybeDomainNote.length < 1) {
                    // TODO: add warning
                    return;
                }
                domainNote = maybeDomainNote[0];
            }
            else {
                throw new common_all_1.DendronError({ msg: `mult notes found for ${domain}` });
            }
        }
        else if (notes.length < 1) {
            // TODO: add warning
            return;
        }
        else {
            domainNote = { ...notes[0] };
        }
        if (!domainNote.custom) {
            domainNote.custom = {};
        }
        domainNote.custom.nav_order = navOrder;
        domainNote.parent = null;
        domainNote.title = lodash_1.default.capitalize(domainNote.title);
        if (domainNote.fname === config.siteIndex) {
            domainNote.custom.permalink = "/";
        }
        const out = {};
        const processQ = [domainNote];
        while (!lodash_1.default.isEmpty(processQ)) {
            const note = processQ.pop();
            const maybeNote = SiteUtils.filterByNote({ note, hConfig });
            if (maybeNote) {
                if (config.writeStubs && maybeNote.stub) {
                    maybeNote.stub = false;
                    await engine.writeNote(note);
                }
                let children = maybeNote.children.map((id) => engine.notes[id]);
                children = lodash_1.default.filter(children, (note) => SiteUtils.canPublish({ note, config: hConfig }));
                config.writeStubs;
                children.forEach((n) => processQ.push(n));
                // updated children
                out[maybeNote.id] = {
                    ...maybeNote,
                    children: children.map((ent) => ent.id),
                };
            }
        }
        return { notes: out, domain: domainNote };
    }
    static filterByNote(opts) {
        var _a;
        const { note, hConfig } = opts;
        // apply custom frontmatter if exist
        (_a = hConfig.customFrontmatter) === null || _a === void 0 ? void 0 : _a.forEach((fm) => {
            const { key, value } = fm;
            // @ts-ignore
            meta[key] = value;
        });
        // remove site-only stuff
        return {
            ...note,
            body: utils_1.stripLocalOnlyTags(note.body),
        };
    }
    static getDomains(opts) {
        const { notes, config } = opts;
        if (config.siteHierarchies.length === 1) {
            const fname = config.siteHierarchies[0];
            const rootNotes = common_all_1.NoteUtilsV2.getNotesByFname({ fname, notes });
            return [rootNotes[0]].concat(rootNotes[0].children.map((ent) => notes[ent]));
        }
        else {
            return lodash_1.default.filter(lodash_1.default.values(notes), { parent: null });
        }
    }
}
exports.SiteUtils = SiteUtils;
//# sourceMappingURL=site.js.map