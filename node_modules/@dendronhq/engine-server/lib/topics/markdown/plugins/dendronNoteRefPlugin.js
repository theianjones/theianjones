"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dendronNoteRefPluginForMd = exports.dendronNoteRefPlugin = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("../../../utils");
const utilsv2_1 = require("../utilsv2");
const inject_1 = require("./inject");
const replaceRefs_1 = require("./replaceRefs");
const LINK_REGEX = /^\(\((?<ref>[^)]+)\)\)/;
// --- Utils
function doRenderWithOutline(opts) {
    const { content, title, link } = opts;
    return `

<div class="portal-container">
<div class="portal-head">
<div class="portal-backlink" >
<div class="portal-title">From <span class="portal-text-title">${title}</span></div>
<a href="${link}" class="portal-arrow">Go to text <span class="right-arrow">â†’</span></a>
</div>
</div>
<div id="portal-parent-anchor" class="portal-parent" markdown="1">
<div class="portal-parent-fader-top"></div>
<div class="portal-parent-fader-bottom"></div>        
  
${content}

</div>    
</div>
`;
}
const MAX_REF_LVL = 2;
function convertNoteRef(opts) {
    const { replaceRefOpts, renderWithOutline, engine, refLvl, link, defaultRoot, proc, } = lodash_1.default.defaults(opts);
    if (refLvl >= MAX_REF_LVL) {
        return "ERROR: Too many nested note references";
    }
    let noteRefs = [];
    // check if link is normal
    if (link.from.fname.endsWith("*")) {
        const resp = engine.queryNotesSync({ qs: link.from.fname });
        const out = lodash_1.default.filter(resp.data, (ent) => common_all_1.DUtils.minimatch(ent.fname, link.from.fname));
        noteRefs = lodash_1.default.sortBy(out.map((ent) => common_all_1.NoteUtilsV2.toNoteLoc(ent)), "fname");
    }
    else {
        noteRefs.push(link.from);
    }
    const out = noteRefs.map((ref) => {
        var _a;
        const vaultPath = ((_a = ref.vault) === null || _a === void 0 ? void 0 : _a.fsPath) || defaultRoot;
        const name = ref.fname;
        const alias = ref.alias;
        const npath = common_all_1.DNodeUtilsV2.getFullPath({
            wsRoot: engine.wsRoot,
            vault: { fsPath: vaultPath },
            basename: name + ".md",
        });
        try {
            const body = fs_extra_1.default.readFileSync(npath, { encoding: "utf8" });
            const out = extractNoteRef({
                body,
                link,
                engine,
                renderWithOutline,
                replaceRefOpts,
                refLvl: refLvl + 1,
            });
            if (renderWithOutline) {
                let linkString = name;
                linkString = lodash_1.default.trim(utilsv2_1.ParserUtilsV2.getRemark()
                    .use(plugin, {
                    engine,
                    renderWithOutline,
                    replaceRefOpts,
                    refLvl,
                })
                    .use(replaceRefs_1.replaceRefs, { ...lodash_1.default.omit(replaceRefOpts, "wikiLink2Md") })
                    .processSync(`[[${linkString}]]`)
                    .toString());
                return doRenderWithOutline({
                    content: out,
                    title: alias || name || "no title",
                    link: linkString,
                });
            }
            else {
                return out;
            }
        }
        catch (err) {
            const errors = proc.data("errors");
            const msg = `${name} not found`;
            errors.push(new common_all_1.DendronError({ msg }));
            return proc.stringify(utilsv2_1.ParserUtilsV2.genMDError({
                msg,
                title: "Note Ref Error",
            }));
        }
    });
    return out.join("\n");
}
function extractNoteRef(opts) {
    const { body, link, engine, renderWithOutline, replaceRefOpts, refLvl, } = opts;
    const proc = utilsv2_1.ParserUtilsV2.getRemark().use(plugin, {
        engine,
        renderWithOutline,
        replaceRefOpts,
        refLvl,
    });
    // parse it so we can slice it
    const bodyAST = proc.parse(body);
    const { anchorStart, anchorEnd, anchorStartOffset } = link.data;
    let anchorStartIndex = bodyAST.children[0].type === "yaml" ? 1 : 0;
    let anchorEndIndex = bodyAST.children.length;
    if (anchorStart) {
        anchorStartIndex = inject_1.findIndex(bodyAST.children, function (node) {
            return inject_1.isHeading(node, anchorStart);
        });
        if (anchorStartIndex < 0) {
            return proc.stringify(utilsv2_1.ParserUtilsV2.genMDError({
                msg: `start anchor ${anchorStart} not found`,
                title: "Note Ref Error",
            }));
        }
    }
    if (anchorEnd) {
        anchorEndIndex = inject_1.findIndex(bodyAST.children.slice(anchorStartIndex + 1), function (node) {
            return inject_1.isHeading(node, anchorEnd);
        });
        if (anchorEndIndex < 0) {
            const mdError = utilsv2_1.ParserUtilsV2.genMDError({
                msg: `end anchor ${anchorEnd} not found`,
                title: "Note Ref Error",
            });
            return proc.stringify(mdError);
        }
        anchorEndIndex += anchorStartIndex + 1;
    }
    bodyAST.children = bodyAST.children.slice(anchorStartIndex, anchorEndIndex);
    // take the output and convert it using the full md toolchain
    let outProc = utilsv2_1.ParserUtilsV2.getRemark()
        .use(plugin, opts)
        .use(replaceRefs_1.replaceRefs, replaceRefOpts);
    try {
        let out = outProc.processSync(outProc.stringify(bodyAST)).toString();
        if (anchorStartOffset) {
            out = out.split("\n").slice(anchorStartOffset).join("\n");
        }
        return out;
    }
    catch (err) {
        console.log(err);
        throw err;
    }
}
// --- Main
function plugin(opts) {
    // @ts-ignore
    let _this = this;
    attachParser({ proc: _this });
    attachCompiler({ proc: _this, ...opts });
}
exports.dendronNoteRefPlugin = plugin;
function pluginForMarkdown(opts) {
    // @ts-ignore
    let _this = this;
    attachParser({ proc: _this });
    attachCompilerForMarkdown({ proc: _this, opts });
}
exports.dendronNoteRefPluginForMd = pluginForMarkdown;
function attachCompilerForMarkdown({ proc, opts, }) {
    const Compiler = proc.Compiler;
    const visitors = Compiler.prototype.visitors;
    visitors.refLink = function (node) {
        const data = node.data;
        if (opts === null || opts === void 0 ? void 0 : opts.replaceLink) {
            data.link = utilsv2_1.RemarkUtilsV2.replaceLink({
                link: data.link,
                opts: opts.replaceLink,
            });
        }
        return utils_1.refLink2String(data.link, {
            includeParen: true,
            includeRefTag: true,
        });
    };
    return Compiler;
}
function attachParser(opts) {
    const { proc } = opts;
    const permalinks = [];
    const aliasDivider = "|";
    function isAlias(pageTitle) {
        return pageTitle.indexOf(aliasDivider) !== -1;
    }
    const pageResolver = (name) => [name.replace(/ /g, "").toLowerCase()];
    function locator(value, fromIndex) {
        return value.indexOf("((", fromIndex);
    }
    function parsePageTitle(pageTitle) {
        if (isAlias(pageTitle)) {
            return parseAliasLink(pageTitle);
        }
        return {
            name: pageTitle,
            displayName: pageTitle,
        };
    }
    function parseAliasLink(pageTitle) {
        const [displayName, name] = pageTitle.split(aliasDivider);
        return { name, displayName };
    }
    function inlineTokenizer(eat, value) {
        const match = LINK_REGEX.exec(value);
        if (match) {
            const pageName = match[1].trim();
            const { link } = utils_1.parseDendronRef(pageName);
            const { name, displayName } = parsePageTitle(pageName);
            const pagePermalinks = pageResolver(name);
            let permalink = pagePermalinks.find((p) => permalinks.indexOf(p) !== -1);
            const exists = permalink !== undefined;
            if (!exists) {
                permalink = pagePermalinks[0];
            }
            let classNames = "internal";
            if (!exists) {
                classNames += " " + "new";
            }
            // normalize
            if (permalink) {
                permalink = common_server_1.removeMDExtension(permalink);
            }
            return eat(match[0])({
                type: "refLink",
                value: name,
                data: {
                    alias: displayName,
                    link,
                    permalink,
                    exists,
                    hName: "a",
                    hProperties: {
                        className: classNames,
                        href: permalink,
                    },
                    hChildren: [
                        {
                            type: "text",
                            value: displayName,
                        },
                    ],
                },
            });
        }
        return;
    }
    inlineTokenizer.locator = locator;
    const Parser = proc.Parser;
    const inlineTokenizers = Parser.prototype.inlineTokenizers;
    const inlineMethods = Parser.prototype.inlineMethods;
    inlineTokenizers.refLink = inlineTokenizer;
    inlineMethods.splice(inlineMethods.indexOf("link"), 0, "refLink");
    return Parser;
}
function attachCompiler(opts) {
    const { refLvl, proc, engine, renderWithOutline, replaceRefOpts, } = lodash_1.default.defaults(opts, { refLvl: 0 });
    const Compiler = proc.Compiler;
    const visitors = Compiler.prototype.visitors;
    visitors.refLink = function (node) {
        const data = node.data;
        return convertNoteRef({
            refLvl,
            proc,
            engine,
            renderWithOutline,
            replaceRefOpts,
            link: data.link,
            defaultRoot: engine.vaults[0],
        });
    };
    return Compiler;
}
//# sourceMappingURL=dendronNoteRefPlugin.js.map