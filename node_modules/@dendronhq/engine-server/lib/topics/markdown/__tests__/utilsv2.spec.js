"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const utilsv2_1 = require("../utilsv2");
describe(utilsv2_1.ParserUtilsV2, () => {
    const vault = { fsPath: "dummy" };
    describe("findHeaders", async () => {
        test("one header", () => {
            const note = common_all_1.NoteUtilsV2.create({
                fname: "foo",
                id: "foo",
                created: "1",
                updated: "1",
                body: "# h1",
                vault,
            });
            const out = utilsv2_1.ParserUtilsV2.findHeaders(note.body);
            expect(out).toMatchSnapshot("bond");
            expect(lodash_1.default.size(out)).toEqual(1);
            expect(out[0].depth).toEqual(1);
        });
    });
    describe("findLinks", async () => {
        test("one link", () => {
            var _a;
            const note = common_all_1.NoteUtilsV2.create({
                fname: "foo",
                id: "foo",
                created: "1",
                updated: "1",
                body: "[[bar]]",
                vault,
            });
            const links = utilsv2_1.ParserUtilsV2.findLinks({ note });
            expect(links).toMatchSnapshot("bond");
            expect((_a = links[0].to) === null || _a === void 0 ? void 0 : _a.fname).toEqual("bar");
        });
        test("empty link", () => {
            const note = common_all_1.NoteUtilsV2.create({
                fname: "foo",
                id: "foo",
                created: "1",
                updated: "1",
                body: "[[]]",
                vault,
            });
            const links = utilsv2_1.ParserUtilsV2.findLinks({ note });
            expect(links).toMatchSnapshot();
            expect(lodash_1.default.isEmpty(links)).toBeTruthy();
        });
    });
    describe("replaceLinks", async () => {
        test("one", async () => {
            const content = ["[[bond]]"].join("\n");
            const from = {
                fname: "bond",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const to = {
                fname: "bar",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const out = await utilsv2_1.ParserUtilsV2.replaceLinks({ content, from, to });
            expect(out).toMatchSnapshot();
            expect(lodash_1.default.trim(out)).toEqual("[[bar]]");
        });
        test("ref", async () => {
            const content = ["((ref: [[bond]]))"].join("\n");
            const from = {
                fname: "bond",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const to = {
                fname: "bar",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const out = await utilsv2_1.ParserUtilsV2.replaceLinks({ content, from, to });
            expect(out).toMatchSnapshot();
            expect(lodash_1.default.trim(out)).toEqual("((ref: [[bar]]))");
        });
        test("multiple", async () => {
            const content = ["[[bond]]", "[[bond]]"].join("\n");
            const from = {
                fname: "bond",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const to = {
                fname: "bar",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const out = await utilsv2_1.ParserUtilsV2.replaceLinks({ content, from, to });
            expect(out).toMatchSnapshot();
        });
        test("inline code", async () => {
            const content = ["`[[bond]]`"].join("\n");
            const from = {
                fname: "bond",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const to = {
                fname: "bar",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const out = await utilsv2_1.ParserUtilsV2.replaceLinks({ content, from, to });
            expect(out).toMatchSnapshot();
            expect(lodash_1.default.trim(out)).toEqual("`[[bond]]`");
        });
        test("fenced code", async () => {
            const content = ["```", "[[bond]]", "```"].join("\n");
            const from = {
                fname: "bond",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const to = {
                fname: "bar",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const out = await utilsv2_1.ParserUtilsV2.replaceLinks({ content, from, to });
            expect(out).toMatchSnapshot();
        });
        test("with alias", async () => {
            const content = ["[[hero|bond]]"].join("\n");
            const from = {
                fname: "bond",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const to = {
                fname: "bar",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const out = await utilsv2_1.ParserUtilsV2.replaceLinks({ content, from, to });
            expect(out).toMatchSnapshot();
            expect(lodash_1.default.trim(out)).toEqual("[[hero|bar]]");
        });
        test("with offset ", async () => {
            const content = ["   [[bond]]"].join("\n");
            const from = {
                fname: "bond",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const to = {
                fname: "bar",
                vault: {
                    fsPath: "/tmp",
                },
            };
            const out = await utilsv2_1.ParserUtilsV2.replaceLinks({ content, from, to });
            expect(out).toMatchSnapshot();
            expect(lodash_1.default.trim(out)).toEqual("[[bar]]");
        });
    });
});
//# sourceMappingURL=utilsv2.spec.js.map