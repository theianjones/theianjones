"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DendronEngineClient = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const storev2_1 = require("./drivers/file/storev2");
const fuseEngine_1 = require("./fuseEngine");
const utils_1 = require("./utils");
class DendronEngineClient {
    constructor({ api, vaults, ws, history, logger, }) {
        this.api = api;
        this.notes = {};
        this.schemas = {};
        this.links = [];
        this.fuseEngine = new fuseEngine_1.FuseEngine({});
        this.vaults = vaults;
        this.vaultsv3 = vaults.map((ent) => ({ fsPath: ent }));
        this.wsRoot = ws;
        this.ws = ws;
        this.configRoot = this.wsRoot;
        this.history = history;
        this.logger = logger || common_server_1.createLogger();
        this.store = new storev2_1.FileStorageV2({
            wsRoot: this.ws,
            vaultsv3: this.vaultsv3,
            logger: this.logger,
        });
    }
    static create({ port, vaults, ws, history, }) {
        const api = new common_server_1.DendronAPI({
            endpoint: `http://localhost:${port}`,
            apiPath: "api",
        });
        return new DendronEngineClient({ api, vaults, ws, history });
    }
    static getPort({ wsRoot }) {
        const portFile = utils_1.getPortFilePath({ wsRoot });
        if (!fs_extra_1.default.pathExistsSync(portFile)) {
            throw new common_all_1.DendronError({ msg: "no port file" });
        }
        return lodash_1.default.toInteger(lodash_1.default.trim(fs_extra_1.default.readFileSync(portFile, { encoding: "utf8" })));
    }
    /**
     * Load all nodes
     */
    async init() {
        const resp = await this.api.workspaceInit({
            uri: this.ws,
            config: { vaults: this.vaults },
        });
        if (resp.error && resp.error.code !== common_all_1.ERROR_CODES.MINOR) {
            return {
                error: resp.error,
                data: { notes: {}, schemas: {} },
            };
        }
        if (!resp.data) {
            throw new common_all_1.DendronError({ msg: "no data" });
        }
        const { notes, schemas } = resp.data;
        this.notes = notes;
        this.schemas = schemas;
        await this.fuseEngine.updateNotesIndex(notes);
        await this.fuseEngine.updateSchemaIndex(schemas);
        this.store.notes = notes;
        this.store.schemas = schemas;
        return {
            error: resp.error,
            data: { notes, schemas },
        };
    }
    async deleteNote(id, opts) {
        const ws = this.ws;
        const resp = await this.api.engineDelete({ id, opts, ws });
        if (!resp.data) {
            throw new common_all_1.DendronError({ msg: "no data" });
        }
        await this.refreshNotesV2(resp.data);
        return {
            error: null,
            data: resp.data,
        };
    }
    async deleteSchema(id, opts) {
        var _a, _b;
        const ws = this.ws;
        const resp = await this.api.schemaDelete({ id, opts, ws });
        delete this.schemas[id];
        if (!((_a = resp === null || resp === void 0 ? void 0 : resp.data) === null || _a === void 0 ? void 0 : _a.notes) || !((_b = resp === null || resp === void 0 ? void 0 : resp.data) === null || _b === void 0 ? void 0 : _b.schemas)) {
            throw new common_all_1.DendronError({ msg: "bad delete operation" });
        }
        const { notes, schemas } = resp.data;
        this.notes = notes;
        this.schemas = schemas;
        this.fuseEngine.updateNotesIndex(notes);
        this.fuseEngine.updateSchemaIndex(schemas);
        return {
            error: null,
            data: resp.data,
        };
    }
    async getConfig() {
        const resp = await this.api.configGet({
            ws: this.ws,
        });
        return resp;
    }
    async getNoteByPath(opts) {
        const resp = await this.api.engineGetNoteByPath({
            ...opts,
            ws: this.ws,
        });
        if (!lodash_1.default.isUndefined(resp.data)) {
            await this.refreshNotesV2(resp.data.changed);
        }
        return resp;
    }
    async queryNote(opts) {
        const { qs, vault } = opts;
        let noteIndexProps = await this.fuseEngine.queryNote({ qs });
        // TODO: hack
        if (!lodash_1.default.isUndefined(vault)) {
            noteIndexProps = noteIndexProps.filter((ent) => common_server_1.VaultUtils.isEqual(vault, ent.vault, this.wsRoot));
        }
        return noteIndexProps.map((ent) => this.notes[ent.id]);
    }
    async queryNotes(opts) {
        const items = await this.queryNote(opts);
        return {
            data: items,
            error: null,
        };
    }
    async buildNotes() { }
    queryNotesSync({ qs, vault }) {
        let items = this.fuseEngine.queryNote({ qs });
        if (vault) {
            items = items.filter((ent) => {
                return common_server_1.VaultUtils.isEqual(ent.vault, vault, this.wsRoot);
            });
        }
        return {
            error: null,
            data: items.map((ent) => this.notes[ent.id]),
        };
    }
    async refreshNotes(notes) {
        notes.forEach((node) => {
            const { id } = node;
            this.notes[id] = node;
        });
        this.fuseEngine.updateNotesIndex(this.notes);
    }
    async refreshNotesV2(notes) {
        notes.forEach((ent) => {
            const { id } = ent.note;
            const uri = common_all_1.NoteUtilsV2.getURI({ note: ent.note, wsRoot: this.wsRoot });
            if (ent.status === "delete") {
                delete this.notes[id];
                this.history &&
                    this.history.add({ source: "engine", action: "delete", uri });
            }
            else {
                if (ent.status === "create") {
                    this.history &&
                        this.history.add({ source: "engine", action: "create", uri });
                }
                this.notes[id] = ent.note;
            }
        });
        this.fuseEngine.updateNotesIndex(this.notes);
    }
    async refreshSchemas(smods) {
        smods.forEach((smod) => {
            const id = common_all_1.SchemaUtilsV2.getModuleRoot(smod).id;
            this.schemas[id] = smod;
        });
    }
    async renameNote(opts) {
        const resp = await this.api.engineRenameNote({ ...opts, ws: this.ws });
        await this.refreshNotesV2(resp.data);
        return resp;
    }
    async sync() {
        const resp = await this.api.workspaceSync({ ws: this.ws });
        if (!resp.data) {
            throw new common_all_1.DendronError({ msg: "no data" });
        }
        const { notes, schemas } = resp.data;
        this.notes = notes;
        this.schemas = schemas;
        await this.fuseEngine.updateNotesIndex(notes);
        await this.fuseEngine.updateSchemaIndex(schemas);
        return {
            error: resp.error,
            data: { notes, schemas },
        };
    }
    async updateNote(note, opts) {
        await this.api.engineUpdateNote({ ws: this.ws, note, opts });
        const maybeNote = this.notes[note.id];
        if (maybeNote) {
            note = { ...maybeNote, ...note };
        }
        await this.refreshNotes([note]);
        return;
    }
    async writeNote(note, opts) {
        const resp = await this.api.engineWrite({
            node: note,
            opts,
            ws: this.ws,
        });
        let changed = resp.data;
        // we are updating in place, remove deletes
        if (opts === null || opts === void 0 ? void 0 : opts.updateExisting) {
            changed = lodash_1.default.reject(changed, (ent) => ent.status === "delete");
        }
        await this.refreshNotesV2(changed);
        return resp;
    }
    // ~~~ schemas
    async getSchema(_qs) {
        throw Error("not implemetned");
    }
    async querySchema(qs) {
        const out = await this.api.schemaQuery({ qs, ws: this.ws });
        return lodash_1.default.defaults(out, { data: [] });
    }
    async updateSchema(schema) {
        await this.api.schemaUpdate({ schema, ws: this.ws });
        await this.refreshSchemas([schema]);
        return;
    }
    async writeConfig(opts) {
        await this.api.configWrite({ ...opts, ws: this.ws });
        return {
            error: null,
        };
    }
    async writeSchema(schema) {
        await this.api.schemaWrite({ schema, ws: this.ws });
        await this.refreshSchemas([schema]);
        return;
    }
}
exports.DendronEngineClient = DendronEngineClient;
//# sourceMappingURL=engineClient.js.map