import { URI } from "vscode-uri";
import { DendronError } from "./error";
import { DendronConfig, DendronSiteFM } from "./types";
export declare type EngineDeleteOpts = {
    /**
     * Only delete from meta
     */
    metaOnly?: boolean;
};
export declare type SchemaData = {
    namespace?: boolean;
    pattern?: string;
    template?: SchemaTemplate;
};
export declare type SchemaTemplate = {
    id: string;
    type: "snippet" | "note";
};
export declare type NoteLink = {
    type: "note";
    id: string;
};
export declare type DNodePointerV2 = string;
export declare type DLoc = {
    fname?: string;
    id?: string;
    vault?: DVault;
    uri?: URI;
    anchorHeader?: string;
};
export declare type DNoteLoc = {
    fname: string;
    alias?: string;
    id?: string;
    vault?: DVault;
    anchorHeader?: string;
};
export declare type DNoteAnchor = {
    /**
     * In the future, we could have ID based anchors
     */
    type: "header";
    value: string;
};
export declare type VaultRemote = {
    type: "git";
    url: string;
};
export declare type DVault = {
    /** Name of vault */
    name?: string;
    /** Filesystem path to fault */
    fsPath: string;
    remote?: VaultRemote;
};
export declare type DLinkType = "wiki" | "refv2";
export declare type DLink = {
    type: "ref" | "wiki" | "md" | "backlink";
    original: string;
    value: string;
    alias?: string;
    pos: {
        start: number;
        end: number;
    };
    from: DLoc;
    to?: DLoc;
};
export declare type DNoteLink<TData = any> = {
    type: "ref" | "wiki" | "md";
    pos?: {
        start: number;
        end: number;
    };
    from: DNoteLoc;
    to?: DNoteLoc;
    data: TData;
};
export declare type DNodeTypeV2 = "note" | "schema";
export declare type DNoteRefData = {
    anchorStart?: string;
    anchorEnd?: string;
    anchorStartOffset?: number;
    /**
     * File link: wiki based links (eg. [[foo]])
     * Id link: TBD (eg. ^1234)
     */
    type: "file" | "id";
};
export declare type DNoteRefLink = DNoteLink<DNoteRefData>;
export declare type SchemaDataV2 = SchemaData;
/**
 * Props are the official interface for a node
 */
export declare type DNodePropsV2<T = any, TCustom = any> = {
    id: string;
    title: string;
    desc: string;
    links: DLink[];
    fname: string;
    type: DNodeTypeV2;
    updated: string;
    created: string;
    stub?: boolean;
    schemaStub?: boolean;
    parent: DNodePointerV2 | null;
    children: DNodePointerV2[];
    data: T;
    body: string;
    custom?: TCustom;
    schema?: {
        moduleId: string;
        schemaId: string;
    };
    vault: DVault;
};
/**
 * Opts are arguments used when creating a node
 */
export declare type DNodeOptsV2<T = any> = Partial<Omit<DNodePropsV2<T>, "fname|type|vault">> & {
    fname: string;
    type: DNodeTypeV2;
    vault: DVault;
};
export declare type SchemaRawV2 = Pick<SchemaPropsV2, "id"> & Partial<SchemaDataV2> & {
    title?: string;
    desc?: string;
} & Partial<Pick<DNodePropsV2, "children">>;
export declare type SchemaOptsV2 = Omit<DNodeOptsV2<SchemaData>, "type" | "id"> & {
    id: string;
};
export declare type NoteOptsV2 = Omit<DNodeOptsV2, "type">;
export declare type DNodePropsQuickInputV2<T = any> = DNodePropsV2<T> & {
    label: string;
    detail?: string;
    alwaysShow?: boolean;
};
export declare type SchemaPropsV2 = DNodePropsV2<SchemaData>;
export declare type NotePropsV2 = DNodePropsV2<any, DendronSiteFM & any>;
export declare type DNodePropsDictV2 = {
    [key: string]: DNodePropsV2;
};
export declare type NotePropsDictV2 = {
    [key: string]: NotePropsV2;
};
export declare type SchemaPropsDictV2 = {
    [key: string]: SchemaPropsV2;
};
export declare type SchemaModuleDictV2 = {
    [key: string]: SchemaModulePropsV2;
};
export declare type SchemaImportV2 = string[];
export declare type SchemaModuleOptsV2 = {
    version: number;
    imports?: SchemaImportV2;
    schemas: SchemaOptsV2[];
};
export declare type SchemaModulePropsV2 = {
    version: number;
    imports?: SchemaImportV2;
    schemas: SchemaPropsDictV2;
    root: SchemaPropsV2;
    fname: string;
    vault: DVault;
};
export interface RespV2<T> {
    data?: T;
    error: DendronError | null;
}
export interface QueryOptsV2 {
    /**
     * Should add to full nodes
     */
    fullNode?: boolean;
    /**
     * Just get one result
     */
    queryOne?: boolean;
    /**
     * If node does not exist, create it?
     */
    createIfNew?: boolean;
}
export declare type EngineUpdateNodesOptsV2 = {
    /**
     * New Node, should add to `fullNode` cache
     */
    newNode: boolean;
};
export declare type GetNoteOptsV2 = {
    vault: DVault;
    npath: string;
    /**
     * If node does not exist, create it?
     */
    createIfNew?: boolean;
};
export declare type EngineDeleteOptsV2 = EngineDeleteOpts;
export declare type EngineWriteOptsV2 = {
    /**
     * Write all children?
     * default: false
     */
    recursive?: boolean;
    /**
     * Should persist hierarchy information to disk
     */
    writeHierarchy?: boolean;
    /**
     * Don't bother adding parent nodes.
     * Used when importing existing notes in bulk
     */
    noAddParent?: boolean;
    /**
     * Should update existing note instead of overwriting
     */
    updateExisting?: boolean;
} & Partial<EngineUpdateNodesOptsV2>;
export declare type DEngineInitPayloadV2 = {
    notes: NotePropsDictV2;
    schemas: SchemaModuleDictV2;
};
export declare type RenameNoteOptsV2 = {
    oldLoc: DNoteLoc;
    newLoc: DNoteLoc;
};
export declare type ConfigWriteOpts = {
    config: DendronConfig;
};
export declare type DCommonProps = {
    notes: NotePropsDictV2;
    schemas: SchemaModuleDictV2;
    wsRoot: string;
    /**
     * NOTE: currently same as wsRoot. in the future, the two will be decoupled
     */
    configRoot: string;
    vaultsv3: DVault[];
    links: DLink[];
    vaults: string[];
};
export declare type NoteChangeEntry = {
    note: NotePropsV2;
    status: "create" | "update" | "delete";
};
/**
 * Returns list of notes that were changed
 */
export declare type WriteNoteResp = Required<RespV2<NoteChangeEntry[]>>;
export declare type ConfigGetPayload = DendronConfig;
export declare type DCommonMethods = {
    updateNote(note: NotePropsV2, opts?: EngineUpdateNodesOptsV2): Promise<void>;
    updateSchema: (schema: SchemaModulePropsV2) => Promise<void>;
    writeNote: (note: NotePropsV2, opts?: EngineWriteOptsV2) => Promise<WriteNoteResp>;
    writeSchema: (schema: SchemaModulePropsV2) => Promise<void>;
};
export declare type DEngineInitRespV2 = Required<RespV2<DEngineInitPayloadV2>>;
export declare type EngineDeleteNotePayload = NoteChangeEntry[];
export declare type DEngineDeleteSchemaPayloadV2 = DEngineInitPayloadV2;
export declare type DEngineDeleteSchemaRespV2 = DEngineInitRespV2;
export declare type EngineDeleteNoteResp = Required<RespV2<EngineDeleteNotePayload>>;
export declare type EngineQueryNoteResp = Required<RespV2<DNodePropsV2[]>>;
export declare type NoteQueryResp = Required<RespV2<NotePropsV2[]>>;
export declare type SchemaQueryResp = Required<RespV2<SchemaModulePropsV2[]>>;
export declare type StoreDeleteNoteResp = EngineDeleteNotePayload;
export declare type RenameNotePayload = NoteChangeEntry[];
export declare type GetNotePayloadV2 = {
    note: NotePropsV2 | undefined;
    changed: NoteChangeEntry[];
};
export declare type QueryNotesOpts = {
    qs: string;
    vault?: DVault;
    createIfNew?: boolean;
};
export declare type DEngineInitSchemaRespV2 = Required<RespV2<SchemaModulePropsV2[]>>;
export declare type DEngineV2SyncOpts = {
    metaOnly?: boolean;
};
export declare type DEngineV2 = DCommonProps & DCommonMethods & {
    store: DStoreV2;
    init: () => Promise<DEngineInitRespV2>;
    deleteNote: (id: string, opts?: EngineDeleteOptsV2) => Promise<EngineDeleteNoteResp>;
    deleteSchema: (id: string, opts?: EngineDeleteOptsV2) => Promise<DEngineDeleteSchemaRespV2>;
    sync: (opts?: DEngineV2SyncOpts) => Promise<DEngineInitRespV2>;
    getNoteByPath: (opts: GetNoteOptsV2) => Promise<RespV2<GetNotePayloadV2>>;
    getSchema: (qs: string) => Promise<RespV2<SchemaModulePropsV2>>;
    querySchema: (qs: string) => Promise<SchemaQueryResp>;
    queryNotes: (opts: QueryNotesOpts) => Promise<NoteQueryResp>;
    queryNotesSync({ qs }: {
        qs: string;
        vault?: DVault;
    }): NoteQueryResp;
    renameNote: (opts: RenameNoteOptsV2) => Promise<RespV2<RenameNotePayload>>;
    writeConfig: (opts: ConfigWriteOpts) => Promise<RespV2<void>>;
    getConfig: () => Promise<RespV2<ConfigGetPayload>>;
};
export declare type DEngineClientV2 = Omit<DEngineV2, "store">;
export declare type DStoreV2 = DCommonProps & DCommonMethods & {
    init: () => Promise<DEngineInitRespV2>;
    deleteNote: (id: string, opts?: EngineDeleteOptsV2) => Promise<StoreDeleteNoteResp>;
    deleteSchema: (id: string, opts?: EngineDeleteOptsV2) => Promise<DEngineDeleteSchemaRespV2>;
    renameNote: (opts: RenameNoteOptsV2) => Promise<RenameNotePayload>;
};
export declare type DEngineV4 = {
    notes: NotePropsDictV2;
    schemas: SchemaModuleDictV2;
    wsRoot: string;
    vaults: DVault[];
    initialized: boolean;
} & DEngineV4Methods;
export declare type DEngineV4Methods = {
    init: () => Promise<DEngineInitRespV2>;
    deleteNote: (id: string, opts?: EngineDeleteOptsV2) => Promise<EngineDeleteNoteResp>;
    deleteSchema: (id: string, opts?: EngineDeleteOptsV2) => Promise<DEngineDeleteSchemaRespV2>;
    sync: (opts?: DEngineV2SyncOpts) => Promise<DEngineInitRespV2>;
    getNoteByPath: (opts: GetNoteOptsV2) => Promise<RespV2<GetNotePayloadV2>>;
    getSchema: (qs: string) => Promise<RespV2<SchemaModulePropsV2>>;
    querySchema: (qs: string) => Promise<SchemaQueryResp>;
    queryNotes: (opts: QueryNotesOpts) => Promise<NoteQueryResp>;
    queryNotesSync({ qs }: {
        qs: string;
    }): NoteQueryResp;
    renameNote: (opts: RenameNoteOptsV2) => Promise<RespV2<RenameNotePayload>>;
    writeConfig: (opts: ConfigWriteOpts) => Promise<RespV2<void>>;
    getConfig: () => Promise<RespV2<ConfigGetPayload>>;
};
export declare type WorkspaceOpts = {
    wsRoot: string;
    vaults: DVault[];
};
export declare type DPod<TConfig> = {
    config: PodConfig[];
    execute(opts: BasePodExecuteOpts<TConfig>): Promise<any>;
};
export declare type PodConfig = {
    key: string;
    description: string;
    type: "string" | "number" | "boolean";
    default?: any;
};
export declare type BasePodExecuteOpts<TConfig> = {
    config: TConfig;
    engine: DEngineClientV2;
    wsRoot: string;
    vaults: DVault[];
};
