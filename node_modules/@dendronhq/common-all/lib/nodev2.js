"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaUtilsV2 = exports.NoteUtilsV2 = exports.DNodeUtilsV2 = void 0;
const gray_matter_1 = __importDefault(require("gray-matter"));
const js_yaml_1 = __importStar(require("js-yaml"));
const lodash_1 = __importDefault(require("lodash"));
const minimatch_1 = __importDefault(require("minimatch"));
const moment_1 = __importDefault(require("moment"));
const path_1 = __importDefault(require("path"));
const vscode_uri_1 = require("vscode-uri");
const constants_1 = require("./constants");
const error_1 = require("./error");
const utils_1 = require("./utils");
const uuid_1 = require("./uuid");
const vault_1 = require("./vault");
class DNodeUtilsV2 {
    static addChild(parent, child) {
        parent.children = Array.from(new Set(parent.children).add(child.id));
        child.parent = parent.id;
    }
    static create(opts) {
        const { id, type, desc, links, fname, updated, created, parent, children, body, data, vault, } = lodash_1.default.defaults(opts, {
            updated: moment_1.default.now(),
            created: moment_1.default.now(),
            id: uuid_1.genUUID(),
            desc: "",
            links: [],
            children: [],
            parent: null,
            body: "",
            data: {},
            fname: null,
        });
        const title = opts.title || NoteUtilsV2.genTitle(fname);
        const cleanProps = {
            id,
            title,
            vault,
            type,
            desc,
            links,
            fname,
            updated,
            created,
            parent,
            children,
            body,
            data,
        };
        // don't include optional props
        const optionalProps = [
            "stub",
            "schema",
            "schemaStub",
            "custom",
        ];
        lodash_1.default.forEach(optionalProps, (op) => {
            if (opts[op]) {
                cleanProps[op] = opts[op];
            }
        });
        return cleanProps;
    }
    static basename(nodePath, rmExtension) {
        if (rmExtension) {
            const idx = nodePath.lastIndexOf(".md");
            if (idx > 0) {
                nodePath = nodePath.slice(0, idx);
            }
        }
        const [first, ...rest] = nodePath.split(".");
        return lodash_1.default.isEmpty(rest) ? first : rest.slice(-1)[0];
    }
    static dirName(nodePath) {
        return nodePath.split(".").slice(0, -1).join(".");
    }
    static domainName(nodePath) {
        return nodePath.split(".")[0];
    }
    static fname(nodePath) {
        return path_1.default.basename(nodePath, ".md");
    }
    static enhancePropForQuickInput({ props, schemas, vaults, }) {
        var _a;
        const vaultSuffix = vaults.length > 1
            ? ` (${path_1.default.basename((_a = props.vault) === null || _a === void 0 ? void 0 : _a.fsPath)})`
            : "";
        if (props.type === "note") {
            const isRoot = DNodeUtilsV2.isRoot(props);
            const label = isRoot ? "root" : props.fname;
            const detail = props.desc;
            const sm = props.schema ? schemas[props.schema.moduleId] : undefined;
            const description = NoteUtilsV2.genSchemaDesc(props, sm) + vaultSuffix;
            const out = { ...props, label, detail, description };
            return out;
        }
        else {
            const label = DNodeUtilsV2.isRoot(props) ? "root" : props.id;
            const detail = props.desc;
            const out = { ...props, label, detail, description: vaultSuffix };
            return out;
        }
    }
    static findClosestParent(fpath, nodes, opts) {
        const { vault } = opts;
        const dirname = DNodeUtilsV2.dirName(fpath);
        if (dirname === "") {
            const _node = lodash_1.default.find(nodes, (ent) => ent.fname === "root" &&
                vault_1.VaultUtils.isEqual(ent.vault, vault, opts.wsRoot));
            if (lodash_1.default.isUndefined(_node)) {
                throw new error_1.DendronError({ msg: `no root found for ${fpath}` });
            }
            return _node;
        }
        const maybeNode = NoteUtilsV2.getNoteByFnameV4({
            fname: dirname,
            notes: nodes,
            vault,
        });
        if ((maybeNode && !(opts === null || opts === void 0 ? void 0 : opts.noStubs)) ||
            (maybeNode && (opts === null || opts === void 0 ? void 0 : opts.noStubs) && !maybeNode.stub && !maybeNode.schemaStub)) {
            return maybeNode;
        }
        else {
            return DNodeUtilsV2.findClosestParent(dirname, nodes, opts);
        }
    }
    static getCustomProps(props) {
        const blacklist = [
            "id",
            "title",
            "type",
            "desc",
            "fname",
            "updated",
            "custom",
            "created",
            "parent",
            "children",
            "body",
            "data",
            "schemaStub",
            "type",
        ];
        return lodash_1.default.omit(props, blacklist);
    }
    static getDepth(node) {
        if (node.fname === "root") {
            return 0;
        }
        return node.fname.split(".").length;
    }
    static getDomain(node, opts) {
        if (node.fname === "root") {
            throw Error("root has no domain");
        }
        const isRoot = DNodeUtilsV2.isRoot(opts.nodeDict[node.parent]);
        if (isRoot) {
            return node;
        }
        else {
            return DNodeUtilsV2.getDomain(DNodeUtilsV2.getParent(node, opts), opts);
        }
    }
    static getFullPath(opts) {
        const root = path_1.default.isAbsolute(opts.vault.fsPath)
            ? opts.vault.fsPath
            : path_1.default.join(opts.wsRoot, opts.vault.fsPath);
        return path_1.default.join(root, opts.basename);
    }
    static getParent(node, opts) {
        if (DNodeUtilsV2.isRoot(node)) {
            throw Error("root has no parent");
        }
        const parent = opts.nodeDict[node.parent];
        if (lodash_1.default.isUndefined(parent)) {
            throw Error(`parent ${node.parent} not found`);
        }
        return parent;
    }
    static getChildren(node, opts) {
        const { nodeDict, recursive } = opts;
        const children = node.children.map((id) => {
            if (!lodash_1.default.has(nodeDict, id)) {
                throw Error("child nod found");
            }
            return nodeDict[id];
        });
        if (recursive) {
            return children.concat(children.map((c) => DNodeUtilsV2.getChildren(c, opts)).flat());
        }
        return children;
    }
    static getVaultByDir({ vaults, dirPath, }) {
        const vault = lodash_1.default.find(vaults, { fsPath: dirPath });
        if (lodash_1.default.isUndefined(vault)) {
            throw new error_1.DendronError({ msg: `no vault found. ${dirPath}, ${vaults}` });
        }
        return vault;
    }
    static isRoot(note) {
        return note.fname === "root";
    }
}
exports.DNodeUtilsV2 = DNodeUtilsV2;
class NoteUtilsV2 {
    static addBacklink({ from, to, link, }) {
        // const backlinks = _.filter(to.links, { type: "backlink" });
        // if (!_.find(backlinks, (ent) => ent.from.fname === from.fname)) {
        to.links.push({
            from: { fname: from.fname, vault: from.vault },
            type: "backlink",
            original: link.original,
            pos: link.pos,
            value: link.value,
        });
        // }
    }
    /**
     * Add node to parent
     * Create stubs if no direct parent exists
     * @param opts
     * @returns All notes that were changed including the parent
     */
    static addParent(opts) {
        const { note, notesList, createStubs, wsRoot } = opts;
        const parentPath = DNodeUtilsV2.dirName(note.fname);
        let parent = lodash_1.default.find(notesList, (p) => p.fname === parentPath &&
            vault_1.VaultUtils.isEqual(p.vault.fsPath, note.vault.fsPath, wsRoot)) || null;
        const changed = [];
        if (parent) {
            changed.push(parent);
            DNodeUtilsV2.addChild(parent, note);
        }
        if (!parent && !createStubs) {
            const err = {
                status: constants_1.ENGINE_ERROR_CODES.NO_PARENT_FOR_NOTE,
                msg: JSON.stringify({
                    fname: note.fname,
                }),
            };
            throw new error_1.DendronError(err);
        }
        if (!parent) {
            parent = DNodeUtilsV2.findClosestParent(note.fname, notesList, {
                vault: note.vault,
                wsRoot,
            });
            changed.push(parent);
            const stubNodes = NoteUtilsV2.createStubs(parent, note);
            stubNodes.forEach((ent2) => {
                changed.push(ent2);
            });
        }
        return changed;
    }
    static addSchema(opts) {
        const { note, schema, schemaModule } = opts;
        note.schema = { schemaId: schema.id, moduleId: schemaModule.root.id };
    }
    static create(opts) {
        const cleanOpts = lodash_1.default.defaults(opts, {
            schemaStub: false,
        });
        return DNodeUtilsV2.create({ ...cleanOpts, type: "note" });
    }
    static createWithSchema({ noteOpts, engine, }) {
        const note = NoteUtilsV2.create(noteOpts);
        const maybeMatch = SchemaUtilsV2.matchPath({
            notePath: noteOpts.fname,
            schemaModDict: engine.schemas,
        });
        if (maybeMatch) {
            const { schema, schemaModule } = maybeMatch;
            NoteUtilsV2.addSchema({ note, schemaModule, schema });
            const maybeTemplate = schema.data.template;
            if (maybeTemplate) {
                SchemaUtilsV2.applyTemplate({ template: maybeTemplate, note, engine });
            }
        }
        return note;
    }
    static createRoot(opts) {
        return DNodeUtilsV2.create({
            ...opts,
            type: "note",
            fname: "root",
            id: uuid_1.genUUID(),
        });
    }
    /**
     * Create stubs and add notes to parent
     * @param from
     * @param to
     */
    static createStubs(from, to) {
        const stubNodes = [];
        let fromPath = from.fname;
        if (DNodeUtilsV2.isRoot(from)) {
            fromPath = "";
        }
        const toPath = to.fname;
        const index = toPath.indexOf(fromPath) + fromPath.length;
        const diffPath = lodash_1.default.trimStart(toPath.slice(index), ".").split(".");
        let stubPath = fromPath;
        let parent = from;
        // last element is node
        diffPath.slice(0, -1).forEach((part) => {
            // handle starting from root, path = ""
            if (lodash_1.default.isEmpty(stubPath)) {
                stubPath = part;
            }
            else {
                stubPath += `.${part}`;
            }
            const n = NoteUtilsV2.create({
                fname: stubPath,
                stub: true,
                vault: to.vault,
            });
            stubNodes.push(n);
            DNodeUtilsV2.addChild(parent, n);
            parent = n;
        });
        DNodeUtilsV2.addChild(parent, to);
        return stubNodes;
    }
    static createWikiLink({ note, header, }) {
        const { title, fname } = note;
        let suffix = "";
        const slugger = utils_1.getSlugger();
        if (header) {
            suffix = "#" + slugger.slug(header);
        }
        const link = `[[${title}|${fname}${suffix}]]`;
        return link;
    }
    static fromSchema({ fname, schemaModule, schemaId, vault, }) {
        const mschema = schemaModule.schemas[schemaId];
        return NoteUtilsV2.create({
            fname,
            schemaStub: true,
            desc: mschema.desc,
            schema: {
                moduleId: schemaModule.root.id,
                schemaId,
            },
            vault,
        });
    }
    static genSchemaDesc(note, schemaMod) {
        const prefixParts = [];
        if (note.title !== note.fname) {
            prefixParts.push(note.title);
        }
        if (note.stub || note.schemaStub) {
            prefixParts.push("$(gist-new)");
        }
        if (note.schema) {
            if (!schemaMod) {
                throw Error("schema mod required");
            }
            const domain = schemaMod.root;
            const schema = schemaMod.schemas[note.schema.schemaId];
            // case: recognized schema
            prefixParts.push(`$(repo) ${domain.title || domain.id}`);
            // check if non-domain schema
            if (domain.id !== note.schema.schemaId) {
                prefixParts.push("$(breadcrumb-separator)");
                prefixParts.push(schema.title || schema.id);
            }
        }
        return prefixParts.join(" ");
    }
    static genTitle(fname) {
        if (lodash_1.default.toLower(fname) == fname) {
            return lodash_1.default.upperFirst(DNodeUtilsV2.basename(fname, true));
        }
        return DNodeUtilsV2.basename(fname, true);
    }
    static getNotesByFname({ fname, notes, vault, }) {
        if (!lodash_1.default.isArray(notes)) {
            notes = lodash_1.default.values(notes);
        }
        const out = lodash_1.default.filter(notes, (ent) => {
            return (ent.fname.toLowerCase() === fname.toLowerCase() &&
                (vault ? ent.vault.fsPath === vault.fsPath : true));
        });
        return out;
    }
    /**
     * Get a note.
     * If no vault is entered as a parameter, get first match
     */
    static getNoteByFnameV4({ fname, notes, vault, }) {
        if (!lodash_1.default.isArray(notes)) {
            notes = lodash_1.default.values(notes);
        }
        const out = lodash_1.default.find(notes, (ent) => {
            return (ent.fname.toLowerCase() === fname.toLowerCase() &&
                ((vault &&
                    (vault.fsPath.startsWith("/") || vault.fsPath.startsWith("\\"))
                    ? ent.vault.fsPath === vault.fsPath
                    : true) ||
                    // FIXME: for backward compatibility with full length vaults
                    (vault
                        ? path_1.default.basename(ent.vault.fsPath) === path_1.default.basename(vault.fsPath)
                        : true)));
        });
        return out;
    }
    static getNoteByFname(fname, notes, opts) {
        const _out = lodash_1.default.filter(lodash_1.default.values(notes), (ent) => {
            return ent.fname.toLowerCase() === fname.toLowerCase();
        });
        let out;
        if (_out.length > 1) {
            if (!(opts === null || opts === void 0 ? void 0 : opts.vault)) {
                throw new error_1.DendronError({
                    msg: `multiple nodes found and no vault given for ${fname}`,
                });
            }
            out = lodash_1.default.find(_out, (ent) => { var _a; return ent.vault.fsPath === ((_a = opts === null || opts === void 0 ? void 0 : opts.vault) === null || _a === void 0 ? void 0 : _a.fsPath); });
            if (lodash_1.default.isUndefined(out)) {
                throw new error_1.DendronError({
                    msg: `no note found for vault: ${opts.vault.fsPath}`,
                });
            }
        }
        else {
            out = _out[0];
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.throwIfEmpty) && lodash_1.default.isUndefined(out)) {
            throw Error(`${fname} not found in getNoteByFname`);
        }
        return out;
    }
    static getNotesWithLinkTo({ note, notes, }) {
        const maybe = lodash_1.default.values(notes).map((ent) => {
            if (lodash_1.default.find(ent.links, (l) => {
                var _a;
                return ((_a = l.to) === null || _a === void 0 ? void 0 : _a.fname) === note.fname;
            })) {
                return ent;
            }
            else {
                return;
            }
        });
        return lodash_1.default.reject(maybe, lodash_1.default.isUndefined);
    }
    static getPathV4({ note, wsRoot, }) {
        return DNodeUtilsV2.getFullPath({
            wsRoot,
            vault: note.vault,
            basename: note.fname + ".md",
        });
    }
    static getURI({ note, wsRoot }) {
        return vscode_uri_1.URI.file(this.getPathV4({ note, wsRoot }));
    }
    static getPathUpTo(hpath, numCompoenents) {
        return hpath.split(".").slice(0, numCompoenents).join(".");
    }
    static getRoots(notes) {
        return lodash_1.default.filter(lodash_1.default.values(notes), DNodeUtilsV2.isRoot);
    }
    static hydrate({ noteRaw, noteHydrated, }) {
        const hydrateProps = lodash_1.default.pick(noteHydrated, ["parent", "children"]);
        return { ...noteRaw, ...hydrateProps };
    }
    static isDefaultTitle(props) {
        return props.title === NoteUtilsV2.genTitle(props.fname);
    }
    static normalizeFname(nodePath) {
        // remove md extension
        const idx = nodePath.lastIndexOf(".md");
        if (idx > 0) {
            nodePath = nodePath.slice(0, idx);
        }
        return lodash_1.default.trim(nodePath);
    }
    static serializeMeta(props) {
        const builtinProps = lodash_1.default.pick(props, [
            "id",
            "title",
            "desc",
            "updated",
            "created",
            "stub",
            "parent",
            "children",
        ]);
        const { custom: customProps } = props;
        const meta = { ...builtinProps, ...customProps };
        return meta;
    }
    static serialize(props, opts) {
        const body = props.body;
        let blacklist = ["parent", "children"];
        if (opts === null || opts === void 0 ? void 0 : opts.writeHierarchy) {
            blacklist = [];
        }
        const meta = lodash_1.default.omit(NoteUtilsV2.serializeMeta(props), blacklist);
        return gray_matter_1.default.stringify(body || "", meta);
    }
    static toLoc(note) {
        const { fname, id } = note;
        return {
            fname,
            id,
        };
    }
    static toLogObj(note) {
        const { fname, id } = note;
        return {
            fname,
            id,
        };
    }
    static toNoteLoc(note) {
        const { fname, id, vault } = note;
        return {
            fname,
            id,
            vault,
        };
    }
    static uri2Fname(uri) {
        return path_1.default.basename(uri.fsPath, ".md");
    }
}
exports.NoteUtilsV2 = NoteUtilsV2;
NoteUtilsV2.RE_FM = /^---(.*)^---/ms;
NoteUtilsV2.RE_FM_UPDATED = /^updated:.*$/m;
NoteUtilsV2.RE_FM_CREATED = /^created:.*$/m;
class SchemaUtilsV2 {
    static applyTemplate(opts) {
        const { template, note, engine } = opts;
        if (template.type === "note") {
            const tempNote = lodash_1.default.find(lodash_1.default.values(engine.notes), { fname: template.id });
            if (lodash_1.default.isUndefined(tempNote)) {
                throw Error(`no template found for ${template}`);
            }
            const tempNoteProps = lodash_1.default.pick(tempNote, ["body", "desc", "custom"]);
            lodash_1.default.forEach(tempNoteProps, (v, k) => {
                // @ts-ignore
                note[k] = v;
            });
            return true;
        }
        return false;
    }
    static create(opts) {
        const schemaDataOpts = [
            "namespace",
            "pattern",
            "template",
        ];
        const optsWithoutData = lodash_1.default.omit(opts, schemaDataOpts);
        const optsData = lodash_1.default.pick(opts, schemaDataOpts);
        const vault = opts.vault;
        return DNodeUtilsV2.create({
            vault,
            ...lodash_1.default.defaults(optsWithoutData, {
                title: optsWithoutData.id,
                data: optsData,
                fname: "__empty",
            }),
            type: "schema",
        });
    }
    static createModule(opts) {
        return opts;
    }
    static createModuleProps(opts) {
        const { fname, vault } = opts;
        const root = SchemaUtilsV2.create({
            id: `${fname}`,
            fname,
            parent: "root",
            created: "1",
            updated: "1",
            children: [],
            vault,
        });
        return {
            version: 1,
            fname,
            root,
            schemas: { [root.id]: root },
            imports: [],
            vault,
        };
    }
    static createRootModule(opts) {
        const schema = SchemaUtilsV2.create({
            id: "root",
            title: "root",
            fname: "root.schema",
            parent: "root",
            children: [],
            ...opts,
        });
        return {
            version: 1,
            imports: [],
            schemas: [schema],
        };
    }
    static createRootModuleProps(fname, vault, opts) {
        const schema = SchemaUtilsV2.create({
            id: "root",
            title: "root",
            fname: "root",
            parent: "root",
            children: [],
            vault,
            ...opts,
        });
        return {
            version: 1,
            imports: [],
            schemas: { root: schema },
            fname,
            root: schema,
            vault,
        };
    }
    static enhanceForQuickInput({ props, vaults, }) {
        var _a;
        const vaultSuffix = vaults.length > 1
            ? ` (${path_1.default.basename((_a = props.vault) === null || _a === void 0 ? void 0 : _a.fsPath)})`
            : "";
        const label = DNodeUtilsV2.isRoot(props.root) ? "root" : props.root.id;
        const detail = props.root.desc;
        const out = {
            ...props.root,
            label,
            detail,
            description: vaultSuffix,
            vault: props.vault,
        };
        return out;
    }
    static getModuleRoot(module) {
        const maybeRoot = lodash_1.default.find(module.schemas, { parent: "root" });
        if (!maybeRoot) {
            const rootSchemaRoot = lodash_1.default.find(module.schemas, {
                parent: null,
                id: "root",
            });
            if (!rootSchemaRoot) {
                throw new error_1.DendronError({
                    status: constants_1.ENGINE_ERROR_CODES.NO_ROOT_SCHEMA_FOUND,
                });
            }
            else {
                return rootSchemaRoot;
            }
        }
        return maybeRoot;
    }
    static getPath({ root, fname }) {
        return path_1.default.join(root, fname + ".schema.yml");
    }
    static getSchemaModuleByFnameV4({ fname, schemas, vault, }) {
        if (!lodash_1.default.isArray(schemas)) {
            schemas = lodash_1.default.values(schemas);
        }
        const out = lodash_1.default.find(schemas, (ent) => {
            return (ent.fname.toLowerCase() === fname.toLowerCase() &&
                ((vault &&
                    (vault.fsPath.startsWith("/") || vault.fsPath.startsWith("\\"))
                    ? ent.vault.fsPath === vault.fsPath
                    : true) ||
                    // FIXME: for backward compatibility with full length vaults
                    (vault ? path_1.default.basename(ent.vault.fsPath) === vault.fsPath : true)));
        });
        return out;
    }
    static getSchemaFromNote({ note, engine, }) {
        if (note.schema) {
            return engine.schemas[note.schema.moduleId];
        }
        return;
    }
    /**
     * Matcn and assign schemas to all nodes within
     * a domain
     *
     * @param domain
     * @param notes
     * @param schemas
     */
    static matchDomain(domain, notes, schemas) {
        const match = schemas[domain.fname];
        if (!match) {
            return;
        }
        else {
            const domainSchema = match.schemas[match.root.id];
            return SchemaUtilsV2.matchDomainWithSchema({
                noteCandidates: [domain],
                notes,
                schemaCandidates: [domainSchema],
                schemaModule: match,
            });
        }
    }
    static matchDomainWithSchema(opts) {
        const { noteCandidates, schemaCandidates, notes, schemaModule, matchNamespace, } = lodash_1.default.defaults(opts, { matchNamespace: true });
        const matches = lodash_1.default.map(noteCandidates, (note) => {
            return SchemaUtilsV2.matchNotePathWithSchemaAtLevel({
                notePath: note.fname,
                schemas: schemaCandidates,
                schemaModule,
                matchNamespace,
            });
        }).filter((ent) => !lodash_1.default.isUndefined(ent));
        matches.map((m) => {
            const { schema, notePath } = m;
            const note = lodash_1.default.find(noteCandidates, { fname: notePath });
            NoteUtilsV2.addSchema({ note, schema, schemaModule });
            const matchNextNamespace = schema.data.namespace && matchNamespace ? false : true;
            const nextSchemaCandidates = matchNextNamespace
                ? schema.children.map((id) => schemaModule.schemas[id])
                : [schema];
            const nextNoteCandidates = note.children.map((id) => notes[id]);
            return SchemaUtilsV2.matchDomainWithSchema({
                noteCandidates: nextNoteCandidates,
                schemaCandidates: nextSchemaCandidates,
                notes,
                schemaModule,
                matchNamespace: matchNextNamespace,
            });
        });
    }
    static matchPath(opts) {
        const { notePath, schemaModDict } = opts;
        const domainName = DNodeUtilsV2.domainName(notePath);
        const match = schemaModDict[domainName];
        if (!match) {
            return;
        }
        else {
            const domainSchema = match.schemas[match.root.id];
            if (domainName.length === notePath.length) {
                return {
                    schema: domainSchema,
                    notePath,
                    namespace: domainSchema.data.namespace || false,
                    schemaModule: match,
                };
            }
            return SchemaUtilsV2.matchPathWithSchema({
                notePath,
                matched: "",
                schemaCandidates: [domainSchema],
                schemaModule: match,
            });
        }
    }
    /**
     *
     * @param param0
     * @return
     *  - schemaModule
     *  - schema
     *  - namespace
     *  - notePath
     */
    static matchPathWithSchema({ notePath, matched, schemaCandidates, schemaModule, matchNamespace = true, }) {
        const getChildOfPath = (notePath, matched) => {
            const nextLvlIndex = lodash_1.default.indexOf(notePath, ".", matched.length + 1);
            return nextLvlIndex > 0 ? notePath.slice(0, nextLvlIndex) : notePath;
        };
        const nextNotePath = getChildOfPath(notePath, matched);
        const match = SchemaUtilsV2.matchNotePathWithSchemaAtLevel({
            notePath: nextNotePath,
            schemas: schemaCandidates,
            schemaModule,
            matchNamespace,
        });
        if (match) {
            const { schema, namespace } = match;
            // found a match
            if (notePath === nextNotePath) {
                return {
                    schemaModule,
                    schema,
                    namespace,
                    notePath,
                };
            }
            // if current note is a namespace and we are currently matching namespaces, don't match on the next turn
            const matchNextNamespace = schema.data.namespace && matchNamespace ? false : true;
            // if we are not matching the next namespace, then we go back to regular matching behavior
            const nextSchemaCandidates = matchNextNamespace
                ? schema.children.map((id) => schemaModule.schemas[id])
                : [schema];
            return SchemaUtilsV2.matchPathWithSchema({
                notePath,
                matched: nextNotePath,
                schemaCandidates: nextSchemaCandidates,
                schemaModule,
                matchNamespace: matchNextNamespace,
            });
        }
        return;
    }
    static matchNotePathWithSchemaAtLevel({ notePath, schemas, schemaModule, matchNamespace = true, }) {
        const notePathClean = notePath.replace(/\./g, "/");
        let namespace = false;
        let match = lodash_1.default.find(schemas, (sc) => {
            var _a;
            const pattern = SchemaUtilsV2.getPatternRecursive(sc, schemaModule.schemas);
            if (((_a = sc === null || sc === void 0 ? void 0 : sc.data) === null || _a === void 0 ? void 0 : _a.namespace) && matchNamespace) {
                namespace = true;
                return minimatch_1.default(notePathClean, lodash_1.default.trimEnd(pattern, "/*"));
            }
            else {
                return minimatch_1.default(notePathClean, pattern);
            }
        });
        if (match) {
            return {
                schema: match,
                namespace,
                notePath,
                schemaModule,
            };
        }
        return;
    }
    static serializeSchemaProps(props) {
        const builtinProps = lodash_1.default.pick(props, [
            "id",
            "children",
        ]);
        const optional = [
            "title",
            "desc",
        ];
        lodash_1.default.forEach(optional, (opt) => {
            if (props[opt]) {
                builtinProps[opt] = props[opt];
            }
        });
        const dataProps = props.data;
        // special for root
        if ((props === null || props === void 0 ? void 0 : props.parent) === "root") {
            builtinProps.parent = "root";
        }
        return { ...builtinProps, ...dataProps };
    }
    static serializeModuleProps(moduleProps) {
        const { version, imports, schemas } = moduleProps;
        // TODO: filter out imported schemas
        const out = {
            version,
            imports: [],
            schemas: lodash_1.default.values(schemas).map((ent) => this.serializeSchemaProps(ent)),
        };
        if (imports) {
            out.imports = imports;
        }
        return js_yaml_1.default.safeDump(out, { schema: js_yaml_1.JSON_SCHEMA });
    }
    static serializeModuleOpts(moduleOpts) {
        const { version, imports, schemas } = lodash_1.default.defaults(moduleOpts, {
            imports: [],
        });
        const out = {
            version,
            imports,
            schemas: lodash_1.default.values(schemas).map((ent) => this.serializeSchemaProps(ent)),
        };
        return js_yaml_1.default.safeDump(out, { schema: js_yaml_1.JSON_SCHEMA });
    }
}
exports.SchemaUtilsV2 = SchemaUtilsV2;
SchemaUtilsV2.getPattern = (schema, opts) => {
    var _a, _b;
    const pattern = ((_a = schema === null || schema === void 0 ? void 0 : schema.data) === null || _a === void 0 ? void 0 : _a.pattern) || schema.id;
    const part = ((_b = schema === null || schema === void 0 ? void 0 : schema.data) === null || _b === void 0 ? void 0 : _b.namespace) && !(opts === null || opts === void 0 ? void 0 : opts.isNotNamespace)
        ? `${pattern}/*`
        : pattern;
    return part;
};
SchemaUtilsV2.getPatternRecursive = (schema, schemas) => {
    const part = SchemaUtilsV2.getPattern(schema);
    if (lodash_1.default.isNull(schema.parent)) {
        return part;
    }
    const parent = schemas[schema.parent];
    if (parent && parent.id !== "root") {
        const prefix = SchemaUtilsV2.getPatternRecursive(parent, schemas);
        return [prefix, part].join("/");
    }
    else {
        return part;
    }
};
SchemaUtilsV2.hasSimplePattern = (schema, opts) => {
    const pattern = SchemaUtilsV2.getPattern(schema, opts);
    return !lodash_1.default.isNull(pattern.match(/^[a-zA-Z0-9_-]*$/));
};
//# sourceMappingURL=nodev2.js.map