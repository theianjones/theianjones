"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VaultUtils = exports.tmp = exports.writeJSONWithComments = exports.vault2Path = exports.tmpDir = exports.readJSONWithComments = exports.assignJSONWithComment = exports.schemaModuleProps2File = exports.schemaModuleOpts2File = exports.note2File = exports.goUpTo = exports.file2Note = exports.string2Note = exports.string2Schema = exports.file2Schema = exports.createFileWatcher = void 0;
const common_all_1 = require("@dendronhq/common-all");
const comment_json_1 = require("comment-json");
const fs_extra_1 = __importDefault(require("fs-extra"));
const gray_matter_1 = __importDefault(require("gray-matter"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
// @ts-ignore
const tmp_1 = __importStar(require("tmp"));
exports.tmp = tmp_1.default;
const files_1 = require("./files");
const parser_1 = require("./parser");
async function createFileWatcher(opts) {
    const { numTries, fpath, onChange } = lodash_1.default.defaults(opts, {
        numTries: 5,
    });
    let didCreate = false;
    return new Promise(async (resolve, _reject) => {
        if (!fs_extra_1.default.existsSync(fpath)) {
            return setTimeout(() => {
                resolve(_createFileWatcher({
                    ...opts,
                    numTries: numTries - 1,
                    isCreate: true,
                }));
            }, 3000);
        }
        const watcher = fs_extra_1.default.watch(fpath, () => {
            onChange({ fpath });
        });
        return resolve({ watcher, didCreate });
    });
}
exports.createFileWatcher = createFileWatcher;
async function _createFileWatcher(opts) {
    const { numTries, fpath, onChange, onCreate } = lodash_1.default.defaults(opts, {
        numTries: 5,
    });
    if (numTries <= 0) {
        throw new common_all_1.DendronError({ msg: "exceeded numTries" });
    }
    return new Promise(async (resolve, _reject) => {
        if (!fs_extra_1.default.existsSync(fpath)) {
            console.log({ fpath, msg: "not exist" });
            return setTimeout(() => {
                resolve(createFileWatcher({ ...opts, numTries: numTries - 1 }));
            }, 3000);
        }
        await onCreate({ fpath });
        const watcher = fs_extra_1.default.watch(fpath, () => {
            onChange({ fpath });
        });
        return resolve({ watcher, didCreate: true });
    });
}
function file2Schema(fpath) {
    const root = { fsPath: path_1.default.dirname(fpath) };
    const fname = path_1.default.basename(fpath, ".schema.yml");
    const schemaOpts = js_yaml_1.default.safeLoad(fs_extra_1.default.readFileSync(fpath, { encoding: "utf8" }), {
        schema: js_yaml_1.default.JSON_SCHEMA,
    });
    return parser_1.SchemaParserV2.parseRaw(schemaOpts, { root, fname });
}
exports.file2Schema = file2Schema;
function string2Schema({ vault, content, fname, }) {
    const schemaOpts = js_yaml_1.default.safeLoad(content, {
        schema: js_yaml_1.default.JSON_SCHEMA,
    });
    return parser_1.SchemaParserV2.parseRaw(schemaOpts, { root: vault, fname });
}
exports.string2Schema = string2Schema;
function string2Note({ content, fname, vault, }) {
    const options = {
        engines: {
            yaml: {
                parse: (s) => js_yaml_1.default.safeLoad(s, { schema: js_yaml_1.default.JSON_SCHEMA }),
                stringify: (s) => js_yaml_1.default.safeDump(s, { schema: js_yaml_1.default.JSON_SCHEMA }),
            },
        },
    };
    const { data, content: body } = gray_matter_1.default(content, options);
    const custom = common_all_1.DNodeUtilsV2.getCustomProps(data);
    const note = common_all_1.DNodeUtilsV2.create({
        ...data,
        custom,
        fname,
        body,
        type: "note",
        vault,
    });
    return note;
}
exports.string2Note = string2Note;
function file2Note(fpath, vault) {
    const content = fs_extra_1.default.readFileSync(fpath, { encoding: "utf8" });
    const { name: fname } = path_1.default.parse(fpath);
    return string2Note({ content, fname, vault });
}
exports.file2Note = file2Note;
function goUpTo(base, fname) {
    fname = fname || "package.json";
    let acc = 10;
    const lvls = [];
    while (acc > 0) {
        const tryPath = path_1.default.join(base, ...lvls, fname);
        if (fs_extra_1.default.existsSync(tryPath)) {
            return path_1.default.dirname(tryPath);
        }
        acc -= 1;
        lvls.push("..");
    }
    throw Error(`no root found from ${base}`);
}
exports.goUpTo = goUpTo;
function note2File({ note, vault, wsRoot, opts, }) {
    const { fname } = note;
    const ext = ".md";
    const payload = common_all_1.NoteUtilsV2.serialize(note, opts);
    const vpath = exports.vault2Path({ vault, wsRoot });
    return fs_extra_1.default.writeFile(path_1.default.join(vpath, fname + ext), payload);
}
exports.note2File = note2File;
function schemaModuleOpts2File(schemaFile, vaultPath, fname) {
    const ext = ".schema.yml";
    return fs_extra_1.default.writeFile(path_1.default.join(vaultPath, fname + ext), common_all_1.SchemaUtilsV2.serializeModuleOpts(schemaFile));
}
exports.schemaModuleOpts2File = schemaModuleOpts2File;
function schemaModuleProps2File(schemaMProps, vpath, fname) {
    const ext = ".schema.yml";
    return fs_extra_1.default.writeFile(path_1.default.join(vpath, fname + ext), common_all_1.SchemaUtilsV2.serializeModuleProps(schemaMProps));
}
exports.schemaModuleProps2File = schemaModuleProps2File;
function assignJSONWithComment(jsonObj, dataToAdd) {
    return comment_json_1.assign({
        ...dataToAdd,
    }, jsonObj);
}
exports.assignJSONWithComment = assignJSONWithComment;
async function readJSONWithComments(fpath) {
    const content = await fs_extra_1.default.readFile(fpath);
    const obj = comment_json_1.parse(content.toString());
    return obj;
}
exports.readJSONWithComments = readJSONWithComments;
function tmpDir() {
    const dirPath = tmp_1.dirSync();
    return dirPath;
}
exports.tmpDir = tmpDir;
exports.vault2Path = ({ vault, wsRoot, }) => {
    return files_1.resolvePath(vault.fsPath, wsRoot);
};
function writeJSONWithComments(fpath, data) {
    const payload = comment_json_1.stringify(data, null, 4);
    return fs_extra_1.default.writeFileSync(fpath, payload);
}
exports.writeJSONWithComments = writeJSONWithComments;
// @deprecated - use VaultUtils in common-all
class VaultUtils {
    static getName(vault) {
        return vault.name || path_1.default.basename(vault.fsPath);
    }
    static isEqual(vaultSrc, vaultCmp, wsRoot) {
        return (this.normVaultPath({ vault: vaultSrc, wsRoot }) ===
            this.normVaultPath({ vault: vaultCmp, wsRoot }));
    }
    static getByVaultPath({ wsRoot, vaults, vaultPath, }) {
        // get diname
        const vault = lodash_1.default.find(vaults, (ent) => {
            let cmp = path_1.default.isAbsolute(vaultPath)
                ? path_1.default.relative(wsRoot, vaultPath)
                : vaultPath;
            return ent.fsPath === cmp;
        });
        if (!vault) {
            throw new common_all_1.DendronError({ msg: "no vault found" });
        }
        return vault;
    }
    static getVaultByNotePathV4({ vaults, fsPath, }) {
        // get diname
        fsPath = path_1.default.dirname(fsPath);
        const vault = lodash_1.default.find(vaults, { fsPath });
        if (!vault) {
            throw new common_all_1.DendronError({ msg: "no vault found" });
        }
        return vault;
    }
}
exports.VaultUtils = VaultUtils;
VaultUtils.normVaultPath = (opts) => {
    return path_1.default.isAbsolute(opts.vault.fsPath)
        ? path_1.default.relative(opts.wsRoot, opts.vault.fsPath)
        : opts.vault.fsPath;
};
//# sourceMappingURL=filesv2.js.map