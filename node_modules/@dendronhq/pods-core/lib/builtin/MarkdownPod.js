"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarkdownPublishPod = exports.MarkdownImportPod = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const engine_server_1 = require("@dendronhq/engine-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const klaw_1 = __importDefault(require("klaw"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const through2_1 = __importDefault(require("through2"));
const basev2_1 = require("../basev2");
const ID = "dendron.markdown";
const toMarkdownLink = (assetPath, opts) => {
    const name = (opts === null || opts === void 0 ? void 0 : opts.name) ? opts.name : path_1.default.parse(assetPath).name;
    return `- [${name}](${assetPath})`;
};
class MarkdownImportPod extends basev2_1.ImportPod {
    async _collectItems(root) {
        const items = []; // files, directories, symlinks, etc
        const mask = root.endsWith("/") ? root.length : root.length + 1;
        const excludeFilter = through2_1.default.obj(function (item, _enc, next) {
            // check if hidden file
            if (!lodash_1.default.some(item.path.split("/"), (ent) => ent.startsWith("."))) {
                this.push(item);
            }
            next();
        });
        return await new Promise((resolve, _reject) => {
            klaw_1.default(root)
                .pipe(excludeFilter)
                // eslint-disable-next-line prefer-arrow-callback
                .on("data", function (item) {
                const out = { ...item, entries: [] };
                if (item.path.endsWith(".md")) {
                    const { data, content } = common_server_1.readMD(item.path);
                    out.data = data;
                    out.body = content;
                }
                out.path = out.path.slice(mask);
                items.push(out);
            })
                .on("end", () => {
                resolve(items);
            });
        });
    }
    async _prepareItems(items) {
        const engineFileDict = {};
        const assetFileDict = {};
        // create map of files
        lodash_1.default.each(items, (v, _k) => {
            if (lodash_1.default.some([v.path.endsWith(".md"), v.stats.isDirectory()])) {
                engineFileDict[v.path] = v;
            }
            else {
                assetFileDict[v.path] = v;
            }
        });
        // add assets
        lodash_1.default.values(assetFileDict).forEach((ent) => {
            let dirname = path_1.default.dirname(ent.path);
            // root directories
            if (dirname === ".") {
                dirname = "";
            }
            engineFileDict[dirname].entries.push(ent);
        });
        return { engineFileDict, assetFileDict };
    }
    _files2HierarichalDict(opts) {
        const { files, src, vaultPath, wsRoot } = opts;
        const vault = { fsPath: vaultPath };
        const out = {};
        lodash_1.default.forEach(files, (item) => {
            const fname = common_server_1.cleanFileName(item.path, {
                isDir: item.stats.isDirectory(),
            });
            const lvl = fname.split(".").length;
            if (!lodash_1.default.has(out, lvl)) {
                out[lvl] = [];
            }
            const stub = item.stats.isDirectory() && lodash_1.default.isEmpty(item.entries);
            const noteProps = common_all_1.NoteUtilsV2.create({ fname, stub, vault });
            if (item === null || item === void 0 ? void 0 : item.body) {
                noteProps.body = item.body;
            }
            if (item === null || item === void 0 ? void 0 : item.data) {
                noteProps.data = item.data;
            }
            // deal with non-md files
            if (!lodash_1.default.isEmpty(item.entries)) {
                // move entries over
                // TODO: don't hardcode assets
                const assetDirName = "assets";
                const vpath = common_server_1.vault2Path({ vault, wsRoot });
                const assetDir = path_1.default.join(vpath, assetDirName);
                fs_extra_1.default.ensureDirSync(assetDir);
                const mdLinks = [];
                item.entries.map((_item) => {
                    const uuid = common_all_1.genUUID();
                    const { ext, name } = path_1.default.parse(_item.path);
                    // const { ext, name } = path.parse(cleanFileName(_item.path));
                    const assetBaseNew = `${common_server_1.cleanFileName(name)}-${uuid}${ext}`;
                    const assetPathFull = path_1.default.join(assetDir, assetBaseNew);
                    const assetPathRel = path_1.default.join(assetDirName, assetBaseNew);
                    // TODO: make sure to append uuid
                    fs_extra_1.default.copyFileSync(path_1.default.join(src, _item.path), assetPathFull);
                    mdLinks.push(toMarkdownLink(assetPathRel, { name: `${name}${ext}` }));
                });
                // TODO
                noteProps.body = `# Imported Assets\n${mdLinks.join("\n")}`;
            }
            out[lvl].push(noteProps);
        });
        return out;
    }
    hDict2Notes(hdict) {
        const noteDict = {};
        // TODO: currently don't handle stuff attached to root
        hdict[1]
            .filter((n) => !lodash_1.default.isEmpty(n.fname))
            .forEach((props) => {
            const n = common_all_1.NoteUtilsV2.create({ ...props });
            noteDict[n.fname] = n;
        });
        let lvl = 2;
        let currRawNodes = hdict[lvl];
        while (!lodash_1.default.isEmpty(currRawNodes)) {
            currRawNodes.forEach((props) => {
                const parentPath = common_all_1.DNodeUtilsV2.dirName(props.fname);
                if (lodash_1.default.has(noteDict, parentPath)) {
                    const n = common_all_1.NoteUtilsV2.create({ ...props });
                    common_all_1.DNodeUtilsV2.addChild(noteDict[parentPath], n);
                    noteDict[n.fname] = n;
                }
                else {
                    throw Error("missing notes not supported yet");
                }
            });
            lvl += 1;
            currRawNodes = hdict[lvl];
        }
        return lodash_1.default.values(noteDict);
    }
    async clean(opts) {
        return opts.config;
    }
    async plant(opts) {
        const ctx = "FilePod";
        const { wsRoot, engine } = opts;
        const { src } = opts.config;
        this.L.info({ ctx, wsRoot, src, msg: "enter" });
        // get all items
        const items = await this._collectItems(src.fsPath);
        const { engineFileDict } = await this._prepareItems(items);
        const mainVault = engine.vaults[0];
        const hDict = this._files2HierarichalDict({
            files: lodash_1.default.values(engineFileDict),
            src: src.fsPath,
            vaultPath: mainVault,
            wsRoot,
        });
        const notes = this.hDict2Notes(hDict);
        const out = await Promise.all(notes
            .filter((n) => !n.stub)
            .map(async (n) => {
            const cBody = await engine_server_1.ParserUtilsV2.getRemark({
                dendronLinksOpts: { convertObsidianLinks: true },
            }).process(n.body);
            n.body = cBody.toString();
            return engine.writeNote(n, {
                newNode: true,
                noAddParent: true,
            });
        }));
        return out;
    }
}
exports.MarkdownImportPod = MarkdownImportPod;
MarkdownImportPod.id = ID;
MarkdownImportPod.description = "import markdown";
class MarkdownPublishPod extends basev2_1.PublishPod {
    async plant(opts) {
        const { config, engine } = opts;
        const { fname, vault } = config;
        const note = common_all_1.NoteUtilsV2.getNoteByFnameV4({
            fname,
            notes: engine.notes,
            vault,
        });
        const remark = engine_server_1.ParserUtilsV2.getRemark().use(engine_server_1.dendronNoteRefPlugin, {
            engine,
            renderWithOutline: false,
            replaceRefOpts: {},
        });
        const out = remark.processSync(note.body).toString();
        return lodash_1.default.trim(out);
    }
}
exports.MarkdownPublishPod = MarkdownPublishPod;
MarkdownPublishPod.id = ID;
MarkdownPublishPod.description = "publish markdown";
//# sourceMappingURL=MarkdownPod.js.map