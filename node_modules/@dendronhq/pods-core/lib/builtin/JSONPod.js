"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONExportPod = exports.JSONPublishPod = exports.JSONImportPod = void 0;
const common_all_1 = require("@dendronhq/common-all");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const basev2_1 = require("../basev2");
const ID = "dendron.json";
class JSONImportPod extends basev2_1.ImportPod {
    get config() {
        return super.config.concat([
            {
                key: "concatenate",
                description: "concatenate all entries into one note? if set to true, need to set `destName`",
                type: "boolean",
                default: false,
            },
            {
                key: "destName",
                description: "if `concatenate: true`, specify name of concatenated note",
                type: "string",
            },
        ]);
    }
    async clean(opts) {
        return opts.config;
    }
    async plant(opts) {
        const ctx = "JSONPod";
        this.L.info({ ctx, opts, msg: "enter" });
        const engine = opts.engine;
        const { src, destName, concatenate } = opts.config;
        const entries = fs_extra_1.default.readJSONSync(src.fsPath);
        const vault = engine.vaultsv3[0];
        const notes = await this._entries2Notes(entries, {
            vault,
            destName,
            concatenate,
        });
        return Promise.all(lodash_1.default.map(notes, (n) => engine.writeNote(n, { newNode: true })));
    }
    async _entries2Notes(entries, opts) {
        const { vault } = opts;
        const notes = lodash_1.default.map(entries, (ent) => {
            if (!ent.fname) {
                throw Error("fname not defined");
            }
            let fname = ent.fname;
            return common_all_1.NoteUtilsV2.create({ ...ent, fname, vault });
        });
        if (opts.concatenate) {
            if (!opts.destName) {
                throw Error("destname needs to be specified if concatenate is set to true");
            }
            const acc = [""];
            lodash_1.default.forEach(notes, (n) => {
                acc.push(`# [[${n.fname}]]`);
                acc.push(n.body);
                acc.push("---");
            });
            return [
                common_all_1.NoteUtilsV2.create({
                    fname: opts.destName,
                    body: acc.join("\n"),
                    vault,
                }),
            ];
        }
        else {
            return notes;
        }
    }
}
exports.JSONImportPod = JSONImportPod;
JSONImportPod.id = ID;
JSONImportPod.description = "import json";
class JSONPublishPod extends basev2_1.PublishPod {
    async plant(opts) {
        const { config, engine } = opts;
        const { fname, vault } = config;
        const note = common_all_1.NoteUtilsV2.getNoteByFnameV4({
            fname,
            notes: engine.notes,
            vault,
        });
        const out = JSON.stringify(note, null, 4);
        return out;
    }
}
exports.JSONPublishPod = JSONPublishPod;
JSONPublishPod.id = ID;
JSONPublishPod.description = "publish json";
class JSONExportPod extends basev2_1.ExportPod {
    async clean(opts) {
        return opts.config;
    }
    async plant(opts) {
        const { config, engine } = opts;
        // verify root
        const podDstPath = config.dest.fsPath;
        fs_extra_1.default.ensureDirSync(path_1.default.dirname(podDstPath));
        const notes = this.preareNotesForExport({
            config,
            notes: lodash_1.default.values(engine.notes),
        });
        fs_extra_1.default.writeJSONSync(podDstPath, notes, { encoding: "utf8" });
    }
}
exports.JSONExportPod = JSONExportPod;
JSONExportPod.id = ID;
JSONExportPod.description = "export notes to snapshot";
//# sourceMappingURL=JSONPod.js.map