"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapshotImportPod = exports.SnapshotExportPod = void 0;
const common_all_1 = require("@dendronhq/common-all");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const basev2_1 = require("../basev2");
const ID = "dendron.snapshot";
function genVaultId(vaultPath) {
    return path_1.default.basename(vaultPath);
}
class SnapshotExportPod extends basev2_1.ExportPod {
    get config() {
        return [
            {
                key: "dest",
                description: "where will output be stored",
                type: "string",
                default: "snapshots",
            },
            {
                key: "ignore",
                description: "what files will be ignored during snapshot",
                type: "string",
                default: ".git",
            },
        ];
    }
    async backupVault({ vault, snapshotDirPath, ignore, }) {
        const vaultId = genVaultId(vault.fsPath);
        return fs_extra_1.default.copy(vault.fsPath, path_1.default.join(snapshotDirPath, vaultId), {
            filter: (src) => {
                if (lodash_1.default.isEmpty(ignore)) {
                    return true;
                }
                src = lodash_1.default.trimStart(lodash_1.default.replace(src, vault.fsPath, ""), "/");
                return !lodash_1.default.some(ignore, (ent) => {
                    return common_all_1.DUtils.minimatch(src, ent);
                });
            },
        });
    }
    async clean(opts) {
        // set ignore
        const { ignore } = lodash_1.default.defaults(opts.config, { ignore: ".git" });
        let cIgnore = lodash_1.default.reject(ignore.split(","), (ent) => lodash_1.default.isEmpty(ent));
        return {
            ...opts.config,
            ignore: cIgnore,
        };
    }
    async plant(opts) {
        const { config, vaults } = opts;
        const { ignore } = config;
        // const payload = this.prepareForExport(opts);
        // verify snapshot root
        const snapshotRoot = config.dest.fsPath;
        fs_extra_1.default.ensureDirSync(snapshotRoot);
        // create snapshot folder
        const snapshotDirId = common_all_1.Time.now().toMillis().toString();
        const snapshotDirPath = path_1.default.join(snapshotRoot, snapshotDirId);
        fs_extra_1.default.ensureDirSync(snapshotDirPath);
        await Promise.all(vaults.map((vault) => {
            return this.backupVault({
                vault,
                snapshotDirPath,
                ignore,
            });
        }));
        return { snapshotDirPath };
    }
}
exports.SnapshotExportPod = SnapshotExportPod;
SnapshotExportPod.id = ID;
SnapshotExportPod.description = "export notes to snapshot";
class SnapshotUtils {
    static copy({ src, dst, ignore, }) {
        return fs_extra_1.default.copy(src, dst, {
            filter: (_src) => {
                if (lodash_1.default.isEmpty(ignore)) {
                    return true;
                }
                _src = lodash_1.default.trimStart(lodash_1.default.replace(_src, src, ""), "/");
                return !lodash_1.default.some(ignore, (ent) => {
                    return common_all_1.DUtils.minimatch(_src, ent);
                });
            },
        });
    }
    static snapshotDir2Vault({ vaults, wsRoot, }) {
        if (lodash_1.default.isEmpty(vaults)) {
            return { fsPath: path_1.default.join(wsRoot, "vault") };
        }
        // TODO: impl for multi-vault
        return vaults[0];
    }
}
class SnapshotImportPod extends basev2_1.ImportPod {
    get config() {
        return [];
    }
    async restoreVault({ wsRoot, vaults, snapshotDirPath, }) {
        const vault = SnapshotUtils.snapshotDir2Vault({
            snapshotDirPath,
            vaults,
            wsRoot,
        });
        return SnapshotUtils.copy({
            src: snapshotDirPath,
            dst: vault.fsPath,
            ignore: [".git"],
        });
    }
    async clean(opts) {
        const { config } = opts;
        return config;
    }
    async plant(opts) {
        const ctx = "SnapshotImportPod:plant";
        const { config, wsRoot, vaults } = opts;
        const { src } = config;
        const vaultSnapshots = fs_extra_1.default.readdirSync(src.fsPath);
        this.L.info({ ctx, src: src.fsPath });
        await Promise.all(vaultSnapshots.map((ent) => {
            return this.restoreVault({
                wsRoot,
                vaults,
                snapshotDirPath: path_1.default.join(src.fsPath, ent),
            });
        }));
    }
}
exports.SnapshotImportPod = SnapshotImportPod;
SnapshotImportPod.id = ID;
SnapshotImportPod.description = "import snapshot";
//# sourceMappingURL=SnapshotPod.js.map