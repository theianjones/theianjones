"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublishPod = exports.ImportPod = exports.ExportPod = exports.BasePod = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const common_server_1 = require("@dendronhq/common-server");
const vscode_uri_1 = require("vscode-uri");
const fs_extra_1 = __importDefault(require("fs-extra"));
class BasePod {
    constructor() {
        this.L = common_server_1.createLogger("PodLogger");
    }
    getPodPath({ fpath, wsRoot, pathKey, }) {
        let destPath = fpath;
        if (lodash_1.default.isUndefined(destPath)) {
            const maybeDest = lodash_1.default.find(this.config, { key: pathKey });
            if (lodash_1.default.isUndefined(maybeDest) || lodash_1.default.isUndefined(maybeDest.default)) {
                throw new common_all_1.DendronError({ msg: "no dest specified" });
            }
            destPath = maybeDest.default;
        }
        return vscode_uri_1.URI.file(common_server_1.resolvePath(destPath, wsRoot));
    }
}
exports.BasePod = BasePod;
class ExportPod extends BasePod {
    get config() {
        return [
            {
                key: "dest",
                description: "where to export to",
                type: "string",
            },
        ];
    }
    cleanExportConfig({ wsRoot, config, }) {
        const { includeBody, includeStubs } = lodash_1.default.defaults(config, {
            includeBody: true,
            includeStubs: false,
        });
        let dest = this.getPodPath({ fpath: config.dest, wsRoot, pathKey: "dest" });
        return {
            dest,
            includeBody,
            includeStubs,
        };
    }
    preareNotesForExport({ config, notes, }) {
        const hideBody = config.includeBody ? false : true;
        if (!config.includeStubs) {
            notes = lodash_1.default.reject(notes, { stub: true });
        }
        if (hideBody) {
            notes = notes.map((ent) => ({ ...ent, body: "" }));
        }
        return notes;
    }
    async execute(opts) {
        const { config, engine, wsRoot, vaults } = opts;
        const _config = this.cleanExportConfig({ config, wsRoot });
        const cleanConfig = await this.clean({
            config: { ...config, ..._config },
            wsRoot,
        });
        return this.plant({ config: cleanConfig, wsRoot, vaults, engine });
    }
}
exports.ExportPod = ExportPod;
ExportPod.kind = "export";
class ImportPod extends BasePod {
    get config() {
        return [
            {
                key: "src",
                description: "where to import from",
                type: "string",
            },
        ];
    }
    cleanImportConfig({ wsRoot, config, }) {
        let src = this.getPodPath({ fpath: config.src, wsRoot, pathKey: "src" });
        if (!fs_extra_1.default.existsSync(src.fsPath)) {
            throw new common_all_1.DendronError({
                friendly: `no snapshot found at ${src.fsPath}`,
            });
        }
        return {
            src,
        };
    }
    async execute(opts) {
        const { config, engine, wsRoot, vaults } = opts;
        const _config = this.cleanImportConfig({ config, wsRoot });
        const cleanConfig = await this.clean({
            config: { ...config, ..._config },
            wsRoot,
        });
        return this.plant({ config: cleanConfig, wsRoot, vaults, engine });
    }
}
exports.ImportPod = ImportPod;
ImportPod.kind = "import";
class PublishPod extends BasePod {
    get config() {
        return [
            {
                key: "dest",
                description: "where to export to",
                type: "string",
                default: "stdout",
            },
            {
                key: "fname",
                description: "where to export to",
                type: "string",
            },
            {
                key: "vault",
                description: "vault path",
                type: "string",
            },
        ];
    }
    async clean(opts) {
        return opts.config;
    }
    cleanPublishConfig({ wsRoot, config, vaults, }) {
        let dest;
        if (config.dest === "stdout") {
            dest = "stdout";
        }
        else {
            dest = this.getPodPath({ fpath: config.dest, wsRoot, pathKey: "src" });
            if (!fs_extra_1.default.existsSync(dest.fsPath)) {
                throw new common_all_1.DendronError({
                    friendly: `no snapshot found at ${dest.fsPath}`,
                });
            }
        }
        const vault = common_server_1.VaultUtils.getByVaultPath({
            wsRoot,
            vaults,
            vaultPath: config.vault,
        });
        return {
            dest,
            fname: config.fname,
            vault,
        };
    }
    async execute(opts) {
        const { config, engine, wsRoot, vaults } = opts;
        const _config = this.cleanPublishConfig({ config, wsRoot, vaults });
        const cleanConfig = await this.clean({
            config: { ...config, ..._config },
            wsRoot,
        });
        return this.plant({ config: cleanConfig, wsRoot, vaults, engine });
    }
}
exports.PublishPod = PublishPod;
PublishPod.kind = "publish";
//# sourceMappingURL=basev2.js.map