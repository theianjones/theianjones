"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PodCLICommand = exports.fetchPodClassV4 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const engine_server_1 = require("@dendronhq/engine-server");
const pods_core_1 = require("@dendronhq/pods-core");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const base_1 = require("./base");
function fetchPodClassV4(podId, opts) {
    const { podSource, pods } = opts;
    if (podSource === "builtin") {
        if (!pods) {
            throw Error("pods needs to be defined");
        }
        const podClass = lodash_1.default.find(pods, {
            id: podId,
        });
        return podClass;
    }
    else {
        const podEntry = require(podId);
        const podClass = podEntry[opts.podType];
        if (!podClass) {
            throw Error("no podClass found");
        }
        return podClass;
    }
}
exports.fetchPodClassV4 = fetchPodClassV4;
class PodCLICommand extends base_1.BaseCommand {
    static async buildArgsCore(args, _podItems) {
        args.option("podId", {
            describe: "pod to use",
        });
        args.option("vault", {
            describe: "location of vault",
        });
        args.option("wsRoot", {
            describe: "location of workspace",
        });
        // args.option("podSource", {
        //   describe: "what kind of pod are you using",
        //   choices: ["remote", "builtin"],
        //   default: "builtin"
        // });
    }
    async enrichArgs(args, pods, podType) {
        const { vault, podId, wsRoot, podSource } = lodash_1.default.defaults(args, {
            podSource: "builtin",
        });
        const podsDir = path_1.default.join(wsRoot, "pods");
        const logger = this.L;
        const engineClient = engine_server_1.DendronEngineV2.createV3({
            vaults: [{ fsPath: vault }],
            wsRoot,
            logger,
        });
        await engineClient.init();
        const podClass = fetchPodClassV4(podId, { podSource, pods, podType });
        const maybeConfig = pods_core_1.PodUtils.getConfig({ podsDir, podClass });
        if (!maybeConfig) {
            const podConfigPath = pods_core_1.PodUtils.getConfigPath({ podsDir, podClass });
            throw new common_all_1.DendronError({
                status: "no-config",
                msg: `no config found. please create a config at ${podConfigPath}`,
            });
        }
        return {
            podClass,
            config: maybeConfig,
            wsRoot,
            engineClient,
        };
    }
    async execute(opts) {
        const { podClass, config, wsRoot, engineClient } = opts;
        const vaults = engineClient.vaults.map((ent) => ({ fsPath: ent }));
        const pod = new podClass();
        await pod.execute({ wsRoot, config, engine: engineClient, vaults });
    }
}
exports.PodCLICommand = PodCLICommand;
//# sourceMappingURL=pod.js.map