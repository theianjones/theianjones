"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const api_server_1 = require("@dendronhq/api-server");
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const common_test_utils_1 = require("@dendronhq/common-test-utils");
const engine_server_1 = require("@dendronhq/engine-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const process_1 = __importDefault(require("process"));
const build_site_1 = require("../build-site");
const setupCase1 = async ({ vaultDir }) => {
    const vault = { fsPath: vaultDir };
    await common_test_utils_1.EngineTestUtilsV2.setupVault({
        vaultDir,
        initDirCb: async (vaultPath) => {
            const root = common_all_1.SchemaUtilsV2.createRootModule({ vault });
            await common_server_1.schemaModuleOpts2File(root, vaultDir, "root");
            await common_test_utils_1.NodeTestUtilsV2.createNotes({
                vaultPath,
                noteProps: [
                    {
                        id: "id.foo",
                        fname: "foo",
                        vault,
                    },
                    {
                        id: "id.bar.one",
                        fname: "bar.one",
                        vault,
                    },
                ],
            });
        },
    });
};
const setupCase2 = async ({}) => {
    return common_test_utils_1.EngineTestUtilsV2.setupWS({
        initDirCb: async (vaultPath) => {
            const vault = { fsPath: vaultPath };
            const root = common_all_1.SchemaUtilsV2.createRootModule({ vault });
            await common_server_1.schemaModuleOpts2File(root, vaultPath, "root");
            await common_test_utils_1.NodeTestUtilsV2.createNotes({
                vaultPath,
                noteProps: [
                    {
                        id: "id.foo",
                        fname: "foo",
                        vault,
                    },
                    {
                        id: "id.bar.one",
                        fname: "bar.one",
                        vault,
                    },
                ],
            });
        },
    });
};
const setupCaseCustom = async ({ noteProps }) => {
    return await common_test_utils_1.EngineTestUtilsV2.setupVault({
        initDirCb: async (vaultPath) => {
            const vault = { fsPath: vaultPath };
            const root = common_all_1.SchemaUtilsV2.createRootModule({ vault });
            await common_server_1.schemaModuleOpts2File(root, vaultPath, "root");
            await common_test_utils_1.NodeTestUtilsV2.createNotes({
                vaultPath,
                noteProps,
            });
        },
    });
};
describe("buildSite v2", () => {
    let wsRoot;
    let vault;
    let siteRootDir;
    let engineClient;
    let port;
    //@ts-ignore
    let notesDir;
    describe("incremental", () => {
        beforeAll(async () => {
            const logPath = process_1.default.env["LOG_PATH"];
            port = await api_server_1.launch({ logPath });
        });
        beforeEach(async () => {
            wsRoot = common_server_1.tmpDir().name;
            vault = path_1.default.join(wsRoot, "vault");
            fs_extra_1.default.ensureDirSync(vault);
            await setupCase1({ vaultDir: vault });
            siteRootDir = path_1.default.join(wsRoot, "docs");
            fs_extra_1.default.ensureDir(siteRootDir);
            notesDir = path_1.default.join(siteRootDir, "notes");
            engineClient = engine_server_1.DendronEngineClient.create({
                port,
                vaults: [vault],
                ws: wsRoot,
            });
            await engineClient.init();
        });
        afterEach(() => {
            fs_extra_1.default.removeSync(wsRoot);
        });
        test("basic", async () => {
            const config = {
                siteHierarchies: ["foo", "bar"],
                siteRootDir,
            };
            const cmd = new build_site_1.BuildSiteCommand();
            await cmd.execute({
                engineClient,
                config,
                wsRoot,
                writeStubs: false,
                incremental: true,
            });
            // check storage notes no change
            const notes = fs_extra_1.default.readdirSync(vault);
            expect(notes.length).toEqual(4);
            // chekc site notes
            const sitePath = path_1.default.join(siteRootDir, "notes");
            const entries = fs_extra_1.default.readdirSync(sitePath);
            expect(entries.length).toEqual(3);
        });
    });
    describe("write stubs", () => {
        let vaults;
        beforeEach(async () => {
            ({ wsRoot, vaults } = await setupCase2({}));
            vault = vaults[0];
            siteRootDir = common_server_1.tmpDir().name;
            notesDir = path_1.default.join(siteRootDir, "notes");
            engineClient = engine_server_1.DendronEngineClient.create({
                port,
                vaults: [vault],
                ws: wsRoot,
            });
            await engineClient.init();
        });
        afterEach(() => {
            fs_extra_1.default.removeSync(wsRoot);
        });
        test("no write stub", async () => {
            const config = {
                siteHierarchies: ["foo", "bar"],
                siteRootDir,
            };
            const cmd = new build_site_1.BuildSiteCommand();
            await cmd.execute({
                engineClient,
                config,
                wsRoot,
                writeStubs: false,
            });
            const notesDir = vault;
            const notes = fs_extra_1.default.readdirSync(notesDir);
            expect(notes).toMatchSnapshot();
            expect(notes.length).toEqual(6);
        });
        test("write stub", async () => {
            const config = {
                siteHierarchies: ["foo", "bar"],
                siteRootDir,
            };
            const cmd = new build_site_1.BuildSiteCommand();
            await cmd.execute({
                engineClient,
                config,
                wsRoot,
                writeStubs: true,
            });
            const notesDir = vault;
            const notes = fs_extra_1.default.readdirSync(notesDir);
            expect(notes).toMatchSnapshot();
            expect(notes.length).toEqual(7);
        });
    });
});
describe("wiki link", () => {
    let siteRootDir;
    let notesDir;
    let writeStubs = false;
    let engineClient;
    let port;
    beforeAll(async () => {
        const logPath = process_1.default.env["LOG_PATH"];
        port = await api_server_1.launch({ logPath });
    });
    beforeEach(async () => {
        siteRootDir = common_server_1.tmpDir().name;
        notesDir = path_1.default.join(siteRootDir, "notes");
    });
    const createEngine = ({ vaults, wsRoot }) => {
        return (engineClient = engine_server_1.DendronEngineClient.create({
            port,
            vaults: vaults.map((ent) => ent.fsPath),
            ws: wsRoot,
        }));
    };
    test("relative link", async () => {
        await common_test_utils_1.runEngineTest(async ({ wsRoot }) => {
            const config = {
                siteHierarchies: ["alpha"],
                siteRootDir,
            };
            const cmd = new build_site_1.BuildSiteCommand();
            await cmd.execute({
                engineClient,
                config,
                wsRoot,
                writeStubs,
            });
            let fooPath = path_1.default.join(notesDir, "alpha.md");
            const { content } = common_server_1.readMD(fooPath);
            expect(lodash_1.default.trim(content)).toEqual("[foo](notes/foo#one)");
        }, {
            preSetupHook: async ({ vaults, wsRoot }) => {
                await common_test_utils_1.NoteTestUtilsV4.createNote({
                    fname: "alpha",
                    vault: vaults[0],
                    body: "[[foo#one]]",
                    wsRoot,
                });
            },
            createEngine,
        });
    });
    test("missing link", async () => {
        await common_test_utils_1.runEngineTest(async ({ wsRoot }) => {
            const config = {
                siteHierarchies: ["foo"],
                siteRootDir,
            };
            const cmd = new build_site_1.BuildSiteCommand();
            const { errors } = await cmd.execute({
                engineClient,
                config,
                wsRoot,
                writeStubs,
            });
            let fooPath = path_1.default.join(notesDir, "foo.md");
            const { content } = common_server_1.readMD(fooPath);
            expect(content).toMatchSnapshot();
            expect(content.indexOf("[missing-link](/404.html)") >= 0).toBeTruthy();
            expect(errors).toMatchSnapshot();
            expect(errors).toEqual([
                {
                    links: [
                        "missing-link:no note found for following link: missing-link",
                    ],
                    source: "foo",
                },
            ]);
        }, {
            createEngine,
            preSetupHook: async ({ vaults, wsRoot }) => {
                await common_test_utils_1.NoteTestUtilsV4.createNote({
                    wsRoot,
                    fname: "foo",
                    body: "# Foo Content\n # Bar Content [[missing-link]]",
                    vault: vaults[0],
                });
            },
        });
    });
    test("case sensitive link", async () => {
        await common_test_utils_1.runEngineTest(async ({ wsRoot }) => {
            const config = {
                siteHierarchies: ["foo"],
                siteRootDir,
            };
            const cmd = new build_site_1.BuildSiteCommand();
            const { errors } = await cmd.execute({
                engineClient,
                config,
                wsRoot,
                writeStubs,
            });
            let fooPath = path_1.default.join(notesDir, "id.foo.one.md");
            const { content } = common_server_1.readMD(fooPath);
            expect(content).toMatchSnapshot();
            expect(content.indexOf("[foo.Mixed_case](id.foo.mixed-case)") >= 0).toBeTruthy();
            expect(errors).toEqual([]);
        }, {
            createEngine,
            preSetupHook: async ({ vaults, wsRoot }) => {
                await common_test_utils_1.NoteTestUtilsV4.createNote({
                    wsRoot,
                    fname: "foo.Mixed_case",
                    props: { id: "id.foo.mixed-case" },
                    vault: vaults[0],
                });
                await common_test_utils_1.NoteTestUtilsV4.createNote({
                    wsRoot,
                    fname: "foo.one",
                    props: { id: "id.foo.one" },
                    vault: vaults[0],
                    body: "[[foo.Mixed_case]]",
                });
            },
        });
    });
});
describe("note refs", () => {
    let root;
    let vaultDir;
    let siteRootDir;
    let dendronRoot;
    let notesDir;
    let writeStubs = false;
    let engineClient;
    let port;
    beforeAll(async () => {
        const logPath = process_1.default.env["LOG_PATH"];
        port = await api_server_1.launch({ logPath });
    });
    beforeEach(async () => {
        root = await setupCaseCustom({
            noteProps: [
                {
                    id: "id.foo",
                    fname: "foo",
                    body: "# Foo Content\n # Bar Content ((ref:[[bar]]))",
                },
                { id: "id.bar", fname: "bar", body: "# I am bar\n [[foo]]" },
                { id: "id.c", fname: "c" },
            ],
        });
        vaultDir = root;
        siteRootDir = common_server_1.tmpDir().name;
        dendronRoot = root;
        notesDir = path_1.default.join(siteRootDir, "notes");
        engineClient = engine_server_1.DendronEngineClient.create({
            port,
            vaults: [root],
            ws: path_1.default.join(root, "../"),
        });
        await engineClient.init();
    });
    afterEach(() => {
        fs_extra_1.default.removeSync(root);
    });
    test("note refs", async () => {
        const config = {
            siteHierarchies: ["foo"],
            siteRootDir,
        };
        const cmd = new build_site_1.BuildSiteCommand();
        await cmd.execute({
            engineClient,
            config,
            wsRoot: dendronRoot,
            writeStubs,
        });
        let fooPath = path_1.default.join(notesDir, "id.foo.md");
        const { content } = common_server_1.readMD(fooPath);
        expect(content).toMatchSnapshot();
        expect(content.indexOf("[foo](notes/id.foo)") >= 0).toBeTruthy();
        expect(content.indexOf("portal-container") >= 0).toBeTruthy();
    });
    test("note refs, recursive", async () => {
        const config = {
            siteHierarchies: ["foo"],
            siteRootDir,
        };
        await common_test_utils_1.NodeTestUtilsV2.createNote({
            vaultDir,
            noteProps: {
                fname: "bar.one",
                body: ["# Bar.One"].join("\n"),
            },
        });
        await common_test_utils_1.NodeTestUtilsV2.createNote({
            vaultDir,
            noteProps: {
                fname: "bar",
                body: ["# Bar", `((ref: [[bar.one]]))`].join("\n"),
            },
        });
        //{ id: "id.bar", fname: "bar", body: "# I am bar\n [[foo]]" },
        const cmd = new build_site_1.BuildSiteCommand();
        await cmd.execute({
            engineClient,
            config,
            wsRoot: dendronRoot,
            writeStubs,
        });
        let fooPath = path_1.default.join(notesDir, "id.foo.md");
        const { content } = common_server_1.readMD(fooPath);
        expect(content).toMatchSnapshot();
        lodash_1.default.every(["# Bar", "# Bar.One"], (ent) => {
            expect(content.indexOf(ent) >= 0).toBeTruthy();
        });
        expect(content.indexOf("portal-container") >= 0).toBeTruthy();
    });
    test("note refs, disable pretty", async () => {
        const config = {
            siteHierarchies: ["foo"],
            siteRootDir,
            usePrettyRefs: false,
        };
        const cmd = new build_site_1.BuildSiteCommand();
        await cmd.execute({
            engineClient,
            config,
            wsRoot: dendronRoot,
            writeStubs,
        });
        let fooPath = path_1.default.join(notesDir, "id.foo.md");
        const { content } = common_server_1.readMD(fooPath);
        expect(content).toMatchSnapshot();
        expect(content.indexOf("portal-container") >= 0).toBeFalsy();
    });
    test(common_test_utils_1.ENGINE_SERVER.NOTE_REF.WILDCARD_LINK.label, async () => {
        let vaults = [{ fsPath: vaultDir }];
        const { note } = await common_test_utils_1.ENGINE_SERVER.NOTE_REF.WILDCARD_LINK.before({
            vaults,
        });
        const results = common_test_utils_1.ENGINE_SERVER.NOTE_REF.WILDCARD_LINK.results;
        await engineClient.init();
        //
        const config = {
            siteHierarchies: ["journal"],
            siteRootDir,
            usePrettyRefs: false,
        };
        const cmd = new build_site_1.BuildSiteCommand();
        await cmd.execute({
            engineClient,
            config,
            wsRoot: dendronRoot,
            writeStubs,
        });
        let fooPath = path_1.default.join(notesDir, note.id + ".md");
        const { content } = common_server_1.readMD(fooPath);
        await common_test_utils_1.NodeTestPresetsV2.runJestHarness({
            expect,
            results,
            opts: { body: content },
        });
    });
});
describe("toc", () => {
    let vaultDir;
    let siteRootDir;
    let notesDir;
    let writeStubs = false;
    let engineClient;
    let port;
    beforeAll(async () => {
        const logPath = process_1.default.env["LOG_PATH"];
        port = await api_server_1.launch({ logPath });
    });
    beforeEach(async () => {
        siteRootDir = common_server_1.tmpDir().name;
        notesDir = path_1.default.join(siteRootDir, "notes");
        vaultDir = await common_test_utils_1.EngineTestUtilsV2.setupVault({
            initDirCb: async (vaultDir) => {
                await common_test_utils_1.NodeTestPresetsV2.createOneNoteOneSchemaPresetWithBody({
                    vaultDir,
                });
            },
        });
    });
    afterEach(() => {
        fs_extra_1.default.removeSync(vaultDir);
    });
    test("generate toc", async () => {
        await common_test_utils_1.NodeTestUtilsV2.createNote({
            vaultDir,
            noteProps: {
                id: "bar",
                custom: {
                    toc: true,
                },
                fname: "bar",
                body: [
                    "# Header1",
                    "## Table of Contents",
                    "## Header 1.1",
                    "",
                    "## Header 2",
                ].join("\n"),
            },
        });
        const wsRoot = path_1.default.join(vaultDir, "../");
        engineClient = engine_server_1.DendronEngineClient.create({
            port,
            vaults: [vaultDir],
            ws: wsRoot,
        });
        await engineClient.init();
        const config = {
            siteHierarchies: ["bar"],
            siteRootDir,
            usePrettyRefs: true,
        };
        const cmd = new build_site_1.BuildSiteCommand();
        await cmd.execute({
            engineClient,
            config,
            wsRoot,
            writeStubs,
        });
        let fooPath = path_1.default.join(notesDir, "bar.md");
        const content = fs_extra_1.default.readFileSync(fooPath, { encoding: "utf8" });
        // const { content } = readMD(fooPath);
        expect(content).toMatchSnapshot();
        expect(content.indexOf("[Header 1.1](#header-11)") >= 0).toBeTruthy();
    });
    test("no generate toc", async () => {
        await common_test_utils_1.NodeTestUtilsV2.createNote({
            vaultDir,
            noteProps: {
                id: "bar",
                fname: "bar",
                body: [
                    "# Header1",
                    "## Table of Contents",
                    "## Header 1.1",
                    "",
                    "## Header 2",
                ].join("\n"),
            },
        });
        const wsRoot = path_1.default.join(vaultDir, "../");
        engineClient = engine_server_1.DendronEngineClient.create({
            port,
            vaults: [vaultDir],
            ws: wsRoot,
        });
        await engineClient.init();
        const config = {
            siteHierarchies: ["bar"],
            siteRootDir,
            usePrettyRefs: true,
        };
        const cmd = new build_site_1.BuildSiteCommand();
        await cmd.execute({
            engineClient,
            config,
            wsRoot,
            writeStubs,
        });
        let fooPath = path_1.default.join(notesDir, "bar.md");
        const content = fs_extra_1.default.readFileSync(fooPath, { encoding: "utf8" });
        // const { content } = readMD(fooPath);
        expect(content).toMatchSnapshot();
        expect(content.indexOf("[Header 1.1](#header-11)") >= 0).toBeFalsy();
    });
});
describe("custom frontmatter", () => {
    let vaultDir;
    let siteRootDir;
    let notesDir;
    let writeStubs = false;
    let engineClient;
    let port;
    beforeAll(async () => {
        const logPath = process_1.default.env["LOG_PATH"];
        port = await api_server_1.launch({ logPath });
    });
    beforeEach(async () => {
        siteRootDir = common_server_1.tmpDir().name;
        notesDir = path_1.default.join(siteRootDir, "notes");
        vaultDir = await common_test_utils_1.EngineTestUtilsV2.setupVault({
            initDirCb: async (vaultDir) => {
                await common_test_utils_1.NodeTestPresetsV2.createOneNoteOneSchemaPresetWithBody({
                    vaultDir,
                });
            },
        });
    });
    afterEach(() => {
        fs_extra_1.default.removeSync(vaultDir);
    });
    test("basic", async () => {
        const wsRoot = path_1.default.join(vaultDir, "../");
        engineClient = engine_server_1.DendronEngineClient.create({
            port,
            vaults: [vaultDir],
            ws: wsRoot,
        });
        await engineClient.init();
        const config = {
            siteHierarchies: ["foo"],
            siteRootDir,
            usePrettyRefs: true,
            config: {
                foo: {
                    customFrontmatter: [
                        {
                            key: "bond",
                            value: 42,
                        },
                    ],
                },
            },
        };
        const cmd = new build_site_1.BuildSiteCommand();
        await cmd.execute({
            engineClient,
            config,
            wsRoot,
            writeStubs,
        });
        let fooPath = path_1.default.join(notesDir, "foo.md");
        const content = fs_extra_1.default.readFileSync(fooPath, { encoding: "utf8" });
        // const { content } = readMD(fooPath);
        expect(content).toMatchSnapshot();
        expect(content.indexOf("bond: 42") >= 0).toBeTruthy();
    });
    test("generate toc", async () => {
        await common_test_utils_1.NodeTestUtilsV2.createNote({
            vaultDir,
            noteProps: {
                id: "bar",
                fname: "bar",
                body: [
                    "# Header1",
                    "## Table of Contents",
                    "## Header 1.1",
                    "",
                    "## Header 2",
                ].join("\n"),
            },
        });
        const wsRoot = path_1.default.join(vaultDir, "../");
        engineClient = engine_server_1.DendronEngineClient.create({
            port,
            vaults: [vaultDir],
            ws: wsRoot,
        });
        await engineClient.init();
        const config = {
            siteHierarchies: ["bar"],
            siteRootDir,
            usePrettyRefs: true,
            config: {
                bar: {
                    customFrontmatter: [
                        {
                            key: "toc",
                            value: true,
                        },
                    ],
                },
            },
        };
        const cmd = new build_site_1.BuildSiteCommand();
        await cmd.execute({
            engineClient,
            config,
            wsRoot,
            writeStubs,
        });
        let fooPath = path_1.default.join(notesDir, "bar.md");
        const content = fs_extra_1.default.readFileSync(fooPath, { encoding: "utf8" });
        // const { content } = readMD(fooPath);
        expect(content).toMatchSnapshot();
        expect(content.indexOf("[Header 1.1](#header-11)") >= 0).toBeTruthy();
    });
});
const setupServer = () => {
    const logPath = process_1.default.env["LOG_PATH"];
    return api_server_1.launch({ logPath });
};
// const createEngineFactory = (_port: number) => async (opts: WorkspaceOpts) => {
//   const engineClient = DendronEngineClient.create({
//     port,
//     ws: opts.wsRoot,
//     vaults: opts.vaults.map(ent => ent.fsPath)
//   });
//   return engineClient;
// };
describe("vault specific config", () => {
    let port;
    let siteRootDir;
    let notesDir;
    beforeAll(async () => {
        port = await setupServer();
    });
    beforeEach(async () => {
        siteRootDir = common_server_1.tmpDir().name;
        notesDir = path_1.default.join(siteRootDir, "notes");
    });
    test("no whitelist", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine, wsRoot }) => {
            const config = {
                siteHierarchies: ["foo", "bar"],
                siteRootDir,
                usePrettyRefs: true,
            };
            const cmd = new build_site_1.BuildSiteCommand();
            await cmd.execute({
                engineClient: engine,
                config,
                wsRoot,
                writeStubs: false,
            });
            const notesInDir = fs_extra_1.default.readdirSync(notesDir);
            return [
                {
                    expected: ["bar.md", "foo.ch1.md", "foo.md"],
                    actual: notesInDir,
                },
            ];
        }, {
            preSetupHook: async (opts) => {
                await common_test_utils_1.ENGINE_HOOKS_MULTI.setupBasicMulti(opts);
            },
            expect,
            createEngine: (opts) => {
                const engineClient = engine_server_1.DendronEngineClient.create({
                    port,
                    ws: opts.wsRoot,
                    vaults: opts.vaults.map((ent) => ent.fsPath),
                });
                return engineClient;
            },
        });
    });
    test("blacklist primary vault", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine, wsRoot }) => {
            const config = {
                siteHierarchies: ["foo", "bar"],
                privateVaults: ["vault1"],
                siteRootDir,
                usePrettyRefs: true,
            };
            const cmd = new build_site_1.BuildSiteCommand();
            await cmd.execute({
                engineClient: engine,
                config,
                wsRoot,
                writeStubs: false,
            });
            const notesInDir = fs_extra_1.default.readdirSync(notesDir);
            return [
                {
                    expected: ["bar.md"],
                    actual: notesInDir,
                },
            ];
        }, {
            preSetupHook: async (opts) => {
                await common_test_utils_1.ENGINE_HOOKS_MULTI.setupBasicMulti(opts);
            },
            expect,
            createEngine: (opts) => {
                const engineClient = engine_server_1.DendronEngineClient.create({
                    port,
                    ws: opts.wsRoot,
                    vaults: opts.vaults.map((ent) => ent.fsPath),
                });
                return engineClient;
            },
        });
    });
    test("blacklist other vault", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine, wsRoot }) => {
            const config = {
                siteHierarchies: ["foo", "bar"],
                privateVaults: ["vault2"],
                siteRootDir,
                usePrettyRefs: true,
            };
            const cmd = new build_site_1.BuildSiteCommand();
            await cmd.execute({
                engineClient: engine,
                config,
                wsRoot,
                writeStubs: false,
            });
            const notesInDir = fs_extra_1.default.readdirSync(notesDir);
            return [
                {
                    expected: ["foo.ch1.md", "foo.md"],
                    actual: notesInDir,
                },
            ];
        }, {
            preSetupHook: async (opts) => {
                await common_test_utils_1.ENGINE_HOOKS_MULTI.setupBasicMulti(opts);
            },
            expect,
            createEngine: (opts) => {
                const engineClient = engine_server_1.DendronEngineClient.create({
                    port,
                    ws: opts.wsRoot,
                    vaults: opts.vaults.map((ent) => ent.fsPath),
                });
                return engineClient;
            },
        });
    });
});
describe("per hierarchy config", () => {
    let vaultDir;
    let siteRootDir;
    let notesDir;
    let writeStubs = false;
    let engineClient;
    let port;
    beforeAll(async () => {
        const logPath = process_1.default.env["LOG_PATH"];
        port = await api_server_1.launch({ logPath });
    });
    beforeEach(async () => {
        siteRootDir = common_server_1.tmpDir().name;
        notesDir = path_1.default.join(siteRootDir, "notes");
        vaultDir = await common_test_utils_1.EngineTestUtilsV2.setupVault({
            initDirCb: async (vaultDir) => {
                await common_test_utils_1.NodeTestPresetsV2.createOneNoteOneSchemaPresetWithBody({
                    vaultDir,
                });
            },
        });
    });
    afterEach(() => {
        fs_extra_1.default.removeSync(vaultDir);
    });
    test("root config set", async () => {
        const wsRoot = path_1.default.join(vaultDir, "../");
        engineClient = engine_server_1.DendronEngineClient.create({
            port,
            vaults: [vaultDir],
            ws: wsRoot,
        });
        await engineClient.init();
        const config = {
            siteHierarchies: ["root"],
            siteRootDir,
            usePrettyRefs: true,
            config: {
                root: {
                    publishByDefault: false,
                },
            },
        };
        const cmd = new build_site_1.BuildSiteCommand();
        await cmd.execute({
            engineClient,
            config,
            wsRoot,
            writeStubs,
        });
        expect(fs_extra_1.default.readdirSync(notesDir)).toEqual([]);
    });
    test("root config and hierarchal config set", async () => {
        const wsRoot = path_1.default.join(vaultDir, "../");
        engineClient = engine_server_1.DendronEngineClient.create({
            port,
            vaults: [vaultDir],
            ws: wsRoot,
        });
        await engineClient.init();
        const config = {
            siteHierarchies: ["root"],
            siteRootDir,
            usePrettyRefs: true,
            config: {
                root: {
                    publishByDefault: false,
                },
                foo: {
                    publishByDefault: true,
                },
            },
        };
        const cmd = new build_site_1.BuildSiteCommand();
        await cmd.execute({
            engineClient,
            config,
            wsRoot,
            writeStubs,
        });
        expect(fs_extra_1.default.readdirSync(notesDir)).toEqual(["foo.ch1.md", "foo.md"]);
    });
});
//# sourceMappingURL=build-site.v2.spec.js.map