"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildSiteCommand = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const engine_server_1 = require("@dendronhq/engine-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const gray_matter_1 = __importDefault(require("gray-matter"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const rsync_1 = __importDefault(require("rsync"));
const soil_1 = require("./soil");
function getRoot(engine) {
    return engine.vaults[0];
}
function rsyncCopy(src, dst) {
    // rsync -a --no-times --size-only /tmp/notes/* docs/notes
    return new Promise((resolve, reject) => {
        const rsync = new rsync_1.default()
            .flags("a")
            .set("no-times")
            .set("size-only")
            .delete()
            .source(src)
            .destination(dst);
        console.log(rsync.command());
        rsync.execute((err, code, cmd) => {
            if (err) {
                err.message += JSON.stringify({
                    code,
                    cmd,
                    src,
                    dst,
                });
                reject(err);
            }
            else {
                resolve(undefined);
            }
        });
    });
}
function stripSiteOnlyTags(body) {
    const re = new RegExp(/(?<raw><!--SITE_ONLY(?<body>.*)-->)/, "ms");
    let matches;
    let doc = body;
    do {
        matches = doc.match(re);
        if (matches) {
            // @ts-ignore
            const { raw, body } = matches.groups;
            doc = doc.replace(raw, body);
        }
    } while (matches);
    return doc;
}
async function note2JekyllMdFile(note, opts) {
    var _a, _b, _c, _d;
    let meta;
    // @ts-ignore
    meta = {
        ...common_all_1.NoteUtilsV2.serializeMeta(note),
        fname: note.fname,
    };
    const jekyllProps = {
        hpath: note.fname,
    };
    const config = opts.config || {};
    const domainPath = common_all_1.DNodeUtilsV2.domainName(note.fname);
    let rConfig = lodash_1.default.defaults(lodash_1.default.get(config, "root", {
        publishByDefault: true,
        noindexByDefault: false,
        customFrontmatter: [],
    }));
    let hConfig = lodash_1.default.defaults(lodash_1.default.get(config, domainPath), rConfig);
    const siteNotesDir = config.siteNotesDir || "notes";
    if (!hConfig.publishByDefault && !((_a = note.custom) === null || _a === void 0 ? void 0 : _a.published)) {
        return [];
    }
    if (lodash_1.default.some(opts.privateVaults || [], (ent) => {
        return common_server_1.VaultUtils.isEqual(note.vault, { fsPath: ent }, opts.engine.wsRoot);
    })) {
        return [];
    }
    // root page should have '/ permalinik
    let linkPrefix = "";
    if (opts.siteIndex === meta.fname) {
        jekyllProps["permalink"] = "/";
        linkPrefix = path_1.default.basename(siteNotesDir) + "/";
    }
    let engine = opts.engine;
    let parentFname = (_b = common_all_1.NoteUtilsV2.getNoteByFnameV4({
        fname: note.fname,
        notes: engine.notes,
        vault: note.vault,
    })) === null || _b === void 0 ? void 0 : _b.fname;
    // pull children of root to the top
    if (parentFname === opts.siteIndex) {
        meta["parent"] = null;
    }
    if (hConfig.noindexByDefault && lodash_1.default.isUndefined((_c = note.custom) === null || _c === void 0 ? void 0 : _c.noindex)) {
        // @ts-ignore
        meta.noindex = true;
    }
    (_d = hConfig.customFrontmatter) === null || _d === void 0 ? void 0 : _d.forEach((fm) => {
        const { key, value } = fm;
        // @ts-ignore
        meta[key] = value;
    });
    // delete parent from root
    note.body = stripSiteOnlyTags(note.body);
    // delete content that is not meant to be published
    note.body = engine_server_1.stripLocalOnlyTags(note.body);
    const scratchPad1Dir = common_server_1.tmpDir();
    const scratchPad2Dir = common_server_1.tmpDir();
    const scratchPad1 = path_1.default.join(scratchPad1Dir.name, "scratch.txt");
    const scratchPad2 = path_1.default.join(scratchPad2Dir.name, "scratch.txt");
    try {
        let proc = engine_server_1.ParserUtilsV2.getRemark().use(engine_server_1.dendronNoteRefPlugin, {
            renderWithOutline: opts.usePrettyRefs || false,
            replaceRefOpts: {
                wikiLink2Md: true,
                wikiLinkPrefix: linkPrefix,
                imageRefPrefix: opts.assetsPrefix,
                wikiLinkUseId: true,
                engine: opts.engine,
                scratch: scratchPad1,
                forNoteRefInSite: true,
            },
            engine: opts.engine,
        });
        proc = proc.use(engine_server_1.replaceRefs, {
            wikiLink2Md: true,
            wikiLinkPrefix: linkPrefix,
            imageRefPrefix: opts.assetsPrefix,
            wikiLinkUseId: true,
            engine: opts.engine,
            scratch: scratchPad2,
            forNoteRefInSite: true,
        });
        // @ts-ignore
        if (meta === null || meta === void 0 ? void 0 : meta.toc) {
            proc = proc.use(engine_server_1.toc);
        }
        // replaces wiki-links with the markdown equivalent
        note.body = proc.processSync(note.body).toString();
    }
    catch (err) {
        console.log(err);
        throw err;
    }
    const filePath = path_1.default.join(opts.notesDir, meta.id + ".md");
    await fs_extra_1.default.writeFile(filePath, gray_matter_1.default.stringify(note.body || "", { ...meta, ...jekyllProps }));
    const errors = [];
    await Promise.all([scratchPad1Dir, scratchPad2Dir].map(async (ent) => {
        const scratchFile = path_1.default.join(ent.name, "scratch.txt");
        if (fs_extra_1.default.existsSync(scratchFile)) {
            const sc = fs_extra_1.default.readFileSync(scratchFile, { encoding: "utf8" });
            errors.push({
                source: note.fname,
                links: lodash_1.default.reject(sc.split("\n"), lodash_1.default.isEmpty),
            });
            await fs_extra_1.default.emptyDir(ent.name);
        }
        ent.removeCallback();
    }));
    return errors;
}
class BuildSiteCommand extends soil_1.SoilCommand {
    buildArgs(args) {
        super.buildArgs(args);
        args.option("writeStubs", {
            describe: "writeStubs",
            default: true,
        });
        args.option("incremental", {
            describe: "use rsync to only copy files that changed",
            default: false,
            type: "boolean",
        });
        args.option("dryRun", {
            describe: "don't actually build",
            default: false,
            type: "boolean",
        });
    }
    enrichArgs(args) {
        const args1 = super._enrichArgs(args);
        const config = engine_server_1.DConfig.getOrCreate(args.wsRoot).site;
        return { ...args1, config, writeStubs: args.writeStubs || false };
    }
    static buildCmd(yargs) {
        const _cmd = new BuildSiteCommand();
        return yargs.command("buildSite", "build notes for publication", _cmd.buildArgs, _cmd.eval);
    }
    async copyAssetsFallback(opts) {
        const { vaultAssetsDir, siteAssetsDir } = opts;
        if (!fs_extra_1.default.existsSync(path_1.default.join(vaultAssetsDir, "images"))) {
            return;
        }
        return new Promise((resolve, reject) => {
            fs_extra_1.default.copy(path_1.default.join(vaultAssetsDir, "images"), path_1.default.join(siteAssetsDir, "images"), (err) => {
                if (err) {
                    err.message += JSON.stringify({ vaultAssetsDir, siteAssetsDir });
                    reject(err);
                }
                this.L.info({ msg: "finish copying" });
                resolve(undefined);
            });
        });
    }
    async copyAssets(opts) {
        const { vaultAssetsDir, siteAssetsDir } = opts;
        if (!fs_extra_1.default.existsSync(path_1.default.join(vaultAssetsDir, "images"))) {
            return;
        }
        const src = path_1.default.join(vaultAssetsDir, "images");
        const dst = path_1.default.join(siteAssetsDir);
        const rsync = new rsync_1.default().flags("az").delete().source(src).destination(dst);
        return new Promise((resolve, reject) => {
            rsync.execute((err, code, cmd) => {
                if (err) {
                    err.message += JSON.stringify({
                        code,
                        cmd,
                        vaultAssetsDir,
                        siteAssetsDir,
                    });
                    reject(err);
                }
                else {
                    this.L.info({ msg: "finish copying" });
                    resolve(undefined);
                }
            });
        });
    }
    async doBuildV2(opts) {
        const { engineClient, config, writeStubs, notesDir } = opts;
        const { siteHierarchies } = config;
        let navOrder = 0;
        const nodes = siteHierarchies.map((fname) => {
            let notes = common_all_1.NoteUtilsV2.getNotesByFname({
                fname,
                notes: engineClient.notes,
            });
            // remove blacklist notes
            // (opts.config.privateVaults || []).forEach(vaultPath => {
            //   notes = _.reject(notes, ent => VaultUtils.isEqual(ent.vault, {fsPath: vaultPath}, opts.engineClient.wsRoot));
            // });
            let note;
            if (notes.length > 1) {
                throw new common_all_1.DendronError({ msg: `mult notes found for ${fname}` });
            }
            else if (notes.length < 1) {
                throw new common_all_1.DendronError({ msg: `no notes found for ${fname}` });
            }
            else {
                note = notes[0];
            }
            if (!note.custom) {
                note.custom = {};
            }
            note.custom.nav_order = navOrder;
            note.parent = null;
            note.title = lodash_1.default.capitalize(note.title);
            navOrder += 1;
            return note;
        });
        const out = [];
        let writeStubsQ = [];
        // get rest of hieararchy
        while (!lodash_1.default.isEmpty(nodes)) {
            const node = nodes.pop();
            out.push(note2JekyllMdFile(node, {
                notesDir,
                engine: engineClient,
                ...config,
            }));
            node.children.forEach((n) => nodes.push(engineClient.notes[n]));
            if (writeStubs && node.stub) {
                node.stub = false;
                writeStubsQ.push(engineClient.writeNote(node, { writeHierarchy: true }));
            }
        }
        await Promise.all(writeStubsQ);
        const errors = await Promise.all(out);
        return lodash_1.default.flatten(errors);
    }
    async execute(opts) {
        let { config, wsRoot, writeStubs, incremental, engineClient } = lodash_1.default.defaults(opts, {
            incremental: false,
        });
        const ctx = "BuildSiteCommand";
        config = engine_server_1.DConfig.cleanSiteConfig(config);
        this.L.info({ ctx, config, incremental });
        // setup path to site
        const siteRootPath = common_server_1.resolvePath(config.siteRootDir, wsRoot);
        const siteNotesDir = "notes";
        const siteNotesDirPath = path_1.default.join(siteRootPath, siteNotesDir);
        this.L.info({ msg: "enter", siteNotesDirPath });
        fs_extra_1.default.ensureDirSync(siteNotesDirPath);
        let errors;
        if (incremental) {
            const staging = common_server_1.tmpDir();
            errors = await this.doBuildV2({
                engineClient,
                config,
                writeStubs,
                notesDir: staging.name,
            });
            this.L.info({
                ctx,
                msg: "rsync",
                src: staging.name,
                dest: siteNotesDirPath,
            });
            if (!opts.dryRun) {
                await rsyncCopy(`${path_1.default.join(staging.name, "*")}`, siteNotesDirPath);
                fs_extra_1.default.emptyDirSync(staging.name);
                staging.removeCallback();
            }
        }
        else {
            fs_extra_1.default.emptyDirSync(siteNotesDirPath);
            errors = await this.doBuildV2({
                engineClient,
                config,
                writeStubs,
                notesDir: siteNotesDirPath,
            });
        }
        // move assets
        this.L.info({ ctx, msg: "copy assets..." });
        const assetsDir = "assets";
        const vaultAssetsDir = path_1.default.join(getRoot(engineClient), assetsDir);
        const siteAssetsDir = path_1.default.join(siteRootPath, assetsDir);
        if (config.copyAssets !== false) {
            try {
                await this.copyAssets({ vaultAssetsDir, siteAssetsDir });
            }
            catch (err) {
                // this.L.error({ err, msg: "error copying assets" });
                await this.copyAssetsFallback({ vaultAssetsDir, siteAssetsDir });
                this.L.info({ msg: "use copy fallback" });
            }
        }
        this.L.info({ msg: "exit" });
        return {
            buildNotesRoot: siteRootPath,
            errors,
        };
    }
}
exports.BuildSiteCommand = BuildSiteCommand;
//# sourceMappingURL=build-site.js.map