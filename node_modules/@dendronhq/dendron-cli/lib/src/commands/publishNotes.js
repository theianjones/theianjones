"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublishNotesCommand = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const engine_server_1 = require("@dendronhq/engine-server");
const lodash_1 = __importDefault(require("lodash"));
const build_site_1 = require("./build-site");
const soil_1 = require("./soil");
class PublishNotesCommand extends soil_1.SoilCommand {
    buildArgs(args) {
        new build_site_1.BuildSiteCommand().buildArgs(args);
        args.option("noPush", {
            describe: "don't push the result",
            type: "boolean",
        });
        args.option("publishRepoDir", {
            describe: "repo to publish from. default is same as `wsRoot`",
        });
    }
    enrichArgs(args) {
        //const cleanArgs = super._enrichArgs(args);
        const cleanArgs = new build_site_1.BuildSiteCommand().enrichArgs(args);
        let out = lodash_1.default.defaults({ ...args, ...cleanArgs }, {
            buildPod: true,
            noPush: false,
            incremental: false,
            dryRun: false,
            publishRepoDir: cleanArgs.wsRoot,
        });
        out.publishRepoDir = common_server_1.resolvePath(out.publishRepoDir, out.wsRoot);
        return out;
    }
    static buildCmd(yargs) {
        const _cmd = new PublishNotesCommand();
        return yargs.command("publishNotes", "Build, commit, and push your notes for publication", _cmd.buildArgs, _cmd.eval);
    }
    static async run(args) {
        const cmd = new PublishNotesCommand();
        return cmd.eval(args);
    }
    async sanity(opts) {
        const { publishRepoDir } = opts;
        const repo = await engine_server_1.Git.getRepo(publishRepoDir);
        if (!repo) {
            throw new common_all_1.DendronError({ msg: "no repo found" });
        }
        return true;
    }
    async execute(opts) {
        const { wsRoot, noPush, incremental, writeStubs, publishRepoDir, engineClient, } = opts;
        const config = engine_server_1.DConfig.getOrCreate(wsRoot);
        const siteConfig = config.site;
        const git = new engine_server_1.Git({ localUrl: publishRepoDir });
        if (!noPush) {
            await this.sanity(opts);
        }
        const { buildNotesRoot } = await new build_site_1.BuildSiteCommand().execute({
            engineClient,
            config: siteConfig,
            wsRoot: wsRoot,
            incremental,
            writeStubs,
        });
        if (!noPush) {
            await git.addAll();
            await git.commit({ msg: "chore: publish" });
            await git.push();
        }
        return {
            buildNotesRoot,
        };
    }
}
exports.PublishNotesCommand = PublishNotesCommand;
//# sourceMappingURL=publishNotes.js.map