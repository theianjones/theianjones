"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runEngineTest = exports.runJestHarnessV2 = exports.runJestHarness = exports.runMochaHarness = exports.TestPresetEntry = exports.EngineTest = exports.AssertUtils = exports.toPlainObject = void 0;
const common_server_1 = require("@dendronhq/common-server");
const assert_1 = __importDefault(require("assert"));
const lodash_1 = __importDefault(require("lodash"));
const _1 = require(".");
exports.toPlainObject = (value) => value !== undefined ? JSON.parse(JSON.stringify(value)) : value;
class AssertUtils {
    static async assertInString({ body, match, nomatch, }) {
        await Promise.all((match || []).map((m) => {
            if (body.indexOf(m) < 0) {
                throw `${m} not found in ${body}`;
            }
            return true;
        }));
        await Promise.all((nomatch || []).map((m) => {
            if (body.indexOf(m) > 0) {
                throw `${m} found in ${body}`;
            }
            return true;
        }));
        return true;
    }
}
exports.AssertUtils = AssertUtils;
class EngineTest {
    constructor(opts) {
        this.runJest = () => { };
        this.runMocha = () => { };
        const { preSetupHook, postSetupHook, engine } = lodash_1.default.defaults(opts, {
            preSetupHook: async () => { },
            postSetupHook: async () => { },
        });
        this.preSetupHook = preSetupHook;
        this.postSetupHook = postSetupHook;
        this.engine = engine;
    }
}
exports.EngineTest = EngineTest;
class TestPresetEntry {
    constructor({ label, results, before, after, preSetupHook, postSetupHook, }) {
        this.label = label;
        this.results = results;
        this.before = before ? before : async () => { };
        this.preSetupHook = preSetupHook ? preSetupHook : async () => { };
        this.postSetupHook = postSetupHook ? postSetupHook : async () => { };
        this.after = after ? after : async () => { };
        this.init = async () => { };
    }
}
exports.TestPresetEntry = TestPresetEntry;
async function runMochaHarness(results, opts) {
    return lodash_1.default.map(await results(opts), (ent) => assert_1.default.deepStrictEqual(ent.actual, ent.expected));
}
exports.runMochaHarness = runMochaHarness;
async function runJestHarness(results, expect, opts) {
    return lodash_1.default.map(await results(opts), (ent) => expect(ent.actual).toEqual(ent.expected));
}
exports.runJestHarness = runJestHarness;
async function runJestHarnessV2(results, expect) {
    return lodash_1.default.map(await results, (ent) => expect(ent.actual).toEqual(ent.expected));
}
exports.runJestHarnessV2 = runJestHarnessV2;
// @deprecated
async function runEngineTest(func, opts) {
    const { preSetupHook, createEngine } = lodash_1.default.defaults(opts, {
        preSetupHook: async ({}) => { },
        postSetupHook: async ({}) => { },
    });
    const wsRoot = common_server_1.tmpDir().name;
    const vaults = await _1.EngineTestUtilsV3.setupVaults({
        wsRoot,
        initVault1: async (vaultDir) => {
            await _1.NotePresetsUtils.createBasic({ vaultDir, fname: "foo" });
        },
        initVault2: async (vaultDir) => {
            await _1.NotePresetsUtils.createBasic({ vaultDir, fname: "bar" });
        },
    });
    await preSetupHook({ wsRoot, vaults });
    const engine = createEngine({ wsRoot, vaults });
    const initResp = await engine.init();
    await func({ wsRoot, vaults, engine, initResp });
}
exports.runEngineTest = runEngineTest;
//# sourceMappingURL=utils.js.map