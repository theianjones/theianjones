"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoteTestPresetsV2 = exports.NoteTestUtilsV3 = exports.NodeTestPresetsV2 = exports.NodeTestUtilsV2 = exports.EngineTestUtilsV2 = exports.EngineTestUtilsV3 = exports.EngineTestUtilsV4 = exports.sinon = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
__exportStar(require("./fileUtils"), exports);
__exportStar(require("./noteUtils"), exports);
__exportStar(require("./presets"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./utils"), exports);
__exportStar(require("./utilsv2"), exports);
const assert_1 = __importDefault(require("assert"));
const utils_1 = require("./utils");
const sinon_1 = __importDefault(require("sinon"));
exports.sinon = sinon_1.default;
class EngineTestUtilsV4 {
    static async setupWS(opts) {
        const wsRoot = (opts === null || opts === void 0 ? void 0 : opts.wsRoot) || common_server_1.tmpDir().name;
        const setupVaultsOpts = (opts === null || opts === void 0 ? void 0 : opts.setupVaultsOpts) ||
            ["vault1", "vault2"].map((ent) => ({
                vault: { fsPath: ent },
                preSetupHook: async ({ vpath, vault, wsRoot }) => {
                    const rootModule = common_all_1.SchemaUtilsV2.createRootModule({
                        created: "1",
                        updated: "1",
                        vault,
                    });
                    await common_server_1.schemaModuleOpts2File(rootModule, vpath, "root");
                    const rootNote = await common_all_1.NoteUtilsV2.createRoot({
                        created: "1",
                        updated: "1",
                        vault,
                    });
                    await common_server_1.note2File({ note: rootNote, vault, wsRoot });
                },
            }));
        const vaults = await Promise.all(setupVaultsOpts.flatMap((ent) => {
            return this.setupVault({ ...ent, wsRoot });
        }));
        return { wsRoot, vaults };
    }
    static async setupVault(opts) {
        const { wsRoot, vault } = opts;
        const vpath = common_server_1.resolvePath(vault.fsPath, wsRoot);
        fs_extra_1.default.ensureDirSync(vpath);
        if (opts.preSetupHook) {
            await opts.preSetupHook({ wsRoot, vault, vpath });
        }
        return opts.vault;
    }
}
exports.EngineTestUtilsV4 = EngineTestUtilsV4;
/**
 * Legacy Multi-vault setup
 */
class EngineTestUtilsV3 {
    static async setupWS(opts) {
        const wsRoot = common_server_1.tmpDir().name;
        const vaults = await this.setupVaults({ ...opts, wsRoot });
        return { wsRoot, vaults };
    }
    static async setupVaults(opts) {
        const { vaults } = lodash_1.default.defaults(opts, {
            vaults: [
                [common_server_1.tmpDir().name, "main"],
                [common_server_1.tmpDir().name, "other"],
            ].map(([vpath, vname]) => {
                return {
                    fsPath: path_1.default.relative(opts.wsRoot, vpath),
                    name: vname,
                };
            }),
        });
        //     {
        //       fsPath: tmpDir().name,
        //       name: "main",
        //     },
        //     {
        //       fsPath: tmpDir().name,
        //       name: "other",
        //     },
        //   ],
        // });
        const cb = [opts.initVault1, opts.initVault2];
        await Promise.all(vaults.map(async (ent, idx) => {
            const { fsPath } = ent;
            return EngineTestUtilsV2.setupVault({
                ...opts,
                vaultDir: path_1.default.join(opts.wsRoot, fsPath),
                initDirCb: cb[idx],
            });
        }));
        return vaults;
    }
}
exports.EngineTestUtilsV3 = EngineTestUtilsV3;
class EngineTestUtilsV2 {
    static async setupWS(opts) {
        const { initDirCb, withAssets, withGit } = lodash_1.default.defaults(opts, {
            withAssets: true,
            withGit: true,
        });
        let wsRoot = opts.wsRoot ? opts.wsRoot : common_server_1.tmpDir().name;
        let vaultDir = opts.vaultDir ? opts.vaultDir : path_1.default.join(wsRoot, "vault");
        await fs_extra_1.default.ensureDir(vaultDir);
        await EngineTestUtilsV2.setupVault({
            vaultDir,
            initDirCb,
            withAssets,
            withGit,
        });
        let vaults = [vaultDir];
        return {
            wsRoot,
            vaults,
        };
    }
    static async setupVault(opts) {
        const { withAssets, withGit } = opts;
        let vaultDir = opts.vaultDir ? opts.vaultDir : common_server_1.tmpDir().name;
        if (opts === null || opts === void 0 ? void 0 : opts.initDirCb) {
            await opts.initDirCb(vaultDir);
        }
        if (withAssets) {
            const assetsDir = path_1.default.join(vaultDir, "assets");
            await fs_extra_1.default.ensureDir(assetsDir);
            await fs_extra_1.default.ensureFile(path_1.default.join(assetsDir, "foo.jpg"));
        }
        if (withGit) {
            fs_extra_1.default.ensureDirSync(path_1.default.join(vaultDir, ".git"));
        }
        return vaultDir;
    }
}
exports.EngineTestUtilsV2 = EngineTestUtilsV2;
// === Legacy, deprecate
class NodeTestUtilsV2 {
    static normalizeNote({ note }) {
        return {
            ...lodash_1.default.omit(note, ["body", "parent", "id", "vault"]),
            body: lodash_1.default.trim(note.body),
        };
    }
    static normalizeNotes(notes) {
        if (!lodash_1.default.isArray(notes)) {
            notes = lodash_1.default.values(notes);
        }
        return notes.map((note) => {
            return NodeTestUtilsV2.normalizeNote({ note });
            //return { ..._.omit(note, ["body", "parent", "id"]), body: _.trim(note.body) };
        });
    }
}
exports.NodeTestUtilsV2 = NodeTestUtilsV2;
NodeTestUtilsV2.createNoteProps = async (opts) => {
    const { rootName, vaultPath, props } = opts;
    const vault = { fsPath: vaultPath };
    const foo = common_all_1.NoteUtilsV2.create({
        fname: `${rootName}`,
        id: `${rootName}`,
        created: "1",
        updated: "1",
        children: ["ch1"],
        ...props,
        vault,
    });
    const ch1 = common_all_1.NoteUtilsV2.create({
        fname: `${rootName}.ch1`,
        id: `${rootName}.ch1`,
        created: "1",
        updated: "1",
        vault,
        ...props,
    });
    await common_server_1.note2File({
        note: foo,
        vault: { fsPath: vaultPath },
        wsRoot: "fake_root",
    });
    await common_server_1.note2File({
        note: ch1,
        vault: { fsPath: vaultPath },
        wsRoot: "fake_root",
    });
    return { foo, ch1 };
};
NodeTestUtilsV2.createNote = async (opts) => {
    const cleanOpts = lodash_1.default.defaults(opts, {
        withBody: true,
        noteProps: [],
    });
    const defaultOpts = {
        created: "1",
        updated: "1",
    };
    const n = cleanOpts.noteProps;
    const body = cleanOpts.withBody ? n.fname + " body" : "";
    const vault = { fsPath: cleanOpts.vaultDir };
    const _n = common_all_1.NoteUtilsV2.create({ ...defaultOpts, body, ...n, vault });
    await common_server_1.note2File({
        note: _n,
        vault: { fsPath: cleanOpts.vaultDir },
        wsRoot: "fake_root",
    });
    return _n;
};
NodeTestUtilsV2.createNotes = async (opts) => {
    const cleanOpts = lodash_1.default.defaults(opts, {
        withBody: true,
        noteProps: [],
    });
    const vault = { fsPath: cleanOpts.vaultPath };
    const defaultOpts = {
        created: "1",
        updated: "1",
    };
    const rootNote = await common_all_1.NoteUtilsV2.createRoot({
        ...defaultOpts,
        vault,
    });
    const out = {
        root: rootNote,
    };
    await Promise.all(cleanOpts.noteProps.map(async (n) => {
        const body = cleanOpts.withBody ? n.fname + " body" : "";
        const _n = common_all_1.NoteUtilsV2.create({ ...defaultOpts, body, ...n, vault });
        common_all_1.DNodeUtilsV2.addChild(rootNote, _n);
        if (cleanOpts.vaultPath) {
            await common_server_1.note2File({
                note: _n,
                vault: { fsPath: cleanOpts.vaultPath },
                wsRoot: "fake_root",
            });
        }
        out[_n.id] = _n;
        return;
    }));
    await common_server_1.note2File({
        note: rootNote,
        vault: { fsPath: cleanOpts.vaultPath },
        wsRoot: "fake_root",
    });
    return out;
};
NodeTestUtilsV2.createSchema = async (opts) => {
    const { vaultDir, schemas, fname } = opts;
    const schema = common_all_1.SchemaUtilsV2.createModuleProps({
        fname,
        vault: { fsPath: vaultDir },
    });
    schemas.forEach((s) => {
        schema.schemas[s.id] = s;
    });
    await common_server_1.schemaModuleProps2File(schema, vaultDir, fname);
    return schema;
};
NodeTestUtilsV2.createSchemas = async (opts) => {
    const cleanOpts = lodash_1.default.defaults(opts, {
        schemaMO: [],
    });
    const { vaultPath, schemaMO } = cleanOpts;
    const vault = { fsPath: vaultPath };
    const rootModule = common_all_1.SchemaUtilsV2.createRootModule({
        created: "1",
        updated: "1",
        vault,
    });
    await common_server_1.schemaModuleOpts2File(rootModule, vaultPath, "root");
    await Promise.all(schemaMO.map(async (ent) => {
        const [module, fname] = ent;
        if (vaultPath) {
            await common_server_1.schemaModuleOpts2File(module, vaultPath, fname);
        }
    }));
};
NodeTestUtilsV2.createSchemaModuleOpts = async (opts) => {
    const { vaultDir, rootName, rootOpts } = opts;
    const vault = { fsPath: vaultDir };
    const schema = common_all_1.SchemaUtilsV2.create({
        fname: `${rootName}`,
        id: `${rootName}`,
        parent: "root",
        created: "1",
        updated: "1",
        children: ["ch1"],
        vault,
        ...rootOpts,
    });
    const ch1 = common_all_1.SchemaUtilsV2.create({
        fname: `${rootName}`,
        vault,
        id: "ch1",
        created: "1",
        updated: "1",
    });
    common_all_1.DNodeUtilsV2.addChild(schema, ch1);
    const schemaModuleProps = [
        [
            common_all_1.SchemaUtilsV2.createModule({
                version: 1,
                schemas: [schema, ch1],
            }),
            `${rootName}`,
        ],
    ];
    await Promise.all(schemaModuleProps.map((ent) => {
        const [module, fname] = ent;
        return common_server_1.schemaModuleOpts2File(module, vaultDir, fname);
    }));
    return schemaModuleProps[0][0];
};
class NodeTestPresetsV2 {
    static async runMochaHarness({ opts, results, }) {
        return lodash_1.default.map(await results(opts), (ent) => assert_1.default.deepStrictEqual(ent.actual, ent.expected));
    }
    static async runJestHarness({ opts, results, expect, }) {
        return lodash_1.default.map(await results(opts), (ent) => expect(ent.actual).toEqual(ent.expected));
    }
    static async createNoteRefPreset({ vaultDir }) {
        await NodeTestPresetsV2.createOneNoteOneSchemaPresetWithBody({ vaultDir });
        await NodeTestUtilsV2.createNote({
            vaultDir,
            noteProps: {
                body: "((ref: [[foo]]))",
                fname: "bar",
                vault: { fsPath: vaultDir },
            },
        });
    }
    static async createSchemaPreset({ vaultDir }) {
        const vault = { fsPath: vaultDir };
        await NodeTestPresetsV2.createOneNoteOneSchemaPreset({ vaultDir });
        await NodeTestUtilsV2.createSchema({
            vaultDir,
            schemas: [
                common_all_1.SchemaUtilsV2.create({
                    id: "bar",
                    parent: "root",
                    children: ["ch1", "ch2"],
                    vault,
                }),
                common_all_1.SchemaUtilsV2.create({
                    id: "ch1",
                    template: { id: "bar.template.ch1", type: "note" },
                    vault,
                }),
                common_all_1.SchemaUtilsV2.create({
                    id: "ch2",
                    template: { id: "bar.template.ch2", type: "note" },
                    namespace: true,
                    vault,
                }),
            ],
            fname: "bar",
        });
        await NodeTestUtilsV2.createNote({
            vaultDir,
            noteProps: { body: "ch1 template", fname: "bar.template.ch1", vault },
        });
        await NodeTestUtilsV2.createNote({
            vaultDir,
            noteProps: {
                body: "ch2 template",
                fname: "bar.template.ch2",
                vault,
            },
        });
    }
    static async createOneNoteOneSchemaPresetWithBody({ vaultDir, }) {
        await NodeTestUtilsV2.createSchemas({ vaultPath: vaultDir });
        await NodeTestUtilsV2.createNotes({
            vaultPath: vaultDir,
        });
        await NodeTestUtilsV2.createNoteProps({
            vaultPath: vaultDir,
            rootName: "foo",
            props: {
                body: "foo body",
            },
        });
        await NodeTestUtilsV2.createSchemaModuleOpts({
            vaultDir: vaultDir,
            rootName: "foo",
        });
    }
    static async createOneNoteOneSchemaPreset({ vaultDir, }) {
        await NodeTestUtilsV2.createSchemas({ vaultPath: vaultDir });
        await NodeTestUtilsV2.createNotes({ vaultPath: vaultDir });
        await NodeTestUtilsV2.createNoteProps({
            vaultPath: vaultDir,
            rootName: "foo",
        });
        await NodeTestUtilsV2.createSchemaModuleOpts({
            vaultDir: vaultDir,
            rootName: "foo",
        });
    }
}
exports.NodeTestPresetsV2 = NodeTestPresetsV2;
class NoteTestUtilsV3 {
}
exports.NoteTestUtilsV3 = NoteTestUtilsV3;
NoteTestUtilsV3.createNote = async (opts) => {
    const { fname, vault, props, body, genRandomId, noWrite } = lodash_1.default.defaults(opts, { noWrite: false });
    /**
     * Make sure snapshots stay consistent
     */
    const defaultOpts = {
        created: "1",
        updated: "1",
        id: genRandomId ? common_all_1.genUUID() : fname,
    };
    const note = common_all_1.NoteUtilsV2.create({
        ...defaultOpts,
        ...props,
        fname,
        vault,
        body,
    });
    if (!noWrite) {
        await common_server_1.note2File({ note, vault, wsRoot: "FAKE_ROOT" });
    }
    return note;
};
class NoteTestPresetsV2 {
    static async createJestTest({ executeCb, beforeArgs, expect, entry, }) {
        await entry.before(beforeArgs);
        const results = entry.results;
        const executeResp = await executeCb();
        await NodeTestPresetsV2.runJestHarness({
            opts: executeResp,
            results,
            expect,
        });
    }
    static async createDeleteNoteWNoChildrenResults({ changed, notes, vaultDir, }) {
        return [
            { actual: changed[0].note.id, expected: "foo" },
            { actual: lodash_1.default.size(notes), expected: 2 },
            { actual: notes["foo"].children, expected: [] },
            {
                actual: lodash_1.default.includes(fs_extra_1.default.readdirSync(vaultDir), "foo.ch1.md"),
                expected: false,
            },
        ];
    }
}
exports.NoteTestPresetsV2 = NoteTestPresetsV2;
NoteTestPresetsV2.presets = {
    OneNoteOneSchemaPreset: {
        init: {
            domainStub: new utils_1.TestPresetEntry({
                label: "domain stub",
                before: async ({ vaultDir }) => {
                    fs_extra_1.default.removeSync(path_1.default.join(vaultDir, "foo.md"));
                },
                results: async ({ notes }) => {
                    const note = common_all_1.NoteUtilsV2.getNoteByFname("foo", notes);
                    const vault = note.vault;
                    const root = common_all_1.NoteUtilsV2.getNoteByFname("root", notes, {
                        vault,
                    });
                    const scenarios = [
                        { actual: lodash_1.default.size(notes), expected: 3 },
                        { actual: root.children, expected: [note.id] },
                    ];
                    return scenarios;
                },
            }),
        },
        delete: {
            noteNoChildren: new utils_1.TestPresetEntry({
                label: "note w/no children",
                results: NoteTestPresetsV2.createDeleteNoteWNoChildrenResults,
            }),
            domainChildren: new utils_1.TestPresetEntry({
                label: "domain with children",
                results: async ({ changed, notes, vaultDir, }) => {
                    return [
                        {
                            actual: changed,
                            expected: [{ note: notes["foo"], status: "update" }],
                            msg: "note updated",
                        },
                        {
                            actual: lodash_1.default.size(notes),
                            expected: 3,
                            msg: "same number of notes",
                        },
                        {
                            actual: notes["foo"].stub,
                            expected: true,
                            msg: "foo should be a stub",
                        },
                        {
                            actual: lodash_1.default.includes(fs_extra_1.default.readdirSync(vaultDir), "foo.md"),
                            expected: false,
                            msg: "note should be deleted",
                        },
                    ];
                },
            }),
            domainNoChildren: new utils_1.TestPresetEntry({
                label: "domain w/no children",
                results: async ({ changed, notes, vaultDir, }) => {
                    return [
                        {
                            actual: changed[0].note.fname,
                            expected: "root",
                            msg: "root updated",
                        },
                        {
                            actual: changed[0].note.children,
                            expected: [],
                            msg: "root does not have children",
                        },
                        { actual: lodash_1.default.size(notes), expected: 1 },
                        { actual: notes["foo"], expected: undefined },
                        {
                            actual: lodash_1.default.includes(fs_extra_1.default.readdirSync(vaultDir), "foo.md"),
                            expected: false,
                        },
                    ];
                },
            }),
        },
        update: {
            noteNoChildren: new utils_1.TestPresetEntry({
                label: "update note, no children",
                results: async ({ notes, }) => {
                    return [
                        {
                            actual: lodash_1.default.pick(notes["foo.ch1"], "body"),
                            expected: { body: "new body" },
                            msg: "update body",
                        },
                    ];
                },
            }),
        },
        write: {
            domainStub: new utils_1.TestPresetEntry({
                label: "write child, parent stub",
                before: async ({ vaultDir }) => {
                    const note = common_all_1.NoteUtilsV2.create({
                        fname: "bar.ch1",
                        vault: { fsPath: vaultDir },
                    });
                    await common_server_1.note2File({
                        note,
                        vault: { fsPath: vaultDir },
                        wsRoot: "FAKE",
                    });
                },
                results: async ({ notes }) => {
                    const root = common_all_1.NoteUtilsV2.getNoteByFname("root", notes);
                    const bar = common_all_1.NoteUtilsV2.getNoteByFname("bar", notes);
                    const child = common_all_1.NoteUtilsV2.getNoteByFname("bar.ch1", notes);
                    return [
                        {
                            actual: lodash_1.default.size(root.children),
                            expected: 2,
                            msg: "root, foo, bar",
                        },
                        {
                            actual: lodash_1.default.pick(bar, "stub"),
                            expected: { stub: true },
                            msg: "bar created as stub",
                        },
                        {
                            actual: lodash_1.default.pick(child, ["fname", "stub"]),
                            expected: { fname: "bar.ch1" },
                            msg: "child is not stub",
                        },
                    ];
                },
            }),
            serializeChildWithHierarchy: new utils_1.TestPresetEntry({
                label: "write child, serialize with hierarchy",
                before: async ({ vaultDir }) => {
                    fs_extra_1.default.removeSync(path_1.default.join(vaultDir, "foo.ch1.md"));
                },
                results: async ({ vaultDir, }) => {
                    const rawNote = fs_extra_1.default.readFileSync(path_1.default.join(vaultDir, "foo.ch1.md"), {
                        encoding: "utf8",
                    });
                    return [
                        {
                            actual: rawNote.match(/^parent: foo/gm),
                            expected: ["parent: foo"],
                            msg: "should have parent",
                        },
                    ];
                },
            }),
        },
    },
};
//# sourceMappingURL=index.js.map