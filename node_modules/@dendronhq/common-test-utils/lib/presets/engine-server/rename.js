"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ENGINE_RENAME_PRESETS = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const __1 = require("../..");
const fileUtils_1 = require("../../fileUtils");
const utilsv2_1 = require("../../utilsv2");
const notes_1 = require("../notes");
const findCreated = (changed) => {
    const created = lodash_1.default.find(changed, { status: "create" });
    return created;
};
// const findUpdated = (changed: NoteChangeEntry[]) => {
//   const note = _.find(changed, { status: "update" });
//   return note;
// };
const NOTES = {
    NOTE_REF: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        var _a;
        const vault = vaults[0];
        const changed = await engine.renameNote({
            oldLoc: { fname: "foo", vault },
            newLoc: { fname: "baz", vault },
        });
        const checkVault = await fileUtils_1.FileTestUtils.assertInVault({
            wsRoot,
            vault,
            match: ["baz.md"],
            nomatch: ["foo.md"],
        });
        return [
            {
                actual: (_a = changed.data) === null || _a === void 0 ? void 0 : _a.length,
                expected: 3,
            },
            {
                actual: lodash_1.default.trim(changed.data[0].note.body),
                expected: "[[baz]]\n((ref: [[dendron.pro.dendron-next-server]]#quickstart,1:#*))",
            },
            {
                actual: checkVault,
                expected: true,
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            const vault = vaults[0];
            await notes_1.NOTE_PRESETS_V4.NOTE_SIMPLE.create({
                vault,
                wsRoot,
            });
            await notes_1.NOTE_PRESETS_V4.NOTE_SIMPLE.create({
                vault,
                wsRoot,
                fname: "bar",
                body: `[[foo]]\n${notes_1.NOTE_BODY_PRESETS_V4.NOTE_REF}`,
            });
        },
    }),
    DOMAIN_NO_CHILDREN: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        var _a;
        const vault = vaults[0];
        const alpha = notes_1.NOTE_PRESETS_V4.NOTE_WITH_LINK.fname;
        const changed = await engine.renameNote({
            oldLoc: { fname: alpha, vault },
            newLoc: { fname: "gamma", vault },
        });
        const checkVault = await fileUtils_1.FileTestUtils.assertInVault({
            wsRoot,
            vault,
            match: ["gamma.md"],
            nomatch: [`${alpha}.md`],
        });
        return [
            {
                actual: (_a = changed.data) === null || _a === void 0 ? void 0 : _a.length,
                expected: 3,
            },
            {
                actual: lodash_1.default.trim(changed.data[0].note.body),
                expected: "[[gamma]]",
            },
            {
                actual: checkVault,
                expected: true,
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            const vault = vaults[0];
            await notes_1.NOTE_PRESETS_V4.NOTE_WITH_TARGET.create({
                vault,
                wsRoot,
            });
            await notes_1.NOTE_PRESETS_V4.NOTE_WITH_LINK.create({
                vault,
                wsRoot,
            });
        },
    }),
    DOMAIN_DIFF_TITLE: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        var _a;
        const vault = vaults[0];
        const fnameOld = notes_1.NOTE_PRESETS_V4.NOTE_WITH_TARGET.fname;
        const changed = await engine.renameNote({
            oldLoc: { fname: fnameOld, vault },
            newLoc: { fname: "gamma", vault },
        });
        const createdChange = findCreated(changed.data);
        const checkVault = await fileUtils_1.FileTestUtils.assertInVault({
            wsRoot,
            vault,
            match: ["gamma.md"],
            nomatch: [`${fnameOld}.md`],
        });
        return [
            {
                actual: (_a = changed.data) === null || _a === void 0 ? void 0 : _a.length,
                expected: 3,
            },
            {
                actual: createdChange === null || createdChange === void 0 ? void 0 : createdChange.note.title,
                expected: "a title",
            },
            {
                actual: checkVault,
                expected: true,
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            const vault = vaults[0];
            await notes_1.NOTE_PRESETS_V4.NOTE_WITH_TARGET.create({
                vault,
                wsRoot,
                props: { title: "a title" },
            });
            await notes_1.NOTE_PRESETS_V4.NOTE_WITH_LINK.create({
                vault,
                wsRoot,
            });
        },
    }),
    LINK_AT_ROOT: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        var _a;
        const vault = vaults[0];
        const fnameOld = notes_1.NOTE_PRESETS_V4.NOTE_WITH_TARGET.fname;
        const changed = await engine.renameNote({
            oldLoc: { fname: fnameOld, vault },
            newLoc: { fname: "gamma", vault },
        });
        const checkVault = await fileUtils_1.FileTestUtils.assertInVault({
            wsRoot,
            vault,
            match: ["gamma.md"],
            nomatch: [`${fnameOld}.md`],
        });
        const changedNote = common_all_1.NoteUtilsV2.getNoteByFnameV4({
            fname: "root",
            notes: engine.notes,
            vault,
        });
        return [
            {
                actual: (_a = changed.data) === null || _a === void 0 ? void 0 : _a.length,
                expected: 3,
            },
            {
                actual: await __1.AssertUtils.assertInString({
                    body: changedNote === null || changedNote === void 0 ? void 0 : changedNote.body,
                    match: ["[[gamma]]"],
                }),
                expected: true,
            },
            {
                actual: checkVault,
                expected: true,
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            const vault = vaults[0];
            await notes_1.NOTE_PRESETS_V4.NOTE_WITH_TARGET.create({
                vault,
                wsRoot,
            });
            const vpath = common_server_1.vault2Path({ vault, wsRoot });
            const root = path_1.default.join(vpath, "root.md");
            fs_extra_1.default.appendFileSync(root, "[[alpha]]");
        },
    }),
    TARGET_IN_VAULT1_AND_LINK_IN_VAULT2: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        const fnameTarget = notes_1.NOTE_PRESETS_V4.NOTE_WITH_TARGET.fname;
        const fnameNew = "gamma";
        const fnameLink = notes_1.NOTE_PRESETS_V4.NOTE_WITH_LINK.fname;
        const resp = await engine.renameNote({
            oldLoc: { fname: fnameTarget, vault: vaults[0] },
            newLoc: { fname: fnameNew, vault: vaults[0] },
        });
        const changed = resp.data;
        const updated = lodash_1.default.map(changed, (ent) => ({
            status: ent.status,
            fname: ent.note.fname,
        })).sort();
        const checkVault1 = await fileUtils_1.FileTestUtils.assertInVault({
            vault: vaults[0],
            wsRoot,
            match: [fnameNew],
            nomatch: [fnameTarget],
        });
        const checkVault2 = await fileUtils_1.FileTestUtils.assertInVault({
            vault: vaults[1],
            wsRoot,
            match: [fnameLink],
            nomatch: [fnameTarget, fnameNew],
        });
        return [
            {
                actual: updated,
                expected: [
                    { status: "update", fname: fnameLink },
                    { status: "delete", fname: fnameTarget },
                    { status: "create", fname: fnameNew },
                ],
            },
            {
                actual: checkVault1,
                expected: true,
            },
            {
                actual: checkVault2,
                expected: true,
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            await notes_1.NOTE_PRESETS_V4.NOTE_WITH_TARGET.create({
                vault: vaults[0],
                wsRoot,
            });
            await notes_1.NOTE_PRESETS_V4.NOTE_WITH_LINK.create({
                vault: vaults[1],
                wsRoot,
            });
        },
    }),
    TARGET_IN_VAULT2_AND_LINK_IN_VAULT2: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        const fnameTarget = notes_1.NOTE_PRESETS_V4.NOTE_WITH_TARGET.fname;
        const fnameNew = "gamma";
        const fnameLink = notes_1.NOTE_PRESETS_V4.NOTE_WITH_LINK.fname;
        const resp = await engine.renameNote({
            oldLoc: { fname: fnameTarget, vault: vaults[1] },
            newLoc: { fname: fnameNew, vault: vaults[1] },
        });
        const changed = resp.data;
        const updated = lodash_1.default.map(changed, (ent) => ({
            status: ent.status,
            fname: ent.note.fname,
        })).sort();
        const checkVault1 = await fileUtils_1.FileTestUtils.assertInVault({
            vault: vaults[0],
            wsRoot,
            nomatch: [fnameLink, fnameNew],
        });
        const checkVault2 = await fileUtils_1.FileTestUtils.assertInVault({
            vault: vaults[1],
            wsRoot,
            match: [fnameLink, fnameNew],
            nomatch: [fnameTarget],
        });
        return [
            {
                actual: updated,
                expected: [
                    { status: "update", fname: "beta" },
                    { status: "delete", fname: "alpha" },
                    { status: "create", fname: "gamma" },
                ],
            },
            {
                actual: checkVault1,
                expected: true,
            },
            {
                actual: checkVault2,
                expected: true,
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            await notes_1.NOTE_PRESETS_V4.NOTE_WITH_TARGET.create({
                vault: vaults[1],
                wsRoot,
            });
            await notes_1.NOTE_PRESETS_V4.NOTE_WITH_LINK.create({
                vault: vaults[1],
                wsRoot,
            });
        },
    }),
    TARGET_IN_VAULT2_AND_LINK_IN_VAULT1: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        const fnameTarget = notes_1.NOTE_PRESETS_V4.NOTE_WITH_TARGET.fname;
        const fnameNew = "gamma";
        const fnameLink = notes_1.NOTE_PRESETS_V4.NOTE_WITH_LINK.fname;
        const resp = await engine.renameNote({
            oldLoc: { fname: fnameTarget, vault: vaults[1] },
            newLoc: { fname: fnameNew, vault: vaults[1] },
        });
        const changed = resp.data;
        const updated = lodash_1.default.map(changed, (ent) => ({
            status: ent.status,
            fname: ent.note.fname,
        })).sort();
        const checkVault1 = await fileUtils_1.FileTestUtils.assertInVault({
            vault: vaults[0],
            wsRoot,
            match: [fnameLink],
        });
        const checkVault2 = await fileUtils_1.FileTestUtils.assertInVault({
            vault: vaults[1],
            wsRoot,
            match: [fnameNew],
            nomatch: [fnameTarget],
        });
        return [
            {
                actual: updated,
                expected: [
                    { status: "update", fname: "beta" },
                    { status: "delete", fname: "alpha" },
                    { status: "create", fname: "gamma" },
                ],
            },
            {
                actual: checkVault1,
                expected: true,
            },
            {
                actual: checkVault2,
                expected: true,
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            await notes_1.NOTE_PRESETS_V4.NOTE_WITH_TARGET.create({
                vault: vaults[1],
                wsRoot,
            });
            await notes_1.NOTE_PRESETS_V4.NOTE_WITH_LINK.create({
                vault: vaults[0],
                wsRoot,
            });
        },
    }),
};
exports.ENGINE_RENAME_PRESETS = {
    NOTES,
    SCHEMAS: {},
};
//# sourceMappingURL=rename.js.map