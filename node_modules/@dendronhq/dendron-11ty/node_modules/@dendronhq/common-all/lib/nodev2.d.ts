import { URI } from "vscode-uri";
import { DEngineClientV2, DLink, DLoc, DNodeOptsV2, DNodePropsDictV2, DNodePropsQuickInputV2, DNodePropsV2, DNoteLoc, DVault, NoteOptsV2, NotePropsDictV2, NotePropsV2, SchemaModuleDictV2, SchemaModuleOptsV2, SchemaModulePropsV2, SchemaOptsV2, SchemaPropsDictV2, SchemaPropsV2, SchemaRawV2, SchemaTemplate } from "./typesv2";
export declare class DNodeUtilsV2 {
    static addChild(parent: DNodePropsV2, child: DNodePropsV2): void;
    static create(opts: DNodeOptsV2): DNodePropsV2;
    static basename(nodePath: string, rmExtension?: boolean): string;
    static dirName(nodePath: string): string;
    static domainName(nodePath: string): string;
    static fname(nodePath: string): string;
    static enhancePropForQuickInput({ props, schemas, vaults, }: {
        props: DNodePropsV2;
        schemas: SchemaModuleDictV2;
        vaults: DVault[];
    }): DNodePropsQuickInputV2;
    static findClosestParent(fpath: string, nodes: DNodePropsV2[], opts: {
        noStubs?: boolean;
        vault: DVault;
        wsRoot: string;
    }): DNodePropsV2;
    static getCustomProps(props: any): any;
    static getDepth(node: DNodePropsV2): number;
    static getDomain(node: DNodePropsV2, opts: {
        nodeDict: DNodePropsDictV2;
    }): DNodePropsV2;
    static getFullPath(opts: {
        wsRoot: string;
        vault: DVault;
        basename: string;
    }): string;
    static getParent(node: DNodePropsV2, opts: {
        nodeDict: DNodePropsDictV2;
    }): DNodePropsV2;
    static getChildren(node: DNodePropsV2, opts: {
        recursive?: boolean;
        nodeDict: DNodePropsDictV2;
    }): DNodePropsV2[];
    static getVaultByDir({ vaults, dirPath, }: {
        dirPath: string;
        vaults: DVault[];
    }): DVault;
    static isRoot(note: DNodePropsV2): boolean;
}
export declare class NoteUtilsV2 {
    static RE_FM: RegExp;
    static RE_FM_UPDATED: RegExp;
    static RE_FM_CREATED: RegExp;
    static addBacklink({ from, to, link, }: {
        from: NotePropsV2;
        to: NotePropsV2;
        link: DLink;
    }): void;
    /**
     * Add node to parent
     * Create stubs if no direct parent exists
     * @param opts
     * @returns All notes that were changed including the parent
     */
    static addParent(opts: {
        note: NotePropsV2;
        notesList: NotePropsV2[];
        createStubs: boolean;
        wsRoot: string;
    }): NotePropsV2[];
    static addSchema(opts: {
        note: NotePropsV2;
        schemaModule: SchemaModulePropsV2;
        schema: SchemaPropsV2;
    }): void;
    static create(opts: NoteOptsV2): NotePropsV2;
    static createWithSchema({ noteOpts, engine, }: {
        noteOpts: NoteOptsV2;
        engine: DEngineClientV2;
    }): NotePropsV2;
    static createRoot(opts: Partial<NoteOptsV2> & {
        vault: DVault;
    }): NotePropsV2;
    /**
     * Create stubs and add notes to parent
     * @param from
     * @param to
     */
    static createStubs(from: NotePropsV2, to: NotePropsV2): NotePropsV2[];
    static createWikiLink({ note, header, }: {
        note: NotePropsV2;
        header?: string;
    }): string;
    static fromSchema({ fname, schemaModule, schemaId, vault, }: {
        fname: string;
        schemaModule: SchemaModulePropsV2;
        schemaId: string;
        vault: DVault;
    }): DNodePropsV2<any, any>;
    static genSchemaDesc(note: NotePropsV2, schemaMod?: SchemaModulePropsV2): string;
    static genTitle(fname: string): string;
    static getNotesByFname({ fname, notes, vault, }: {
        fname: string;
        notes: NotePropsDictV2 | NotePropsV2[];
        vault?: DVault;
    }): NotePropsV2[];
    /**
     * Get a note.
     * If no vault is entered as a parameter, get first match
     */
    static getNoteByFnameV4({ fname, notes, vault, }: {
        fname: string;
        notes: NotePropsDictV2 | NotePropsV2[];
        vault: DVault;
    }): NotePropsV2 | undefined;
    static getNoteByFname(fname: string, notes: NotePropsDictV2, opts?: {
        throwIfEmpty?: boolean;
        vault?: DVault;
    }): NotePropsV2 | undefined;
    static getNotesWithLinkTo({ note, notes, }: {
        note: NotePropsV2;
        notes: NotePropsDictV2;
    }): NotePropsV2[];
    static getPathV4({ note, wsRoot, }: {
        note: NotePropsV2;
        wsRoot: string;
    }): string;
    static getURI({ note, wsRoot }: {
        note: NotePropsV2;
        wsRoot: string;
    }): URI;
    static getPathUpTo(hpath: string, numCompoenents: number): string;
    static getRoots(notes: NotePropsDictV2): NotePropsV2[];
    static hydrate({ noteRaw, noteHydrated, }: {
        noteRaw: NotePropsV2;
        noteHydrated: NotePropsV2;
    }): {
        parent: string | null;
        children: string[];
        id: string;
        title: string;
        desc: string;
        links: DLink[];
        fname: string;
        type: import("./typesv2").DNodeTypeV2;
        updated: string;
        created: string;
        stub?: boolean | undefined;
        schemaStub?: boolean | undefined;
        data: any;
        body: string;
        custom?: any;
        schema?: {
            moduleId: string;
            schemaId: string;
        } | undefined;
        vault: DVault;
    };
    static isDefaultTitle(props: NotePropsV2): boolean;
    static normalizeFname(nodePath: string): string;
    static serializeMeta(props: NotePropsV2): any;
    static serialize(props: NotePropsV2, opts?: {
        writeHierarchy?: boolean;
    }): string;
    static toLoc(note: NotePropsV2): DLoc;
    static toLogObj(note: NotePropsV2): {
        fname: string;
        id: string;
    };
    static toNoteLoc(note: NotePropsV2): DNoteLoc;
    static uri2Fname(uri: URI): string;
}
declare type SchemaMatchResult = {
    schemaModule: SchemaModulePropsV2;
    schema: SchemaPropsV2;
    namespace: boolean;
    notePath: string;
};
export declare class SchemaUtilsV2 {
    static applyTemplate(opts: {
        template: SchemaTemplate;
        note: NotePropsV2;
        engine: DEngineClientV2;
    }): boolean;
    static create(opts: (SchemaOptsV2 | SchemaRawV2) & {
        vault: DVault;
    }): SchemaPropsV2;
    static createModule(opts: SchemaModuleOptsV2): SchemaModuleOptsV2;
    static createModuleProps(opts: {
        fname: string;
        vault: DVault;
    }): SchemaModulePropsV2;
    static createRootModule(opts: Partial<SchemaPropsV2> & {
        vault: DVault;
    }): SchemaModuleOptsV2;
    static createRootModuleProps(fname: string, vault: DVault, opts?: Partial<SchemaPropsV2>): SchemaModulePropsV2;
    static enhanceForQuickInput({ props, vaults, }: {
        props: SchemaModulePropsV2;
        vaults: DVault[];
    }): DNodePropsQuickInputV2;
    static getModuleRoot(module: SchemaModuleOptsV2 | SchemaModulePropsV2): SchemaPropsV2;
    static getPattern: (schema: SchemaPropsV2, opts?: {
        isNotNamespace?: boolean | undefined;
    } | undefined) => string;
    static getPatternRecursive: (schema: SchemaPropsV2, schemas: SchemaPropsDictV2) => string;
    static getPath({ root, fname }: {
        root: string;
        fname: string;
    }): string;
    static getSchemaModuleByFnameV4({ fname, schemas, vault, }: {
        fname: string;
        schemas: SchemaModuleDictV2 | SchemaModulePropsV2[];
        vault: DVault;
    }): SchemaModulePropsV2 | undefined;
    static getSchemaFromNote({ note, engine, }: {
        note: NotePropsV2;
        engine: DEngineClientV2;
    }): SchemaModulePropsV2 | undefined;
    static hasSimplePattern: (schema: SchemaPropsV2, opts?: {
        isNotNamespace?: boolean | undefined;
    } | undefined) => boolean;
    /**
     * Matcn and assign schemas to all nodes within
     * a domain
     *
     * @param domain
     * @param notes
     * @param schemas
     */
    static matchDomain(domain: NotePropsV2, notes: NotePropsDictV2, schemas: SchemaModuleDictV2): void;
    static matchDomainWithSchema(opts: {
        noteCandidates: NotePropsV2[];
        notes: NotePropsDictV2;
        schemaCandidates: SchemaPropsV2[];
        schemaModule: SchemaModulePropsV2;
        matchNamespace?: boolean;
    }): void;
    static matchPath(opts: {
        notePath: string;
        schemaModDict: SchemaModuleDictV2;
    }): SchemaMatchResult | undefined;
    /**
     *
     * @param param0
     * @return
     *  - schemaModule
     *  - schema
     *  - namespace
     *  - notePath
     */
    static matchPathWithSchema({ notePath, matched, schemaCandidates, schemaModule, matchNamespace, }: {
        notePath: string;
        matched: string;
        schemaCandidates: SchemaPropsV2[];
        schemaModule: SchemaModulePropsV2;
        matchNamespace?: boolean;
    }): SchemaMatchResult | undefined;
    static matchNotePathWithSchemaAtLevel({ notePath, schemas, schemaModule, matchNamespace, }: {
        notePath: string;
        schemas: SchemaPropsV2[];
        schemaModule: SchemaModulePropsV2;
        matchNamespace?: boolean;
    }): SchemaMatchResult | undefined;
    static serializeSchemaProps(props: SchemaPropsV2 | SchemaOptsV2): SchemaRawV2;
    static serializeModuleProps(moduleProps: SchemaModulePropsV2): string;
    static serializeModuleOpts(moduleOpts: SchemaModuleOptsV2): string;
}
export {};
