"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_all_1 = require("@dendronhq/common-all");
const common_test_utils_1 = require("@dendronhq/common-test-utils");
const os_1 = require("os");
const path_1 = __importDefault(require("path"));
const enginev2_1 = require("../enginev2");
const preSetupHook = async ({ vaults, wsRoot }) => {
    await common_test_utils_1.NoteTestUtilsV4.createNote({ fname: "foo", vault: vaults[0], wsRoot });
    await common_test_utils_1.NoteTestUtilsV4.createSchema({
        fname: "foo",
        vault: vaults[0],
        wsRoot,
        modifier: (schema) => {
            schema.schemas["ch1"] = common_all_1.SchemaUtilsV2.create({
                id: "ch1",
                vault: vaults[0],
            });
            return schema;
        },
    });
};
describe("note", () => {
    const vault = { fsPath: os_1.tmpdir() };
    describe("getNoteByFnameV4", async () => {
        test("basic", async () => {
            await common_test_utils_1.runEngineTestV4(async ({ vaults, engine }) => {
                const fname = "foo";
                const resp = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                    fname,
                    notes: engine.notes,
                    vault: vaults[0],
                });
                expect(resp).toEqual(engine.notes["foo"]);
                return [];
            }, {
                expect,
                createEngine: enginev2_1.createEngine,
                preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupBasic,
            });
        });
        test("full path on input", async () => {
            await common_test_utils_1.runEngineTestV4(async ({ vaults, engine, wsRoot }) => {
                const fname = "foo";
                const resp = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                    fname,
                    notes: engine.notes,
                    vault: { fsPath: path_1.default.join(wsRoot, vaults[0].fsPath) },
                });
                expect(resp).toEqual(engine.notes["foo"]);
                return [];
            }, {
                expect,
                createEngine: enginev2_1.createEngine,
                preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupBasic,
            });
        });
        test("full path on node", async () => {
            await common_test_utils_1.runEngineTestV4(async ({ vaults, engine, wsRoot }) => {
                const fname = "foo";
                const resp = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                    fname,
                    notes: engine.notes,
                    vault: { fsPath: path_1.default.join(wsRoot, vaults[0].fsPath) },
                });
                expect(resp).toEqual(engine.notes["foo"]);
                return [];
            }, {
                expect,
                createEngine: enginev2_1.createEngine,
                preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupBasic,
            });
        });
    });
    describe("serialize", () => {
        test("basic", () => {
            const note = common_all_1.NoteUtilsV2.create({
                id: "foo",
                fname: "foo",
                created: "1",
                updated: "1",
                vault,
            });
            const serialized = common_all_1.NoteUtilsV2.serialize(note);
            expect(serialized).toMatchSnapshot();
            expect(serialized.indexOf("stub") >= 0).toBeFalsy();
        });
        test("with children", () => {
            const note = common_all_1.NoteUtilsV2.create({
                id: "foo",
                fname: "foo",
                created: "1",
                updated: "1",
                children: ["ch1", "ch2"],
                vault,
            });
            const serialized = common_all_1.NoteUtilsV2.serialize(note);
            expect(serialized).toMatchSnapshot();
        });
        test("with parent", () => {
            const note = common_all_1.NoteUtilsV2.create({
                id: "foo",
                fname: "foo",
                created: "1",
                updated: "1",
                parent: "root",
                vault,
            });
            const serialized = common_all_1.NoteUtilsV2.serialize(note);
            expect(serialized).toMatchSnapshot();
        });
        test("with custom", () => {
            const note = common_all_1.NoteUtilsV2.create({
                id: "foo",
                fname: "foo",
                created: "1",
                updated: "1",
                custom: {
                    bond: 42,
                },
                vault,
            });
            const serialized = common_all_1.NoteUtilsV2.serialize(note);
            expect(serialized).toMatchSnapshot();
            // should be at beginning of line
            expect(serialized.match(/^bond/gm)).toBeTruthy();
        });
        test("with hierarchy", () => {
            const note = common_all_1.NoteUtilsV2.create({
                id: "foo",
                fname: "foo",
                created: "1",
                updated: "1",
                children: ["ch1", "ch2"],
                parent: "root",
                vault,
            });
            const serialized = common_all_1.NoteUtilsV2.serialize(note, { writeHierarchy: true });
            expect(serialized).toMatchSnapshot();
            expect(serialized.match(/^parent: root/gm)).toBeTruthy();
            expect(serialized.match(/ch1/gm)).toBeTruthy();
            expect(serialized.match(/ch2/gm)).toBeTruthy();
        });
        test("with hierarchy and null parent", () => {
            const note = common_all_1.NoteUtilsV2.create({
                id: "foo",
                fname: "foo",
                created: "1",
                updated: "1",
                children: ["ch1", "ch2"],
                parent: null,
                vault,
            });
            const serialized = common_all_1.NoteUtilsV2.serialize(note, { writeHierarchy: true });
            expect(serialized).toMatchSnapshot();
            expect(serialized.match(/^parent: null/gm)).toBeTruthy();
            expect(serialized.match(/ch1/gm)).toBeTruthy();
            expect(serialized.match(/ch2/gm)).toBeTruthy();
        });
    });
});
describe("matchPath", () => {
    it("match path on domain, reg", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine }) => {
            const resp = common_all_1.SchemaUtilsV2.matchPath({
                notePath: "foo",
                schemaModDict: engine.schemas,
            });
            expect(resp === null || resp === void 0 ? void 0 : resp.schema.id).toEqual("foo");
            return [];
        }, { createEngine: enginev2_1.createEngine, preSetupHook, expect });
    });
    it("match path on domain as namespace", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine }) => {
            const resp = common_all_1.SchemaUtilsV2.matchPath({
                notePath: "bond",
                schemaModDict: engine.schemas,
            });
            expect(resp === null || resp === void 0 ? void 0 : resp.schema.id).toEqual("bond");
            expect(resp === null || resp === void 0 ? void 0 : resp.namespace).toBeTruthy();
            return [];
        }, {
            expect,
            createEngine: enginev2_1.createEngine,
            preSetupHook: async ({ vaults, wsRoot }) => {
                await common_test_utils_1.NoteTestUtilsV4.createSchema({
                    fname: "bond",
                    vault: vaults[0],
                    wsRoot,
                    modifier: (schema) => {
                        schema.schemas[schema.root.id].data.namespace = true;
                        return schema;
                    },
                });
            },
        });
    });
    it("match path on domain as namespace, child", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine }) => {
            const resp = common_all_1.SchemaUtilsV2.matchPath({
                notePath: "bond.foo",
                schemaModDict: engine.schemas,
            });
            expect(resp === null || resp === void 0 ? void 0 : resp.schema.id).toEqual("bond");
            expect(resp === null || resp === void 0 ? void 0 : resp.namespace).toBeFalsy();
            return [];
        }, {
            expect,
            createEngine: enginev2_1.createEngine,
            preSetupHook: async ({ vaults, wsRoot }) => {
                await common_test_utils_1.NoteTestUtilsV4.createSchema({
                    fname: "bond",
                    vault: vaults[0],
                    wsRoot,
                    modifier: (schema) => {
                        schema.schemas[schema.root.id].data.namespace = true;
                        return schema;
                    },
                });
            },
        });
    });
});
describe("matchDomain", () => {
    it("match path on domain, reg", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine }) => {
            const schema = engine.notes["foo"].schema;
            expect(schema).toEqual({ moduleId: "foo", schemaId: "foo" });
            return [];
        }, {
            expect,
            createEngine: enginev2_1.createEngine,
            preSetupHook: async ({ vaults, wsRoot }) => {
                await common_test_utils_1.NoteTestUtilsV4.createNote({
                    fname: "foo",
                    vault: vaults[0],
                    wsRoot,
                });
                await common_test_utils_1.NoteTestUtilsV4.createSchema({
                    fname: "foo",
                    vault: vaults[0],
                    wsRoot,
                });
            },
        });
    });
    it("match path on domain as namespace", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine }) => {
            const schema = engine.notes["bond"].schema;
            expect(schema).toEqual({ moduleId: "bond", schemaId: "bond" });
            return [];
        }, {
            expect,
            createEngine: enginev2_1.createEngine,
            preSetupHook: async ({ vaults, wsRoot }) => {
                await common_test_utils_1.NoteTestUtilsV4.createNote({
                    fname: "bond",
                    vault: vaults[0],
                    wsRoot,
                });
                await common_test_utils_1.NoteTestUtilsV4.createSchema({
                    fname: "bond",
                    vault: vaults[0],
                    wsRoot,
                    modifier: (schema) => {
                        schema.schemas[schema.root.id].data.namespace = true;
                        return schema;
                    },
                });
            },
        });
    });
    it("match path on domain as namespace", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine }) => {
            const schema = engine.notes["bond.ch1"].schema;
            expect(schema).toEqual({ moduleId: "bond", schemaId: "bond" });
            return [];
        }, {
            expect,
            createEngine: enginev2_1.createEngine,
            preSetupHook: async ({ vaults, wsRoot }) => {
                await common_test_utils_1.NoteTestUtilsV4.createNote({
                    fname: "bond.ch1",
                    vault: vaults[0],
                    wsRoot,
                });
                await common_test_utils_1.NoteTestUtilsV4.createSchema({
                    fname: "bond",
                    vault: vaults[0],
                    wsRoot,
                    modifier: (schema) => {
                        schema.schemas[schema.root.id].data.namespace = true;
                        return schema;
                    },
                });
            },
        });
    });
});
//# sourceMappingURL=nodev2.spec.js.map