"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkUtils = exports.getNoteOrError = exports.addError = exports.ALIAS_DIVIDER = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
exports.ALIAS_DIVIDER = "|";
function addError(proc, err) {
    const errors = proc.data("errors");
    errors.push(err);
    proc().data("errors", errors);
}
exports.addError = addError;
function getNoteOrError(notes, hint) {
    let error;
    let note;
    if (lodash_1.default.isUndefined(notes)) {
        error = new common_all_1.DendronError({ msg: `no note found. ${hint}` });
        return { error, note };
    }
    if (notes.length > 1) {
        error = new common_all_1.DendronError({ msg: `multiple notes found for link: ${hint}` });
        return { error, note };
    }
    if (notes.length < 1) {
        error = new common_all_1.DendronError({
            msg: `no notes found for link: ${JSON.stringify(hint)}`,
        });
        return { error, note };
    }
    note = notes[0];
    return { error, note };
}
exports.getNoteOrError = getNoteOrError;
class LinkUtils {
    static isAlias(link) {
        return link.indexOf("|") !== -1;
    }
    static parseAliasLink(link) {
        const [alias, value] = link.split("|").map(lodash_1.default.trim);
        return { alias, value: common_all_1.NoteUtilsV2.normalizeFname(value) };
    }
    static parseLink(linkMatch) {
        linkMatch = common_all_1.NoteUtilsV2.normalizeFname(linkMatch);
        let out = {
            value: linkMatch,
            alias: linkMatch,
        };
        if (LinkUtils.isAlias(linkMatch)) {
            out = LinkUtils.parseAliasLink(linkMatch);
        }
        if (out.value.indexOf("#") !== -1) {
            const [value, anchorHeader] = out.value.split("#").map(lodash_1.default.trim);
            out.value = value;
            out.anchorHeader = anchorHeader;
            // if we didn't have an alias, links with a # anchor shouldn't have # portion be in the title
            if (!LinkUtils.isAlias(linkMatch)) {
                out.alias = value;
            }
        }
        return out;
    }
}
exports.LinkUtils = LinkUtils;
//# sourceMappingURL=utils.js.map