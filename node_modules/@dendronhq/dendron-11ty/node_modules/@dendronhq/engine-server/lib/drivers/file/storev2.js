"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStorageV2 = exports.SchemaParserV2 = exports.NoteParserV2 = exports.ParserBaseV2 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const yamljs_1 = __importDefault(require("yamljs"));
const utilsv2_1 = require("../../topics/markdown/utilsv2");
const utils_1 = require("../../utils");
function getFileMetaV2(fpaths) {
    const metaDict = {};
    lodash_1.default.forEach(fpaths, (fpath) => {
        const { name } = path_1.default.parse(fpath);
        const lvl = name.split(".").length;
        if (!lodash_1.default.has(metaDict, lvl)) {
            metaDict[lvl] = [];
        }
        metaDict[lvl].push({ prefix: name, fpath });
    });
    return metaDict;
}
class ParserBaseV2 {
    constructor(opts) {
        this.opts = opts;
    }
    get logger() {
        return this.opts.logger;
    }
}
exports.ParserBaseV2 = ParserBaseV2;
class NoteParserV2 extends ParserBaseV2 {
    constructor(opts) {
        super(opts);
        this.opts = opts;
        this.cache = opts.cache;
    }
    async parseFile(fpath, vault) {
        const ctx = "parseFile";
        const fileMetaDict = getFileMetaV2(fpath);
        const maxLvl = lodash_1.default.max(lodash_1.default.keys(fileMetaDict).map((e) => lodash_1.default.toInteger(e))) || 2;
        const notesByFname = {};
        const notesById = {};
        this.logger.debug({ ctx, msg: "enter", fpath });
        // get root note
        if (lodash_1.default.isUndefined(fileMetaDict[1])) {
            throw new common_all_1.DendronError({ status: common_all_1.ENGINE_ERROR_CODES.NO_ROOT_NOTE_FOUND });
        }
        const rootFile = fileMetaDict[1].find((n) => n.fpath === "root.md");
        if (!rootFile) {
            throw new common_all_1.DendronError({ status: common_all_1.ENGINE_ERROR_CODES.NO_ROOT_NOTE_FOUND });
        }
        const rootNote = this.parseNoteProps({
            fileMeta: rootFile,
            addParent: false,
            vault,
        })[0];
        this.logger.debug({ ctx, rootNote, msg: "post-parse-rootNote" });
        notesByFname[rootNote.fname] = rootNote;
        notesById[rootNote.id] = rootNote;
        // get root of hiearchies
        let lvl = 2;
        let prevNodes = fileMetaDict[1]
            // don't count root node
            .filter((n) => n.fpath !== "root.md")
            .flatMap((ent) => {
            const notes = this.parseNoteProps({
                fileMeta: ent,
                addParent: false,
                vault,
            });
            return notes;
        });
        prevNodes.forEach((ent) => {
            common_all_1.DNodeUtilsV2.addChild(rootNote, ent);
            notesByFname[ent.fname] = ent;
            notesById[ent.id] = ent;
        });
        // get everything else
        while (lvl <= maxLvl) {
            const currNodes = (fileMetaDict[lvl] || [])
                .filter((ent) => {
                return !common_server_1.globMatch(["root.*"], ent.fpath);
            })
                .flatMap((ent) => {
                const node = this.parseNoteProps({
                    fileMeta: ent,
                    parents: prevNodes,
                    notesByFname,
                    addParent: true,
                    vault,
                });
                // need to be inside this loop
                // deal with `src/__tests__/enginev2.spec.ts`, with stubs/ test case
                node.forEach((ent) => {
                    notesByFname[ent.fname] = ent;
                    notesById[ent.id] = ent;
                });
                return node;
            });
            lvl += 1;
            prevNodes = currNodes;
        }
        // add schemas
        const out = lodash_1.default.values(notesByFname);
        const domains = rootNote.children.map((ent) => notesById[ent]);
        const schemas = this.opts.store.schemas;
        await Promise.all(domains.map(async (d) => {
            return common_all_1.SchemaUtilsV2.matchDomain(d, notesById, schemas);
        }));
        return out;
    }
    parseNoteProps(opts) {
        const cleanOpts = lodash_1.default.defaults(opts, {
            addParent: true,
            createStubs: true,
            notesByFname: {},
            parents: [],
        });
        const { fileMeta, parents, notesByFname, vault } = cleanOpts;
        const ctx = "parseNoteProps";
        this.logger.debug({ ctx, msg: "enter", fileMeta });
        const wsRoot = this.opts.store.wsRoot;
        const vpath = common_server_1.vault2Path({ vault, wsRoot });
        let out = [];
        let noteProps;
        // get note props
        try {
            noteProps = common_server_1.file2Note(path_1.default.join(vpath, fileMeta.fpath), vault);
        }
        catch (_err) {
            const err = {
                status: common_all_1.ENGINE_ERROR_CODES.BAD_PARSE_FOR_NOTE,
                msg: JSON.stringify({
                    fname: fileMeta.fpath,
                    error: _err.message,
                }),
            };
            this.logger.error({ ctx, fileMeta, err });
            throw new common_all_1.DendronError(err);
        }
        // add parent
        if (cleanOpts.addParent) {
            const stubs = common_all_1.NoteUtilsV2.addParent({
                note: noteProps,
                notesList: lodash_1.default.uniqBy(lodash_1.default.values(notesByFname).concat(parents), "id"),
                createStubs: cleanOpts.createStubs,
                wsRoot: this.opts.store.wsRoot,
            });
            out = out.concat(stubs);
        }
        out.push(noteProps);
        return out;
    }
    async parse(fpaths, vault) {
        return this.parseFile(fpaths, vault);
    }
}
exports.NoteParserV2 = NoteParserV2;
class SchemaParserV2 extends ParserBaseV2 {
    parseFile(fpath, root) {
        const fname = path_1.default.basename(fpath, ".schema.yml");
        const wsRoot = this.opts.store.wsRoot;
        const vpath = common_server_1.vault2Path({ vault: root, wsRoot });
        const schemaOpts = yamljs_1.default.parse(fs_extra_1.default.readFileSync(path_1.default.join(vpath, fpath), "utf8"));
        return common_server_1.SchemaParserV2.parseRaw(schemaOpts, { root, fname });
    }
    async parse(fpaths, vault) {
        const ctx = "parse";
        this.logger.info({ ctx, msg: "enter", fpaths, vault });
        const out = await Promise.all(fpaths.flatMap((fpath) => {
            try {
                return this.parseFile(fpath, vault);
            }
            catch (err) {
                return new common_all_1.DendronError({
                    msg: common_all_1.ENGINE_ERROR_CODES.BAD_PARSE_FOR_SCHEMA,
                    payload: { fpath },
                });
            }
        }));
        let errors = lodash_1.default.filter(out, (ent) => ent instanceof common_all_1.DendronError);
        return {
            schemas: lodash_1.default.reject(out, (ent) => ent instanceof common_all_1.DendronError),
            errors: lodash_1.default.isEmpty(errors) ? null : errors,
        };
    }
}
exports.SchemaParserV2 = SchemaParserV2;
// type NoteEntryV2 = {
//   mtime: number;
//   size: number;
//   hash: number;
// };
// type MetaEntryV2 = {
//   links: any[];
//   embeds: any[];
//   tags: any[];
//   headings: any[];
// };
class FileStorageV2 {
    constructor(props) {
        const { vaultsv3, logger, wsRoot } = props;
        this.wsRoot = wsRoot;
        this.configRoot = wsRoot;
        this.vaultsv3 = vaultsv3;
        this.vaults = vaultsv3.map((ent) => ent.fsPath);
        this.notes = {};
        this.schemas = {};
        this.notesCache = {};
        this.links = [];
        this.logger = logger;
        const ctx = "FileStorageV2";
        this.logger.info({ ctx, wsRoot, vaultsv3 });
    }
    async init() {
        try {
            let error = null;
            const resp = await this.initSchema();
            if (!lodash_1.default.isNull(resp.error)) {
                error = new common_all_1.DendronError({
                    code: common_all_1.ERROR_CODES.MINOR,
                    payload: { schema: resp.error },
                });
            }
            resp.data.map((ent) => {
                this.schemas[ent.root.id] = ent;
            });
            const _notes = await this.initNotes();
            _notes.map((ent) => {
                this.notes[ent.id] = ent;
            });
            // FIXME: for testing
            // const _notes = await fs.readJSON("/tmp/notes.json") as NotePropsDictV2;
            // this.notes = _notes;
            const { notes, schemas } = this;
            return { data: { notes, schemas }, error };
        }
        catch (err) {
            this.logger.error(err);
            throw err;
        }
    }
    async deleteNote(id, opts) {
        const ctx = "deleteNote";
        if (id === "root") {
            throw new common_all_1.DendronError({ status: common_all_1.ENGINE_ERROR_CODES.CANT_DELETE_ROOT });
        }
        const noteToDelete = this.notes[id];
        const ext = ".md";
        const vault = noteToDelete.vault;
        const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
        const fpath = path_1.default.join(vpath, noteToDelete.fname + ext);
        const out = [];
        this.logger.info({ ctx, noteToDelete, opts });
        // remove from fs
        if (!(opts === null || opts === void 0 ? void 0 : opts.metaOnly)) {
            this.logger.info({ ctx, noteToDelete, msg: "removing from disk", fpath });
            fs_extra_1.default.unlinkSync(fpath);
        }
        // if have children, keep this node around as a stub
        if (!lodash_1.default.isEmpty(noteToDelete.children)) {
            this.logger.info({ ctx, noteToDelete, msg: "keep as stub" });
            noteToDelete.stub = true;
            this.updateNote(noteToDelete);
            out.push({ note: noteToDelete, status: "update" });
        }
        else {
            this.logger.info({ ctx, noteToDelete, msg: "delete from parent" });
            if (!noteToDelete.parent) {
                throw new common_all_1.DendronError({
                    status: common_all_1.ENGINE_ERROR_CODES.NO_PARENT_FOR_NOTE,
                });
            }
            // no more children, delete from parent
            const parentNote = this.notes[noteToDelete.parent];
            parentNote.children = lodash_1.default.reject(parentNote.children, (ent) => ent === noteToDelete.id);
            delete this.notes[noteToDelete.id];
            out.push({ note: parentNote, status: "update" });
            out.push({ note: noteToDelete, status: "delete" });
        }
        return out;
    }
    async deleteSchema(id, opts) {
        const ctx = "deleteSchema";
        this.logger.info({ ctx, msg: "enter", id });
        if (id === "root") {
            throw new common_all_1.DendronError({ status: common_all_1.ENGINE_ERROR_CODES.CANT_DELETE_ROOT });
        }
        const schemaToDelete = this.schemas[id];
        const ext = ".schema.yml";
        const vault = schemaToDelete.vault;
        const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
        const fpath = path_1.default.join(vpath, schemaToDelete.fname + ext);
        if (!(opts === null || opts === void 0 ? void 0 : opts.metaOnly)) {
            fs_extra_1.default.unlinkSync(fpath);
        }
        delete this.schemas[id];
        return this.init();
    }
    loadNotesCache() {
        return {};
    }
    async initSchema() {
        const ctx = "initSchema";
        this.logger.info({ ctx, msg: "enter" });
        const out = await Promise.all(this.vaultsv3.map(async (vault) => {
            return this._initSchema(vault);
        }));
        const _out = lodash_1.default.reduce(out, (ent, acc) => {
            acc.data = acc.data.concat(ent.data);
            acc.errors = acc.errors.concat(ent.errors);
            return acc;
        }, { data: [], errors: [] });
        const { data, errors } = _out;
        return {
            data,
            error: lodash_1.default.isEmpty(errors)
                ? null
                : new common_all_1.DendronError({ msg: "multiple errors", payload: errors }),
        };
    }
    async _initSchema(vault) {
        const ctx = "initSchema";
        this.logger.info({ ctx, msg: "enter" });
        const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
        const schemaFiles = common_server_1.getAllFiles({
            root: vpath,
            include: ["*.schema.yml"],
        });
        this.logger.info({ ctx, schemaFiles });
        if (lodash_1.default.isEmpty(schemaFiles)) {
            throw new common_all_1.DendronError({ status: common_all_1.ENGINE_ERROR_CODES.NO_SCHEMA_FOUND });
        }
        const { schemas, errors } = await new SchemaParserV2({
            store: this,
            logger: this.logger,
        }).parse(schemaFiles, vault);
        return {
            data: schemas,
            errors: lodash_1.default.isNull(errors) ? [] : errors,
        };
    }
    async initNotes() {
        const ctx = "initNotes";
        this.logger.info({ ctx, msg: "enter" });
        let notesWithLinks = [];
        const out = await Promise.all(this.vaultsv3.map(async (vault) => {
            const notes = await this._initNotes(vault);
            notesWithLinks = notesWithLinks.concat(lodash_1.default.filter(notes, (n) => !lodash_1.default.isEmpty(n.links)));
            return notes;
        }));
        const allNotes = lodash_1.default.flatten(out);
        // await this._addBacklinks({ notesWithLinks, allNotes });
        return allNotes;
    }
    async _addBacklinks({ notesWithLinks, allNotes, }) {
        return lodash_1.default.map(notesWithLinks, async (noteFrom) => {
            return Promise.all(noteFrom.links.map(async (link) => {
                var _a;
                const fname = (_a = link.to) === null || _a === void 0 ? void 0 : _a.fname;
                if (fname) {
                    const notes = common_all_1.NoteUtilsV2.getNotesByFname({
                        fname,
                        notes: allNotes,
                    });
                    return notes.map((noteTo) => {
                        return common_all_1.NoteUtilsV2.addBacklink({
                            from: noteFrom,
                            to: noteTo,
                            link,
                        });
                    });
                }
                return;
            }));
        });
    }
    async _initNotes(vault) {
        const ctx = "initNotes";
        this.logger.info({ ctx, msg: "enter" });
        const wsRoot = this.wsRoot;
        const vpath = common_server_1.vault2Path({ vault, wsRoot });
        const noteFiles = common_server_1.getAllFiles({
            root: vpath,
            include: ["*.md"],
        });
        const cache = this.loadNotesCache();
        const notes = await new NoteParserV2({
            store: this,
            cache,
            logger: this.logger,
        }).parse(noteFiles, vault);
        await Promise.all(notes.map(async (n) => {
            if (n.stub) {
                return;
            }
            const links = utilsv2_1.ParserUtilsV2.findLinks({ note: n });
            n.links = links;
            return;
        }));
        return notes;
    }
    async bulkAddNotes(opts) {
        return Promise.all(opts.notes.map(async (note) => {
            await common_server_1.note2File({
                note,
                vault: note.vault,
                wsRoot: this.wsRoot,
            });
        }));
    }
    async renameNote(opts) {
        const ctx = "Store:renameNote";
        const { oldLoc, newLoc } = opts;
        const { wsRoot } = this;
        this.logger.info({ ctx, msg: "enter", opts });
        const oldVault = oldLoc.vault;
        const oldLocPath = utils_1.loc2Path({ loc: oldLoc, wsRoot });
        if (!oldVault) {
            throw new common_all_1.DendronError({ msg: "vault not set for loation" });
        }
        // read from disk since contents migh have changed
        const noteRaw = common_server_1.file2Note(oldLocPath, oldVault);
        const oldNote = common_all_1.NoteUtilsV2.hydrate({
            noteRaw,
            noteHydrated: this.notes[noteRaw.id],
        });
        const notesToChange = await common_all_1.NoteUtilsV2.getNotesWithLinkTo({
            note: oldNote,
            notes: this.notes,
        });
        // update note body of all notes that have changed
        const notesChanged = await Promise.all(notesToChange.map(async (n) => {
            const vault = n.vault;
            const vaultPath = common_server_1.vault2Path({ vault, wsRoot });
            // read note in case its changed
            const _n = common_server_1.file2Note(path_1.default.join(vaultPath, n.fname + ".md"), vault);
            n.body = await utilsv2_1.ParserUtilsV2.replaceLinks({
                content: _n.body,
                from: oldLoc,
                to: newLoc,
            });
            return n;
        }));
        const newNote = {
            ...oldNote,
            fname: newLoc.fname,
            title: common_all_1.NoteUtilsV2.isDefaultTitle(oldNote)
                ? common_all_1.NoteUtilsV2.genTitle(newLoc.fname)
                : oldNote.title,
        };
        // NOTE: order matters. need to delete old note, otherwise can't write new note
        await this.deleteNote(oldNote.id, { metaOnly: true });
        await this.writeNote(newNote, { newNode: true });
        // update all new notes
        await Promise.all(notesChanged.map(async (n) => this.writeNote(n, { updateExisting: true })));
        let out = notesChanged.map((note) => ({
            status: "update",
            note,
        }));
        // remove old note only when rename is success
        fs_extra_1.default.removeSync(oldLocPath);
        out = out.concat([{ status: "delete", note: oldNote }]);
        out = out.concat([{ status: "create", note: newNote }]);
        this.logger.info({ ctx, msg: "exit", opts });
        return out;
    }
    async updateNote(note, _opts) {
        const maybeNote = this.notes[note.id];
        if (maybeNote) {
            note = common_all_1.NoteUtilsV2.hydrate({ noteRaw: note, noteHydrated: maybeNote });
        }
        this.notes[note.id] = note;
        return;
    }
    async updateSchema(schemaModule) {
        this.schemas[schemaModule.root.id] = schemaModule;
        // const vaultDir = this.vaults[0];
        // await schemaModuleProps2File(schemaModule, vaultDir, schemaModule.fname);
        // TODO: update notes
    }
    async _writeNewNote({ note, maybeNote, opts, }) {
        let changed = [];
        // if note exists, remove from parent and transplant children
        if (maybeNote) {
            // update changed
            const parentNote = this.notes[maybeNote.parent];
            // remove existing note from parent's children
            parentNote.children = lodash_1.default.reject(parentNote.children, (ent) => ent === maybeNote.id);
            // update parent's children
            this.notes[maybeNote.parent].children = parentNote.children;
            // move maybeNote's children to newly written note
            note.children = maybeNote.children;
            // delete maybeNote
            delete this.notes[maybeNote.id];
        }
        // after we have deleted parent, add the current note as a parent
        if (!(opts === null || opts === void 0 ? void 0 : opts.noAddParent)) {
            changed = common_all_1.NoteUtilsV2.addParent({
                note,
                notesList: lodash_1.default.values(this.notes),
                createStubs: true,
                wsRoot: this.wsRoot,
            });
        }
        return changed;
    }
    async writeNote(note, opts) {
        const ctx = "FileStore:writeNote";
        let changed = [];
        this.logger.info({
            ctx,
            msg: "enter",
            opts,
            note: common_all_1.NoteUtilsV2.toLogObj(note),
        });
        const maybeNote = common_all_1.NoteUtilsV2.getNoteByFnameV4({
            fname: note.fname,
            notes: this.notes,
            vault: note.vault,
        });
        // don't count as delete if we're updating existing note
        let noDelete = false;
        if ((maybeNote === null || maybeNote === void 0 ? void 0 : maybeNote.stub) || (opts === null || opts === void 0 ? void 0 : opts.updateExisting)) {
            note = { ...maybeNote, ...note };
            noDelete = true;
        }
        else {
            changed = await this._writeNewNote({ note, maybeNote, opts });
        }
        // add schema if applicable
        const match = common_all_1.SchemaUtilsV2.matchPath({
            notePath: note.fname,
            schemaModDict: this.schemas,
        });
        // order matters - only write file after parents are established @see(_writeNewNote)
        await common_server_1.note2File({
            note,
            vault: note.vault,
            wsRoot: this.wsRoot,
            opts: { writeHierarchy: opts === null || opts === void 0 ? void 0 : opts.writeHierarchy },
        });
        if (match) {
            const { schema, schemaModule } = match;
            common_all_1.NoteUtilsV2.addSchema({ note, schema, schemaModule });
        }
        await Promise.all([note].concat(changed).map((ent) => this.updateNote(ent)));
        const changedEntries = changed.map((ent) => ({
            note: ent,
            status: "update",
        }));
        changedEntries.push({ note, status: "create" });
        if (maybeNote && !noDelete) {
            changedEntries.push({ note: maybeNote, status: "delete" });
        }
        return {
            error: null,
            data: changedEntries,
        };
    }
    async writeSchema(schemaModule) {
        this.schemas[schemaModule.root.id] = schemaModule;
        const vault = schemaModule.vault;
        const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
        await common_server_1.schemaModuleProps2File(schemaModule, vpath, schemaModule.fname);
    }
}
exports.FileStorageV2 = FileStorageV2;
//# sourceMappingURL=storev2.js.map