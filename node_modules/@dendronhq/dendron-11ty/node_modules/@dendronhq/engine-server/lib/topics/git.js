"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Git = exports.GitV2 = void 0;
// import { DendronError } from "@dendronhq/common-all";
// import { findInParent } from "@dendronhq/common-server";
// import fs from "fs-extra";
// import _ from "lodash";
// import nodegit, { Repository } from "nodegit";
// import os from "os";
// import path from "path";
const execa_1 = __importDefault(require("execa"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
class GitV2 {
    static async clone(cmd, opts) {
        const cmdParts = ["git clone", cmd];
        return await execa_1.default.command(cmdParts.join(" "), {
            shell: true,
            cwd: opts === null || opts === void 0 ? void 0 : opts.cwd,
        });
    }
}
exports.GitV2 = GitV2;
class Git {
    constructor(opts) {
        this.opts = opts;
    }
    static async getRepo(fpath) {
        return fs_extra_1.default.existsSync(path_1.default.join(fpath, ".git"));
    }
    static async createRepo(fpath, opts) {
        const { initCommit } = lodash_1.default.defaults(opts, { initCommit: false });
        fs_extra_1.default.ensureDirSync(fpath);
        const cmd = ["git init"];
        await execa_1.default.command(cmd.join(" "), {
            shell: true,
            cwd: fpath,
        });
        const readmePath = path_1.default.join(fpath, "README.md");
        fs_extra_1.default.ensureFileSync(readmePath);
        if (initCommit) {
            await execa_1.default.command(["git add ."].join(" "), {
                shell: true,
                cwd: fpath,
            });
            await execa_1.default.command(["git commit -m 'initial commit'"].join(" "), {
                shell: true,
                cwd: fpath,
            });
        }
        return;
    }
    async isRepo() {
        return Git.getRepo(this.opts.localUrl);
    }
    async clone(destOverride) {
        const { localUrl, remoteUrl } = this.opts;
        const cmdParts = ["git clone", remoteUrl];
        if (destOverride) {
            cmdParts.push(destOverride);
        }
        await execa_1.default.command(cmdParts.join(" "), {
            shell: true,
            cwd: localUrl,
        });
        return localUrl;
    }
    async addAll() {
        await execa_1.default.command(["git add ."].join(" "), {
            shell: true,
            cwd: this.opts.localUrl,
        });
    }
    async commit(opts) {
        const { msg } = opts;
        const { localUrl: cwd } = this.opts;
        await execa_1.default.command([`git commit -m '${msg}'`].join(" "), {
            shell: true,
            cwd,
        });
    }
    async push() {
        const { localUrl: cwd } = this.opts;
        await execa_1.default.command([`git push`].join(" "), {
            shell: true,
            cwd,
        });
    }
}
exports.Git = Git;
//# sourceMappingURL=git.js.map