"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EngineConnector = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const config_1 = require("../config");
const engineClient_1 = require("../engineClient");
const utils_1 = require("../utils");
class EngineConnector {
    constructor({ wsRoot }) {
        this.wsRoot = wsRoot;
        this.config = config_1.DConfig.getOrCreate(wsRoot);
        EngineConnector._ENGINE_CONNECTOR = this;
        this.initialized = false;
    }
    static instance() {
        if (!this._ENGINE_CONNECTOR) {
            throw new common_all_1.DendronError({ msg: "no workspace" });
        }
        return this._ENGINE_CONNECTOR;
    }
    static getOrCreate({ wsRoot }) {
        if (!this._ENGINE_CONNECTOR) {
            return new EngineConnector({ wsRoot });
        }
        return this._ENGINE_CONNECTOR;
    }
    get vaults() {
        return this.config.vaults.map((ent) => ent.fsPath);
    }
    async init(opts) {
        // init engine
        this.onReady = opts === null || opts === void 0 ? void 0 : opts.onReady;
        if (opts === null || opts === void 0 ? void 0 : opts.portOverride) {
            await this.initEngine({ port: opts.portOverride });
        }
        else {
            return this.createServerWatcher({ numRetries: opts === null || opts === void 0 ? void 0 : opts.numRetries });
        }
    }
    async initEngine({ port }) {
        const { wsRoot, vaults } = this;
        const dendronEngine = engineClient_1.DendronEngineClient.create({
            port,
            ws: wsRoot,
            vaults: vaults.map((ent) => ent),
        });
        await dendronEngine.sync();
        this._engine = dendronEngine;
        this.initialized = true;
        return dendronEngine;
    }
    get engine() {
        if (!this._engine) {
            throw Error("engine not set");
        }
        return this._engine;
    }
    async createServerWatcher(opts) {
        const { wsRoot } = this;
        const fpath = utils_1.getPortFilePath({ wsRoot });
        const { watcher } = await common_server_1.createFileWatcher({
            fpath,
            numTries: opts === null || opts === void 0 ? void 0 : opts.numRetries,
            onChange: async ({ fpath }) => {
                const port = utils_1.openPortFile({ fpath });
                this.onChangePort({ port });
            },
            onCreate: async ({ fpath }) => {
                const port = utils_1.openPortFile({ fpath });
                this.onChangePort({ port });
            },
        });
        // file should exist at this point
        const metaFpath = utils_1.getWSMetaFilePath({ wsRoot });
        const wsMeta = utils_1.openWSMetaFile({ fpath: metaFpath });
        const wsActivation = wsMeta.activationTime;
        // check if port was created after current ws
        const portCreated = common_all_1.Time.DateTime.fromJSDate(fs_extra_1.default.statSync(fpath).ctime).toMillis();
        if (portCreated > wsActivation) {
            const port = utils_1.openPortFile({ fpath });
            this.onChangePort({ port });
        }
        // race condition were old workspace file is found
        setTimeout(() => {
            if (fs_extra_1.default.existsSync(fpath) && portCreated > wsActivation) {
                const port = utils_1.openPortFile({ fpath });
                this.onChangePort({ port });
            }
        }, 10000);
        // attach watcher
        this.serverPortWatcher = watcher;
    }
    async onChangePort({ port }) {
        const portPrev = this.port;
        if (this.port !== port) {
            this.port = port;
            await this.initEngine({ port });
        }
        if (lodash_1.default.isUndefined(portPrev) && this.onReady) {
            this.onReady({ ws: this });
        }
        this.initialized = true;
    }
}
exports.EngineConnector = EngineConnector;
//# sourceMappingURL=connector.js.map