"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dendronLinksPlugin = exports.LINK_REGEX = void 0;
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
exports.LINK_REGEX = /^\[\[(.+?)\]\]/;
function locator(value, fromIndex) {
    return value.indexOf("[", fromIndex);
}
function genLinkValue(value, data) {
    if (data.anchorHeader) {
        value = value += `#${data.anchorHeader}`;
    }
    return value;
}
/**
 * Matches wiki-links
 * @param opts
 */
function dendronLinksPlugin(opts = {}) {
    const permalinks = opts.permalinks || [];
    const defaultPageResolver = (name) => [
        name.replace(/ /g, "").toLowerCase(),
    ];
    const pageResolver = opts.pageResolver || defaultPageResolver;
    const newClassName = opts.newClassName || "new";
    const wikiLinkClassName = opts.wikiLinkClassName || "internal";
    const defaultHrefTemplate = (permalink) => `#/page/${permalink}`;
    const hrefTemplate = opts.hrefTemplate || defaultHrefTemplate;
    const aliasDivider = opts.aliasDivider || "|";
    const copts = lodash_1.default.defaults(opts, { convertObsidianLinks: false });
    function isAlias(pageTitle) {
        return pageTitle.indexOf(aliasDivider) !== -1;
    }
    function parseAliasLink(pageTitle) {
        const [alias, value] = pageTitle.split(aliasDivider);
        return { alias, value };
    }
    function parseAnchorIfExist(link) {
        if (link.indexOf("#") !== -1) {
            return link.split("#");
        }
        else {
            return [link, undefined];
        }
    }
    function parsePageTitle(pageTitle) {
        let out = {
            value: pageTitle,
            alias: pageTitle,
        };
        if (isAlias(pageTitle)) {
            out = parseAliasLink(pageTitle);
        }
        if (out.value.indexOf("#") !== -1) {
            const [value, anchorHeader] = out.value.split("#");
            out.value = value;
            out.anchorHeader = anchorHeader;
            // if we didn't have an alias, links with a # anchor shouldn't have # portion be in the title
            if (!isAlias(pageTitle)) {
                out.alias = value;
            }
        }
        return out;
    }
    function inlineTokenizer(eat, value) {
        const match = exports.LINK_REGEX.exec(value);
        if (match) {
            // contents of the link
            const pageName = match[1].trim();
            const { value, alias, anchorHeader } = parsePageTitle(pageName);
            const pagePermalinks = pageResolver(value);
            let permalink = pagePermalinks.find((p) => permalinks.indexOf(p) !== -1);
            const exists = permalink !== undefined;
            if (!exists) {
                permalink = pagePermalinks[0];
            }
            let classNames = wikiLinkClassName;
            if (!exists) {
                classNames += " " + newClassName;
            }
            // normalize
            if (permalink) {
                permalink = common_server_1.removeMDExtension(permalink);
            }
            return eat(match[0])({
                type: "wikiLink",
                value,
                data: {
                    alias,
                    toMdEnhancedPreview: opts.toMdEnhancedPreview,
                    permalink,
                    anchorHeader,
                    exists,
                    hName: "a",
                    hProperties: {
                        className: classNames,
                        href: hrefTemplate(permalink),
                    },
                    hChildren: [
                        {
                            type: "text",
                            value: alias,
                        },
                    ],
                },
            });
        }
        return;
    }
    inlineTokenizer.locator = locator;
    // @ts-ignore
    let _this = this;
    const Parser = _this.Parser;
    // @ts-ignore
    const inlineTokenizers = Parser.prototype.inlineTokenizers;
    // @ts-ignore
    const inlineMethods = Parser.prototype.inlineMethods;
    inlineTokenizers.wikiLink = inlineTokenizer;
    inlineMethods.splice(inlineMethods.indexOf("link"), 0, "wikiLink");
    // Stringify for wiki link
    // @ts-ignore
    const Compiler = _this.Compiler;
    if (Compiler != null) {
        const visitors = Compiler.prototype.visitors;
        if (visitors) {
            visitors.wikiLink = function (node) {
                const data = node.data;
                if (!node || !node.data || !node.data.alias) {
                    throw Error(`no alias found: ${JSON.stringify(node)}`);
                }
                if (data.useId) {
                    if (!data.note) {
                        throw Error("no note");
                    }
                    node.value = data.note.id;
                }
                if (opts.replaceLink && opts.replaceLink.from.fname === node.value) {
                    // TODO: check for case
                    node.value = opts.replaceLink.to.fname;
                    if (node.data.alias === opts.replaceLink.from.fname) {
                        node.data.alias = opts.replaceLink.to.fname;
                    }
                }
                let nodeValue = genLinkValue(node.value, data);
                if (data.toMd) {
                    return `[${data.alias}](${data.prefix || ""}${nodeValue})`;
                }
                if (data.forNoteRefInPreview) {
                    return `${data.prefix || ""}${node.value}.md`;
                }
                if (data.forNoteRefInSite) {
                    return `${data.prefix || ""}${node.value}.html`;
                }
                if (data.toHTML) {
                    return `${data.prefix || ""}${node.value}.html`;
                }
                if (node.data.alias !== node.value) {
                    return `[[${node.data.alias}${aliasDivider}${nodeValue}]]`;
                }
                if (copts.convertObsidianLinks) {
                    nodeValue = lodash_1.default.replace(nodeValue, /\//g, ".");
                }
                if (data.toMdEnhancedPreview) {
                    return `[[${parseAnchorIfExist(node.value)[0]}]]`;
                }
                return `[[${nodeValue}]]`;
            };
        }
    }
}
exports.dendronLinksPlugin = dendronLinksPlugin;
//# sourceMappingURL=dendronLinksPlugin.js.map