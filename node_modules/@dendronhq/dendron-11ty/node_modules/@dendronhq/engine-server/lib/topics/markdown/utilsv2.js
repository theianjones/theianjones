"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemarkUtilsV2 = exports.ParserUtilsV2 = exports.WIKI_LINK_VALUE_RE = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const mdast_builder_1 = require("mdast-builder");
const remark_1 = __importDefault(require("remark"));
const remark_abbr_1 = __importDefault(require("remark-abbr"));
const remark_frontmatter_1 = __importDefault(require("remark-frontmatter"));
const remark_parse_1 = __importDefault(require("remark-parse"));
const dendronLinksPlugin_1 = require("./plugins/dendronLinksPlugin");
const dendronNoteRefPlugin_1 = require("./plugins/dendronNoteRefPlugin");
exports.WIKI_LINK_VALUE_RE = /(^\])/;
const selectAll = require("unist-util-select").selectAll;
class ParserUtilsV2 {
    static createWikiLinkRE(opts) {
        const { oldLink } = opts || {};
        if (oldLink) {
            const match = ParserUtilsV2.escapeForRegExp(oldLink);
            return `\\[\\[\\s*?(.*\\|)?\\s*${match}\\s*\\]\\]`;
        }
        return "\\[\\[\\s*?(.*\\|)?\\s*(?<name>.*)\\s*\\]\\]";
    }
    /**
     * - parse frontmatter
     * - parse wiki links
     * @param opts
     */
    static getRemark(opts) {
        const { dendronLinksOpts, useDendronNoteRefPluginForMd, dendronNoteRefPluginForMdOpts: dendronRefLinkOpts, } = lodash_1.default.defaults(opts, {
            dendronLinksOpts: {},
            useDendronNoteRefPluginForMd: true,
            dendronRefLinkOpts: {},
        });
        const errors = [];
        let plugin = remark_1.default()
            .data("errors", errors)
            .use(remark_parse_1.default, { gfm: true })
            .use(remark_abbr_1.default)
            .use(remark_frontmatter_1.default, ["yaml"])
            .use(dendronLinksPlugin_1.dendronLinksPlugin, dendronLinksOpts)
            .use({ settings: { listItemIndent: "1", fences: true, bullet: "-" } });
        if (useDendronNoteRefPluginForMd) {
            plugin.use(dendronNoteRefPlugin_1.dendronNoteRefPluginForMd, dendronRefLinkOpts);
        }
        return plugin;
    }
    static findHeaders(content) {
        let remark = ParserUtilsV2.getRemark();
        let out = remark.parse(content);
        let out2 = selectAll("heading", out);
        return out2;
    }
    /**
     * Get all links from the note body
     * Currently, just look for wiki links
     * @param param0
     */
    static findLinks({ note }) {
        const content = note.body;
        let remark = ParserUtilsV2.getRemark();
        let out = remark.parse(content);
        let out2 = selectAll("wikiLink", out);
        // let refLink = selectAll("refLink", out)
        const dlinks = out2.map((m) => {
            var _a, _b;
            return ({
                type: "wiki",
                from: common_all_1.NoteUtilsV2.toLoc(note),
                original: m.value,
                value: m.value,
                alias: m.data.alias,
                pos: { start: (_a = m.position) === null || _a === void 0 ? void 0 : _a.start.offset, end: (_b = m.position) === null || _b === void 0 ? void 0 : _b.end.offset },
                to: {
                    fname: m.value,
                    anchorHeader: m.data.anchorHeader,
                },
            });
        });
        return dlinks;
    }
    static escapeForRegExp(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    static genMDError(opts) {
        const { msg, title } = opts;
        return mdast_builder_1.root([
            mdast_builder_1.heading(3, mdast_builder_1.text(title)),
            mdast_builder_1.paragraph([mdast_builder_1.paragraph(mdast_builder_1.text(msg)), mdast_builder_1.brk]),
        ]);
    }
    static async replaceLinks(opts) {
        const { content, from, to } = opts;
        let remark = ParserUtilsV2.getRemark({
            dendronLinksOpts: {
                replaceLink: { from, to },
            },
            dendronNoteRefPluginForMdOpts: {
                replaceLink: { from, to },
            },
        });
        const out = await remark.process(content);
        return out.toString();
    }
}
exports.ParserUtilsV2 = ParserUtilsV2;
class RemarkUtilsV2 {
    static replaceLink({ link, opts, }) {
        if (opts.from.fname === link.from.fname) {
            // TODO: check for case
            link.from.fname = opts.to.fname;
            if (link.from.alias === opts.from.fname) {
                link.from.alias = opts.to.fname;
            }
        }
        return link;
    }
}
exports.RemarkUtilsV2 = RemarkUtilsV2;
//# sourceMappingURL=utilsv2.js.map