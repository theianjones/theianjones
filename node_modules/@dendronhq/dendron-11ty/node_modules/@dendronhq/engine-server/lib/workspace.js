"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkspaceService = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_all_2 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const config_1 = require("./config");
const utils_1 = require("./utils");
class WorkspaceService {
    constructor({ wsRoot }) {
        this.wsRoot = wsRoot;
    }
    static isNewVersionGreater({ oldVersion, newVersion, }) {
        return common_all_2.DUtils.semver.lt(oldVersion, newVersion);
    }
    get config() {
        return config_1.DConfig.getOrCreate(this.wsRoot);
    }
    get configV2() {
        return config_1.DConfig.getOrCreate(this.dendronRoot);
    }
    get dendronRoot() {
        return path_1.default.join(this.wsRoot, "dendron");
    }
    async setConfig(config) {
        const wsRoot = this.wsRoot;
        return config_1.DConfig.writeConfig({ wsRoot, config });
    }
    async setConfigV2(config) {
        const wsRoot = this.dendronRoot;
        return config_1.DConfig.writeConfig({ wsRoot, config });
    }
    /**
     * Create vault files if it does not exist
     */
    async createVault({ vault, noAddToConfig, }) {
        const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
        fs_extra_1.default.ensureDirSync(vpath);
        const note = common_all_2.NoteUtilsV2.createRoot({
            vault,
            body: [
                "# Welcome to Dendron",
                "",
                `This is the root of your dendron vault. If you decide to publish your entire vault, this will be your landing page. You are free to customize any part of this page except the frontmatter on top. `,
            ].join("\n"),
        });
        const schema = common_all_2.SchemaUtilsV2.createRootModule({ vault });
        if (!fs_extra_1.default.existsSync(common_all_2.NoteUtilsV2.getPathV4({ note, wsRoot: this.wsRoot }))) {
            await common_server_1.note2File({ note, vault, wsRoot: this.wsRoot });
        }
        if (!fs_extra_1.default.existsSync(common_all_2.SchemaUtilsV2.getPath({ root: this.wsRoot, fname: "root" }))) {
            await common_server_1.schemaModuleOpts2File(schema, vpath, "root");
        }
        if (!noAddToConfig) {
            const config = this.config;
            config.vaults.unshift(vault);
            await this.setConfig(config);
        }
        return;
    }
    /**
     * Not fully resolved vault
     */
    async createVaultV2({ vault }) {
        const vaultFullPath = common_server_1.resolvePath(vault.fsPath, this.wsRoot);
        fs_extra_1.default.ensureDirSync(vaultFullPath);
        const wsRoot = this.wsRoot;
        const note = common_all_2.NoteUtilsV2.createRoot({
            vault,
            body: [
                "# Welcome to Dendron",
                "",
                `This is the root of your dendron vault. If you decide to publish your entire vault, this will be your landing page. You are free to customize any part of this page except the frontmatter on top. `,
            ].join("\n"),
        });
        const schema = common_all_2.SchemaUtilsV2.createRootModule({ vault });
        const notePath = common_all_2.NoteUtilsV2.getPathV4({ note, wsRoot });
        if (!fs_extra_1.default.existsSync(notePath)) {
            await common_server_1.note2File({ note, vault, wsRoot: this.wsRoot });
        }
        if (!fs_extra_1.default.existsSync(common_all_2.SchemaUtilsV2.getPath({ root: this.wsRoot, fname: "root" }))) {
            await common_server_1.schemaModuleOpts2File(schema, vaultFullPath, "root");
        }
        // update config
        const config = this.configV2;
        config.vaults.push(vault);
        await this.setConfigV2(config);
        return;
    }
    /**
     * Remove vaults. Currently doesn't delete an yfiles
     * @param param0
     */
    async removeVault({ vault }) {
        const config = this.config;
        config.vaults = lodash_1.default.reject(config.vaults, { fsPath: vault.fsPath });
        await this.setConfig(config);
    }
    /**
     * Iinitialize workspace with root
     * @param opts
     */
    static async createWorkspace(opts) {
        const { wsRoot, vaults } = opts;
        const ws = new WorkspaceService({ wsRoot });
        fs_extra_1.default.ensureDirSync(wsRoot);
        await Promise.all(vaults.map(async (vault) => {
            return ws.createVault({ vault });
        }));
        return ws;
    }
    static async createWorkspaceV2(opts) {
        const { wsRoot, vaults } = opts;
        const ws = new WorkspaceService({ wsRoot });
        fs_extra_1.default.ensureDirSync(wsRoot);
        fs_extra_1.default.ensureDirSync(ws.dendronRoot);
        await Promise.all(vaults.map(async (vault) => {
            return ws.createVaultV2({ vault });
        }));
        return ws;
    }
    async cloneVault(opts) {
        const { vault } = opts;
        const wsRoot = this.wsRoot;
        if (!vault.remote || vault.remote.type !== "git") {
            throw new common_all_2.DendronError({ msg: "cloning non-git vault" });
        }
        const repoPath = common_all_2.WorkspaceUtilsCommon.getPathForVault({ wsRoot, vault });
        const repoDir = common_all_2.WorkspaceUtilsCommon.getRepoDir(wsRoot);
        fs_extra_1.default.ensureDirSync(repoDir);
        const git = common_server_1.simpleGit({ baseDir: repoDir });
        await git.clone(vault.remote.url);
        return repoPath;
    }
    writePort(port) {
        const wsRoot = this.wsRoot;
        const portFilePath = utils_1.getPortFilePath({ wsRoot });
        fs_extra_1.default.writeFileSync(portFilePath, port, { encoding: "utf8" });
    }
    writeMeta(opts) {
        const { version } = opts;
        const fpath = utils_1.getWSMetaFilePath({ wsRoot: this.wsRoot });
        return utils_1.writeWSMetaFile({
            fpath,
            data: {
                version,
                activationTime: common_all_1.Time.now().toMillis(),
            },
        });
    }
}
exports.WorkspaceService = WorkspaceService;
//# sourceMappingURL=workspace.js.map