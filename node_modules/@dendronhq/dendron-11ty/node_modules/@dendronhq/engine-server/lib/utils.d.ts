import { DendronError, DEngineClientV2, DNoteLoc, DNoteRefData, DNoteRefLink, DVault } from "@dendronhq/common-all";
import Token from "markdown-it/lib/token";
import { WSMeta } from "./types";
export declare const loc2Path: ({ loc, wsRoot, }: {
    loc: DNoteLoc;
    wsRoot: string;
}) => string;
/**
 * take a ref link and parse it as regular markdown
 */
export declare function refLink2String(link: DNoteRefLink, opts?: {
    includeParen: boolean;
    includeRefTag?: boolean;
}): string;
export declare function getEngine(opts: {
    numTries?: number;
    wsRoot: string;
    vaults: DVault[];
}): Promise<{
    error?: DendronError;
    data?: DEngineClientV2;
}>;
export declare function getPortFilePath({ wsRoot }: {
    wsRoot: string;
}): string;
export declare function getWSMetaFilePath({ wsRoot }: {
    wsRoot: string;
}): string;
export declare function openPortFile({ fpath }: {
    fpath: string;
}): number;
export declare function openWSMetaFile({ fpath }: {
    fpath: string;
}): WSMeta;
export declare function writeWSMetaFile({ fpath, data, }: {
    fpath: string;
    data: WSMeta;
}): void;
export declare type ASTEnt = {
    nodeType: "heading" | "other";
    openNode: Token;
    closeNode: Token;
    children: Token[];
};
export declare function extractBlock(txt: string, link: DNoteRefLink): {
    block: string;
    lines?: {
        start: number | undefined;
        end: number | undefined;
    };
};
export declare function parseDendronRef(ref: string): {
    direction: "to";
    link: import("@dendronhq/common-all").DNoteLink<DNoteRefData> | undefined;
};
export declare function parseFileLink(ref: string): DNoteRefLink;
export declare const matchRefMarker: (txt: string) => RegExpMatchArray | null;
export declare const replaceRefWithMPEImport: (line: string, opts: {
    root: string;
}) => string;
export declare function stripLocalOnlyTags(doc: string): string;
