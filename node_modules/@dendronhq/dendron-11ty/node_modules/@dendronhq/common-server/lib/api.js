"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DendronAPI = exports.API = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const logger_1 = require("./logger");
const requests = require("request-promise");
const L = logger_1.createLogger("api");
// === Utilities
const APIError = common_all_1.DendronError;
const STATUS_HANDLERS = {
    401: {
        isErr: true,
        handler: ({ resp }) => new APIError({ status: "not_authorized_error", code: resp.statusCode }),
    },
    404: {
        isErr: true,
        handler: ({ resp }) => new APIError({ code: resp.statusCode, status: "does_not_exist_error" }),
    },
    502: {
        isErr: true,
        handler: ({ resp }) => new APIError({ code: resp.statusCode, status: "unknown_error" }),
    },
};
// === Base
class API {
    constructor(opts) {
        opts = lodash_1.default.defaults(opts, {
            // _request: request,
            logger: L,
            statusHandlers: {},
            onAuth: async ({ headers }) => headers,
            onBuildHeaders: ({ headers }) => headers,
            onError: (_args) => {
                // console.log(args);
            },
        });
        if (!opts._request) {
            opts._request = requests;
        }
        this.opts = opts;
    }
    _log(msg, lvl = "info") {
        this.opts.logger[lvl](msg);
    }
    _createPayload(data) {
        return {
            error: null,
            data,
        };
    }
    async _doRequest({ auth = false, qs = {}, path, body = {}, method = "get", json = true, }) {
        let headers = {};
        const { _request, onAuth, onBuildHeaders, endpoint, apiPath } = this.opts;
        if (auth) {
            headers = await onAuth({ headers });
        }
        headers = await onBuildHeaders({ headers });
        const requestParams = {
            url: [endpoint, apiPath, path].join("/"),
            qs,
            body,
            json,
            ...headers,
        };
        this._log({ ctx: "pre-request", requestParams }, "debug");
        return _request[method](requestParams, async (err, resp, respBody) => {
            const { statusHandlers, onError } = this.opts;
            let foundError = false;
            // tslint:disable-next-line: no-shadowed-variable
            let respHandler = ({ resp }) => {
                const out = resp;
                return out;
            };
            // check if we have a handler based on return code
            if (lodash_1.default.has(lodash_1.default.defaults(statusHandlers, STATUS_HANDLERS), resp.statusCode)) {
                const { statusCode } = resp;
                this._log({
                    ctx: "post-request",
                    msg: "use statusHandler",
                    statusCode,
                });
                const { isErr, handler } = statusHandlers[resp.statusCode];
                respHandler = handler;
                if (isErr) {
                    foundError = true;
                }
            }
            // log error if we have on
            if (foundError) {
                this._log({ ctx: "post-request-foundError", err });
                onError({
                    headers,
                    qs,
                    path,
                    method,
                    err,
                    body: respBody,
                    resp,
                });
            }
            // trigger handler
            this._log({ ctx: "post-request-exit", resp, respHandler }, "debug");
            return respHandler({ resp });
        });
    }
    async _makeRequest(args, paylaodData) {
        let payload = this._createPayload(paylaodData);
        try {
            const resp = await this._doRequest(args);
            const { error, data } = resp;
            payload.data = data;
            payload.error = error;
        }
        catch (err) {
            payload.error = err;
        }
        return payload;
    }
}
exports.API = API;
// === DendronAPI
class DendronAPI extends API {
    async configGet(req) {
        const resp = await this._makeRequest({
            path: "config/get",
            method: "get",
            qs: req,
        });
        return resp;
    }
    async configWrite(req) {
        const resp = await this._makeRequest({
            path: "config/write",
            method: "post",
            body: req,
        });
        return resp;
    }
    async workspaceInit(req) {
        const resp = await this._makeRequest({
            path: "workspace/initialize",
            method: "post",
            body: {
                ...req,
            },
        });
        return resp;
    }
    async workspaceList() {
        const resp = await this._makeRequest({
            path: "workspace/all",
            method: "get",
        });
        return this._createPayload(resp);
    }
    async workspaceSync(req) {
        const resp = await this._makeRequest({
            path: "workspace/sync",
            method: "post",
            body: req,
        });
        return resp;
    }
    async engineDelete(req) {
        const resp = await this._makeRequest({
            path: "note/delete",
            method: "post",
            body: req,
        });
        return resp;
    }
    async engineGetNoteByPath(req) {
        const resp = await this._makeRequest({
            path: "note/getByPath",
            method: "post",
            body: req,
        });
        return resp;
    }
    // async engineQuery(req: EngineQueryRequest): Promise<EngineQueryPayload> {
    //   const resp = await this._makeRequest({
    //     path: "note/query",
    //     method: "post",
    //     body: req,
    //   });
    //   return resp;
    // }
    async engineRenameNote(req) {
        const resp = await this._makeRequest({
            path: "note/rename",
            method: "post",
            body: req,
        });
        return resp;
    }
    async engineUpdateNote(req) {
        const resp = await this._makeRequest({
            path: "note/update",
            method: "post",
            body: req,
        });
        return resp;
    }
    async engineWrite(req) {
        const resp = await this._makeRequest({
            path: "note/write",
            method: "post",
            body: req,
        });
        return resp;
    }
    async noteQuery(req) {
        const resp = await this._makeRequest({
            path: "note/query",
            method: "get",
            qs: req,
        });
        return resp;
    }
    async schemaDelete(req) {
        const resp = await this._makeRequest({
            path: "schema/delete",
            method: "post",
            body: req,
        });
        return resp;
    }
    async schemaRead(req) {
        const resp = await this._makeRequest({
            path: "schema/get",
            method: "get",
            qs: req,
        });
        return resp;
    }
    async schemaQuery(req) {
        const resp = await this._makeRequest({
            path: "schema/query",
            method: "post",
            body: req,
        });
        return resp;
    }
    async schemaWrite(req) {
        const resp = await this._makeRequest({
            path: "schema/write",
            method: "post",
            body: req,
        });
        return resp;
    }
    async schemaUpdate(req) {
        const resp = await this._makeRequest({
            path: "schema/update",
            method: "post",
            body: req,
        });
        return resp;
    }
}
exports.DendronAPI = DendronAPI;
//# sourceMappingURL=api.js.map