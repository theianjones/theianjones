"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ENGINE_WRITE_PRESETS_MULTI = exports.ENGINE_WRITE_PRESETS = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const noteUtils_1 = require("../../noteUtils");
const utilsv2_1 = require("../../utilsv2");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const common_server_1 = require("@dendronhq/common-server");
const __1 = require("../..");
const utils_1 = require("./utils");
const schemas_1 = require("../schemas");
const SCHEMAS = {
    ADD_NEW_SCHEMA: new utilsv2_1.TestPresetEntryV4(async ({ vaults, engine }) => {
        const schemaModId = schemas_1.SCHEMA_PRESETS_V4.SCHEMA_SIMPLE.fname;
        const module = engine.schemas[schemaModId];
        const vault = vaults[0];
        const schema = common_all_1.SchemaUtilsV2.create({ id: "ch2", vault });
        common_all_1.DNodeUtilsV2.addChild(module.root, schema);
        module.schemas[schema.id] = schema;
        await engine.updateSchema(module);
        const resp = await engine.querySchema("*");
        return [
            {
                actual: lodash_1.default.values(engine.schemas).length,
                expected: 2,
            },
            {
                actual: lodash_1.default.values(engine.schemas["foo"].schemas).length,
                expected: 3,
            },
            {
                actual: resp.data.length,
                expected: 2,
                msg: "query should have same results",
            },
        ];
    }, {
        preSetupHook: utils_1.setupBasic,
    }),
    ADD_NEW_MODULE_NO_CHILD: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        const vault = vaults[0];
        const schemaModNew = await schemas_1.SCHEMA_PRESETS_V4.SCHEMA_SIMPLE_OTHER_NO_CHILD.create({
            vault,
            wsRoot,
            noWrite: true,
        });
        await engine.writeSchema(schemaModNew);
        return [
            {
                actual: lodash_1.default.values(engine.schemas).length,
                expected: 3,
            },
            {
                actual: lodash_1.default.values(engine.schemas["bar"].schemas).length,
                expected: 1,
            },
        ];
    }, {
        preSetupHook: utils_1.setupBasic,
    }),
    ADD_NEW_MODULE: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        const vault = vaults[0];
        const schemaModNew = await schemas_1.SCHEMA_PRESETS_V4.SCHEMA_SIMPLE_OTHER.create({
            vault,
            wsRoot,
            noWrite: true,
        });
        await engine.writeSchema(schemaModNew);
        return [
            {
                actual: lodash_1.default.values(engine.schemas).length,
                expected: 3,
            },
            {
                actual: lodash_1.default.values(engine.schemas["foo"].schemas).length,
                expected: 2,
            },
            {
                actual: lodash_1.default.values(engine.schemas["bar"].schemas).length,
                expected: 2,
            },
        ];
    }, {
        preSetupHook: utils_1.setupBasic,
    }),
};
const NOTES = {
    SERIALIZE_CHILD_WITH_HIERARCHY: new utilsv2_1.TestPresetEntryV4(async ({ vaults, wsRoot, engine }) => {
        const noteNew = common_all_1.NoteUtilsV2.create({
            fname: "foo.ch1",
            id: "foo.ch1",
            created: "1",
            updated: "1",
            vault: vaults[0],
        });
        await engine.writeNote(noteNew, { writeHierarchy: true });
        const vpath = common_server_1.vault2Path({ vault: vaults[0], wsRoot });
        const rawNote = fs_extra_1.default.readFileSync(path_1.default.join(vpath, "foo.ch1.md"), {
            encoding: "utf8",
        });
        return [
            {
                actual: lodash_1.default.isNull(rawNote.match(/^parent: .*/gm)),
                expected: false,
                msg: "should have parent",
            },
        ];
    }),
    CUSTOM_ATT: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        const note = await __1.NOTE_PRESETS_V4.NOTE_WITH_CUSTOM_ATT.create({
            wsRoot,
            vault: vaults[0],
            noWrite: true,
        });
        await engine.writeNote(note);
        const noteRoot = common_all_1.NoteUtilsV2.getNoteByFnameV4({
            fname: note.fname,
            notes: engine.notes,
            vault: vaults[0],
        });
        return [
            {
                actual: noteRoot.fname,
                expected: "foo",
            },
            {
                actual: noteRoot.custom,
                expected: { bond: 42 },
            },
        ];
    }),
    CUSTOM_ATT_ADD: new utilsv2_1.TestPresetEntryV4(async ({ vaults, engine }) => {
        const note = common_all_1.NoteUtilsV2.getNoteByFnameV4({
            fname: "foo",
            notes: engine.notes,
            vault: vaults[0],
        });
        note.custom = { bond: 43 };
        await engine.writeNote(note, { updateExisting: true });
        const newNote = common_all_1.NoteUtilsV2.getNoteByFnameV4({
            fname: "foo",
            notes: engine.notes,
            vault: vaults[0],
        });
        return [
            {
                actual: newNote,
                expected: note,
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            await noteUtils_1.NoteTestUtilsV4.createNote({
                fname: "foo",
                vault: vaults[0],
                wsRoot,
            });
        },
    }),
    NEW_DOMAIN: new utilsv2_1.TestPresetEntryV4(async ({ vaults, engine }) => {
        const vault = vaults[0];
        const noteNew = common_all_1.NoteUtilsV2.create({
            id: "bar",
            fname: "bar",
            created: "1",
            updated: "1",
            vault: vaults[0],
        });
        await engine.writeNote(noteNew);
        const resp = await engine.queryNotes({ qs: "bar", vault });
        const note = resp.data[0];
        return [
            {
                actual: note,
                expected: engine.notes[note.id],
                msg: "bar should be written in engine",
            },
            {
                actual: common_all_1.DNodeUtilsV2.isRoot(engine.notes[note.parent]),
                expected: true,
            },
        ];
    }),
    MATCH_SCHEMA: new utilsv2_1.TestPresetEntryV4(async ({ vaults, engine }) => {
        var _a;
        const vault = vaults[0];
        const noteNew = common_all_1.NoteUtilsV2.create({
            fname: "foo.ch1",
            created: "1",
            updated: "1",
            vault,
        });
        await engine.writeNote(noteNew);
        return [
            {
                actual: (_a = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                    fname: "foo.ch1",
                    notes: engine.notes,
                    vault,
                })) === null || _a === void 0 ? void 0 : _a.schema,
                expected: {
                    moduleId: "foo",
                    schemaId: "ch1",
                },
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            await noteUtils_1.NoteTestUtilsV4.createSchema({
                fname: "foo",
                vault: vaults[0],
                wsRoot,
                modifier: (schema) => {
                    schema.schemas["ch1"] = common_all_1.SchemaUtilsV2.create({
                        id: "ch1",
                        vault: vaults[0],
                    });
                    common_all_1.DNodeUtilsV2.addChild(schema.root, schema.schemas["ch1"]);
                    return schema;
                },
            });
        },
    }),
    DOMAIN_STUB: new utilsv2_1.TestPresetEntryV4(async ({ engine, vaults, wsRoot }) => {
        const note = await noteUtils_1.NoteTestUtilsV4.createNote({
            fname: "bar.ch1",
            vault: vaults[0],
            wsRoot,
            noWrite: true,
        });
        await engine.writeNote(note);
        const { notes } = engine;
        const vault = vaults[0];
        //const root = NoteUtilsV2.getNoteByFnameV4("root", notes) as NotePropsV2;
        const root = common_all_1.NoteUtilsV2.getNoteByFnameV4({
            fname: "root",
            notes,
            vault,
        });
        const bar = common_all_1.NoteUtilsV2.getNoteByFnameV4({
            fname: "bar",
            notes,
            vault,
        });
        const child = common_all_1.NoteUtilsV2.getNoteByFnameV4({
            fname: "bar.ch1",
            notes,
            vault,
        });
        return [
            {
                actual: lodash_1.default.size(root.children),
                expected: 1,
                msg: "root, foo, bar",
            },
            {
                actual: lodash_1.default.pick(bar, "stub"),
                expected: { stub: true },
                msg: "bar created as stub",
            },
            {
                actual: lodash_1.default.pick(child, ["fname", "stub"]),
                expected: { fname: "bar.ch1" },
                msg: "child is not stub",
            },
        ];
    }),
    GRANDCHILD_OF_ROOT_AND_CHILD_IS_STUB: new utilsv2_1.TestPresetEntryV4(async ({ vaults, wsRoot, engine }) => {
        const noteNew = common_all_1.NoteUtilsV2.create({
            fname: "bond.ch1",
            created: "1",
            updated: "1",
            vault: vaults[0],
        });
        await engine.writeNote(noteNew);
        const checkVault = await __1.FileTestUtils.assertInVault({
            wsRoot,
            vault: vaults[0],
            match: ["bond.ch1.md"],
            nomatch: ["bond.md"],
        });
        return [
            {
                actual: checkVault,
                expected: true,
            },
        ];
    }),
    CHILD_OF_DOMAIN: new utilsv2_1.TestPresetEntryV4(async ({ vaults, wsRoot, engine }) => {
        const noteNew = common_all_1.NoteUtilsV2.create({
            fname: "foo.ch2",
            vault: vaults[0],
        });
        await engine.writeNote(noteNew);
        const checkVault = await __1.FileTestUtils.assertInVault({
            wsRoot,
            vault: vaults[0],
            match: ["foo.md", "foo.ch2.md"],
        });
        return [
            {
                actual: checkVault,
                expected: true,
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            await noteUtils_1.NoteTestUtilsV4.createNote({
                fname: "foo",
                vault: vaults[0],
                wsRoot,
            });
        },
    }),
    GRANDCHILD_OF_DOMAIN_AND_CHILD_IS_STUB: new utilsv2_1.TestPresetEntryV4(async ({ vaults, wsRoot, engine }) => {
        const noteNew = common_all_1.NoteUtilsV2.create({
            fname: "foo.ch2.gch1",
            vault: vaults[0],
        });
        await engine.writeNote(noteNew);
        const checkVault = await __1.FileTestUtils.assertInVault({
            wsRoot,
            vault: vaults[0],
            match: ["foo.md", "foo.ch2.gch1.md"],
            nomatch: ["foo.ch2.md"],
        });
        return [
            {
                actual: checkVault,
                expected: true,
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            await noteUtils_1.NoteTestUtilsV4.createNote({
                fname: "foo",
                vault: vaults[0],
                wsRoot,
            });
        },
    }),
    TITLE_MATCHES_TITLE_CASE: new utilsv2_1.TestPresetEntryV4(async ({ vaults, wsRoot, engine }) => {
        var _a, _b, _c;
        const vault = vaults[0];
        const noteA = await noteUtils_1.NoteTestUtilsV4.createNote({
            fname: "Upper Upper",
            vault: vaults[0],
            wsRoot,
        });
        await engine.writeNote(noteA);
        const noteB = await noteUtils_1.NoteTestUtilsV4.createNote({
            fname: "lower lower",
            vault: vaults[0],
            wsRoot,
        });
        await engine.writeNote(noteB);
        const noteC = await noteUtils_1.NoteTestUtilsV4.createNote({
            fname: "lower Upper",
            vault: vaults[0],
            wsRoot,
        });
        await engine.writeNote(noteC);
        return [
            {
                actual: (_a = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                    fname: "Upper Upper",
                    notes: engine.notes,
                    vault,
                })) === null || _a === void 0 ? void 0 : _a.title,
                expected: "Upper Upper",
            },
            {
                actual: (_b = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                    fname: "lower lower",
                    notes: engine.notes,
                    vault,
                })) === null || _b === void 0 ? void 0 : _b.title,
                expected: "Lower lower",
            },
            {
                actual: (_c = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                    fname: "lower Upper",
                    notes: engine.notes,
                    vault,
                })) === null || _c === void 0 ? void 0 : _c.title,
                expected: "lower Upper",
            },
        ];
    }),
};
const NOTES_MULTI = {
    NEW_DOMAIN: new utilsv2_1.TestPresetEntryV4(async ({ vaults, engine }) => {
        const vault = vaults[1];
        const noteNew = common_all_1.NoteUtilsV2.create({
            id: "bar",
            fname: "bar",
            created: "1",
            updated: "1",
            vault: vaults[1],
        });
        await engine.writeNote(noteNew);
        const resp = await engine.queryNotes({ qs: "bar", vault });
        const note = resp.data[0];
        return [
            {
                actual: note,
                expected: engine.notes[note.id],
                msg: "bar should be written in engine",
            },
            {
                actual: common_all_1.DNodeUtilsV2.isRoot(engine.notes[note.parent]),
                expected: true,
            },
        ];
    }),
    NEW_DOMAIN_WITH_FULL_PATH_VAULT: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        const vault = { ...vaults[1] };
        vault.fsPath = path_1.default.join(wsRoot, vault.fsPath);
        const noteNew = common_all_1.NoteUtilsV2.create({
            id: "bar",
            fname: "bar",
            created: "1",
            updated: "1",
            vault: vaults[1],
        });
        await engine.writeNote(noteNew);
        const resp = await engine.queryNotes({ qs: "bar", vault });
        const note = resp.data[0];
        return [
            {
                actual: note,
                expected: engine.notes[note.id],
                msg: "bar should be written in engine",
            },
            {
                actual: common_all_1.DNodeUtilsV2.isRoot(engine.notes[note.parent]),
                expected: true,
            },
        ];
    }),
};
exports.ENGINE_WRITE_PRESETS = {
    NOTES,
    SCHEMAS,
};
exports.ENGINE_WRITE_PRESETS_MULTI = {
    NOTES: NOTES_MULTI,
};
//# sourceMappingURL=write.js.map