"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ENGINE_DELETE_PRESETS = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const __1 = require("../..");
const noteUtils_1 = require("../../noteUtils");
const utilsv2_1 = require("../../utilsv2");
const schemas_1 = require("../schemas");
const utils_1 = require("./utils");
const SCHEMAS = {
    BASIC: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        const vault = vaults[0];
        const schemaId = schemas_1.SCHEMA_PRESETS_V4.SCHEMA_SIMPLE.fname;
        await engine.deleteSchema(schemaId);
        return [
            { actual: lodash_1.default.size(engine.schemas), expected: 1 },
            { actual: engine.schemas[schemaId], expected: undefined },
            {
                actual: await __1.FileTestUtils.assertInVault({
                    vault,
                    wsRoot,
                    nomatch: [`${schemaId}.schema.yml`],
                }),
                expected: true,
            },
        ];
    }, {
        preSetupHook: utils_1.setupBasic,
    }),
};
const NOTES = {
    NOTE_NO_CHILDREN: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        var _a;
        const vault = vaults[0];
        const notes = engine.notes;
        const resp = await engine.deleteNote((_a = common_all_1.NoteUtilsV2.getNoteByFnameV4({ fname: "foo.ch1", vault, notes })) === null || _a === void 0 ? void 0 : _a.id);
        const changed = resp.data;
        const vpath = common_server_1.vault2Path({ vault, wsRoot });
        return [
            { actual: changed[0].note.id, expected: "foo" },
            { actual: lodash_1.default.size(notes), expected: 3 },
            { actual: notes["foo"].children, expected: [] },
            {
                actual: lodash_1.default.includes(fs_extra_1.default.readdirSync(vpath), "foo.ch1.md"),
                expected: false,
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            await noteUtils_1.NoteTestUtilsV4.createNote({
                fname: "foo",
                vault: vaults[0],
                wsRoot,
            });
            await noteUtils_1.NoteTestUtilsV4.createNote({
                fname: "foo.ch1",
                vault: vaults[0],
                wsRoot,
                body: "",
            });
        },
    }),
    DOMAIN_CHILDREN: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        const vault = vaults[0];
        const noteToDelete = common_all_1.NoteUtilsV2.getNoteByFnameV4({
            fname: "foo",
            vault,
            notes: engine.notes,
        });
        const resp = await engine.deleteNote(noteToDelete === null || noteToDelete === void 0 ? void 0 : noteToDelete.id);
        const changed = resp.data;
        const notes = engine.notes;
        const vpath = common_server_1.vault2Path({ vault, wsRoot });
        return [
            {
                actual: changed,
                expected: [{ note: notes["foo"], status: "update" }],
                msg: "note updated",
            },
            {
                actual: lodash_1.default.size(notes),
                expected: 4,
                msg: "same number of notes",
            },
            {
                actual: notes["foo"].stub,
                expected: true,
                msg: "foo should be a stub",
            },
            {
                actual: lodash_1.default.includes(fs_extra_1.default.readdirSync(vpath), "foo.md"),
                expected: false,
                msg: "note should be deleted",
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            await noteUtils_1.NoteTestUtilsV4.createNote({
                fname: "foo",
                vault: vaults[0],
                wsRoot,
            });
            await noteUtils_1.NoteTestUtilsV4.createNote({
                fname: "foo.ch1",
                vault: vaults[0],
                wsRoot,
                body: "",
            });
        },
    }),
    DOMAIN_NO_CHILDREN: new utilsv2_1.TestPresetEntryV4(async ({ wsRoot, vaults, engine }) => {
        const vault = vaults[0];
        const noteToDelete = common_all_1.NoteUtilsV2.getNoteByFnameV4({
            fname: "foo",
            vault,
            notes: engine.notes,
        });
        const resp = await engine.deleteNote(noteToDelete === null || noteToDelete === void 0 ? void 0 : noteToDelete.id);
        const changed = resp.data;
        const notes = engine.notes;
        const vpath = common_server_1.vault2Path({ vault, wsRoot });
        return [
            {
                actual: changed[0].note.fname,
                expected: "root",
                msg: "root updated",
            },
            {
                actual: changed[0].note.children,
                expected: [],
                msg: "root does not have children",
            },
            { actual: lodash_1.default.size(notes), expected: 2 },
            { actual: notes["foo"], expected: undefined },
            {
                actual: lodash_1.default.includes(fs_extra_1.default.readdirSync(vpath), "foo.md"),
                expected: false,
            },
        ];
    }, {
        preSetupHook: async ({ vaults, wsRoot }) => {
            await noteUtils_1.NoteTestUtilsV4.createNote({
                fname: "foo",
                vault: vaults[0],
                wsRoot,
            });
        },
    }),
};
exports.ENGINE_DELETE_PRESETS = {
    NOTES,
    SCHEMAS,
};
//# sourceMappingURL=delete.js.map