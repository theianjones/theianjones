---
id: 8205cbf7-bf3c-4ee6-b6ba-4c9412092250
title: debugging gatsby build for testing js
desc: ''
updated: 1606852499533
created: 1606852499533
parent: 4b3a540b-b1d6-4810-aa30-a08f1c7bef2a
children: []
fname: scratch.2020.12.01.145458
hpath: scratch.2020.12.01.145458
---
```js
const crypto = require('crypto')
const fetch = require('node-fetch')
const assert = require('assert')
const filter = require('lodash/filter')
const forEach = require('lodash/forEach')
const map = require('lodash/map')
const processData = require('./processData')

const axios = require('axios')

const interviewsCourseSlug = 'testing-javascript-interviews-bonus'
const introVideosPlaylistSlug = 'testing-javascript-workshop-intros-245f11c1'

axios.defaults.headers.common[
  'Authorization'
] = `Bearer ${process.env.BUNDLE_BUDDY_TOKEN}`

const loadLessonForCourses = async (playlist) => {
  const courses = filter(playlist.items, (item) => {
    return item.type === 'course' && item.slug !== interviewsCourseSlug
  })

  const courseWithLessons = courses.map(async (course) => {
    if (!course.lessons_url) return course
    console.log(course.slug)
    const lessons = await axios(course.lessons_url)
    return {...course, lessons: lessons.data}
  })

  return Promise.all(courseWithLessons).then((courses) => {
    return {...playlist, courses}
  })
}

const loadInterviews = async (createNodeId) => {
  const interviewsApiUrl = `${process.env.AUTH_DOMAIN}/api/v1/series/${interviewsCourseSlug}?load_lessons=true`

  const interviewCourse = await axios(interviewsApiUrl)

  return interviewCourse.data.lessons.map((lesson) => {
    return {
      id: createNodeId(lesson.slug),
      data: lesson,
    }
  })
}

const loadIntros = async (createNodeId) => {
  const introPlaylistUrl = `${process.env.AUTH_DOMAIN}/api/v1/playlists/${introVideosPlaylistSlug}`
  const introPlaylist = await axios(introPlaylistUrl)
  return introPlaylist.data.items.map((item) => {
    return {
      id: createNodeId(item.slug),
      data: item,
    }
  })
}

const contentOrder = {
  'fundamentals-of-testing-in-javascript': 1,
  'static-analysis-testing-javascript-applications-71c1': 2,
  'javascript-mocking-fundamentals': 3,
  'configure-jest-for-testing-javascript-applications-b3674a': 4,
  'test-react-components-with-jest-and-react-testing-library-82bd': 5,
  'install-configure-and-script-cypress-for-javascript-web-applications-8184': 6,
  'use-dom-testing-library-to-test-any-js-framework': 7,
  'test-node-js-backends': 8,
  'testing-javascript-interviews-bonus': 9,
}

const sortBundles = (playlists) => {
  const sortedPlaylists = forEach(playlists, ({items}) =>
    items.sort((item1, item2) => {
      const item1Order = contentOrder[item1.slug] || 9
      const item2Order = contentOrder[item2.slug] || 9
      return item1Order - item2Order
    }),
  )

  return {playlists: sortedPlaylists}
}

exports.sourceNodes = async (
  {actions: {createNode}, createNodeId},
  {plugins, ...options},
) => {
  assert(
    process.env.BUNDLE_BUDDY_TOKEN !== undefined,
    'You must have the BUNDLE_BUDDY_TOKEN env variable set!',
  )

  const headers = {
    Authorization: `Bearer ${process.env.BUNDLE_BUDDY_TOKEN}`,
    'Content-Type': 'application/json',
  }

  const proBundleFetcher = fetch(
    `${process.env.AUTH_DOMAIN}/api/v1/playlists/pro-testing`,
    {headers},
  ).then((response) => response.json())
  const standardBundleFetcher = fetch(
    `${process.env.AUTH_DOMAIN}/api/v1/playlists/standard-testing`,
    {headers},
  ).then((response) => response.json())
  const basicBundleFetcher = fetch(
    `${process.env.AUTH_DOMAIN}/api/v1/playlists/basic-testing`,
    {headers},
  ).then((response) => response.json())
  // const apiUrl = `${process.env.AUTH_DOMAIN}${bundleApiPath}`
  const bundleResponse = await Promise.all([
    proBundleFetcher,
    standardBundleFetcher,
    basicBundleFetcher,
  ]).then((response) => {
    if (response.status === 403) {
      throw 'Request failed, is your BUNDLE_BUDDY_TOKEN valid?'
    }
    return response
  })

  const bundles = sortBundles(bundleResponse)
  // const bundleResponse = await fetch(apiUrl, {
  //   headers,
  // }).then(response => {
  //   if (response.status === 403) {
  //     throw 'Request failed, is your BUNDLE_BUDDY_TOKEN valid?'
  //   }
  //   return response
  // })

  // const bundles = await bundleResponse.json().then(sortBundles)

  const playlistData = await Promise.all(
    bundles.playlists.map(loadLessonForCourses),
  )

  const packageBundles = (bundleData) => {
    const {id, data, lessons, courses} = bundleData
    const {title, description, slug, price, url, full_price, ...crap} = data
    const nodeContent = JSON.stringify(data)
    const nodeContentDigest = crypto
      .createHash('md5')
      .update(nodeContent)
      .digest('hex')

    const node = {
      id,
      title,
      description,
      slug,
      price,
      hasExtras: slug === 'pro-testing',
      canDownload: slug === 'pro-testing',
      fullPrice: full_price,
      url,
      path: `/bundles/${slug}`,
      lessons___NODE: lessons,
      courses___NODE: courses,
      sellableType: 'playlist',
      sellableID: slug,
      purchaseURL: `${process.env.AUTH_DOMAIN}/api/v1/sellable_purchases`,
      content: nodeContent,
      internal: {
        type: 'Bundle',
        contentDigest: nodeContentDigest,
      },
    }
    createNode(node)
  }

  const packageCourses = (courseData) => {
    const {id, data, lessons, playlists} = courseData
    const nodeContent = JSON.stringify(data)
    const nodeContentDigest = crypto
      .createHash('md5')
      .update(nodeContent)
      .digest('hex')

    const displayOrder = contentOrder[data.slug] || 9
    const node = {
      ...data,
      displayOrder,
      id,
      lessons___NODE: lessons,
      bundles___NODE: playlists,
      content: nodeContent,
      internal: {
        type: 'Course',
        contentDigest: nodeContentDigest,
      },
    }
    createNode(node)
  }

  const packageLessons = (lessonData) => {
    const {id, data, course, playlists} = lessonData

    const nodeContent = JSON.stringify(data)
    const nodeContentDigest = crypto
      .createHash('md5')
      .update(nodeContent)
      .digest('hex')

    const node = {
      ...data,
      id,
      playlists___NODE: playlists,
      course___NODE: course,
      content: nodeContent,
      internal: {
        type: 'Lesson',
        contentDigest: nodeContentDigest,
      },
    }
    createNode(node)
  }

  const packageInterviews = (interviewData) => {
    const {id, data} = interviewData
    const nodeContent = JSON.stringify(data)
    const nodeContentDigest = crypto
      .createHash('md5')
      .update(nodeContent)
      .digest('hex')

    const node = {
      ...data,
      id,
      type: 'interview',
      content: nodeContent,
      internal: {
        type: 'Interview',
        contentDigest: nodeContentDigest,
      },
    }

    createNode(node)
  }

  const packageIntros = (introData) => {
    const {id, data} = introData
    const nodeContent = JSON.stringify(data)
    const nodeContentDigest = crypto
      .createHash('md5')
      .update(nodeContent)
      .digest('hex')

    const node = {
      ...data,
      id,
      type: 'intro',
      content: nodeContent,
      internal: {
        type: 'Intro',
        contentDigest: nodeContentDigest,
      },
    }

    createNode(node)
  }

  const interviews = await loadInterviews(createNodeId)
  const intros = await loadIntros(createNodeId)
  const {playlists, courses, lessons} = processData(playlistData, createNodeId)
  intros.map(packageIntros)
  playlists.map(packageBundles)
  courses.map(packageCourses)
  lessons.map(packageLessons)
  interviews.map(packageInterviews)
}
```

